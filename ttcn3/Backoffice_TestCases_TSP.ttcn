/**
 * @author  PT0140 
 * @desc    This module provides test cases based on TS 16986 TPs
 * @see     [xxxx-1:2017]: Test suite structure and test purpose
 * @see     [xxxx-1:2016], Clause 5.2.1  Namimg conventions
 * @version $id$
 */
module Backoffice_TestCases_TSP {
    /**
     * @desc    [12855:2015]: 
     * @see     Annex A (normative)  data type specifications
     */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     *          Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
     */
    import from Common_Parameterised_Asn1_Data all;
    import from Backoffice_Interfaces all;
    import from Backoffice_Functions all;
    import from Backoffice_Pixits all;
    import from Backoffice_Pics all;
    import from Backoffice_Templates all;
	
    /**
     /**
      * @desc    These Test Cases apply to Toll Service Provider claiming conformance to [16986:2016] and applying Test Purposes as from TS xxxxx:2018 Annex B
      * @remark  nn TCs
      */
    group Base {
         /**
          * @desc    Test subgroup objective:
          * - to test IUT with respect to the correctness of base and general functionalities that are required in many or all transaction types;
          */
     	group Valid_Behaviour {
             /**
              * @desc    TP_TSP_Base_BV_01: Verify that a TC validates correct infoExchanceAuthenticators in received APDUs and generates correct infoExchangeAuthenticators 
              * @remark  [16986:2016], Clause 6.2.2 and Table A.1/2 
              */
             testcase TP_TSP_Base_BV_01() runs on IutComp system TestAdapter {
                 
             } // TP_TSP_Base_BV_01
        } // End of group Valid_Behaviour
         
        group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour
        
    } // End of group Base
    
    group LISTOFUSERS {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour
        
    } // End of group LISTOFUSERS

    group USERDETAILS {
    
          group Valid_Behaviour {

             testcase TP_TSP_USERDETAILS_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_USERDETAILS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserDetailsADUs 
                  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var Apci v_apci;
                var ProvideUserDetailsADUs v_userDetails;
				var ApduIdentifier v_receivedAPDUIdentifier;
				var UserId v_Userid; // value to be taken from PIXIT
                    
                   
                 // Preamble - Initial Conditions
                 f_Backoffice_Preamble();
                 // Front End shall initially receive a Request
                 // named as Transaction sequence #1
                 f_SendAPDU(m_user_Details_Request userId := v_Userid);
    
                 // Preamble done
    
                 // Test body start
                 t_UserDetails_Time1.start;
                 // Transaction sequence #2: Wait for UserDetails message

				 					
// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
// timeout expiration handling is in the altstep branch

                 alt {
                      [] f_receiveAPDUs(mw_userDetails userid := v_Userid, v_apci, v_userDetails) {
                      		
							// User Details ADU arrived. Stop timer
                        	t_UserDetails_Time1.stop;
                            
                        // Transaction sequence #3: Send DefaultACK with correct identifier and set verdict
                        
                        v_receivedAPDUIdentifier := v_apci.apduIdentifier;

                        
						f_SendAPDU(m_defaultAck apci.apduIdentifier := v_receivedAPDUIdentifier);

//                       
						setverdict(pass);
                      }
                    } // End of alt statement

             } // End of TP_TSP_USERDETAILS_BV_01
            
            testcase TP_TSP_USERDETAILS_BV_02() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BV_02: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of data privacy issues 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */
              
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var Apci v_apci;
                var ProvideUserDetailsADUs v_userDetails;
				var ApduIdentifier v_receivedAPDUIdentifier;
 				var UserId v_Userid; // value to be taken from PIXIT
 				                   
                   
                 // Preamble - Initial Conditions
                 f_Backoffice_Preamble();
                 // Front End shall initially receive a Request
                 // named as Transaction sequence #1
                
				f_SendRequestAPDU(m_user_Details_PrivacyBound_Request userId := v_Userid);

                // Preamble done

                // Test body start
				t_UserDetails_Time1.start;
                // transaction sequence #2: Wait for UserDetails message


// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
// timeout expiration handling is in the altstep branch

                  alt {
                	    [] f_receiveAPDUs(mw_userDetailsPrivacy_apduIdentifier userId := v_Userid,  v_apci, v_userDetails)  { 

                        // Stop timer
                	       t_UserDetails_Time1.stop;
                        
                 // Transaction sequence #3: Send DefaultACK
                 
                  			v_receivedAPDUIdentifier := v_apci.apduIdentifier;

                			f_SendAPDU(m_defaultAck apci.apduIdentifier := v_receivedAPDUIdentifier);
                 //  Set verdict pass
                 	    	setverdict(pass);
                    		}
                 }// End of alt statement

             } // End of TP_TSP_USERDETAILS_BV_02
                         
 		} // End of group Valid_Behaviour
         
        group Invalid_Behaviour {

            testcase TP_TSP_USERDETAILS_BI_01() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_01: Verify that the TSP correctly responds to an incorrect RequestADUs of type userDetailsRequest 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */
          
             // Local variables

                var AckADU v_receivedAck;
				var InfoExchangeContent v_infoExchangeContent;
				var ApduIdentifier v_APDUIdentifier;
				var UserId v_Userid; // value to be taken from PIXIT
				
                
                
                // Preamble - Initial Conditions
                
               f_Backoffice_Preamble();
                 // Front End shall initially receive a Request
                 // named as Transaction sequence #1

                f_SendRequestAPDU(m_user_Details_Invalid_Request) -> value v_APDUIdentifier; // Store assigned identifier for checking correct AcK

                // Preamble done

                // Test body start

                t_UserDetails_Time1.start;

                // transaction sequence #2: Wait for Nack message with semantic error code
// Either we receive an APDU containing Nack or the timeout expires
// timeout expiration handling is in the altstep branch				
                alt {
                    [] f_receiveAPDUs(m_defaultAck {ApduIdentifier := v_APDUIdentifier, apduAckCode:= 3000},  v_apci, v_receivedAck) { // No specific test was required
                        // Stop timer
                        t_UserDetails_Time1.stop;
                       //  Set verdict pass
                        setverdict(pass);
                    }
                } // End of alt statement
                
                // Test body done

             } // End of TP_TSP_USERDETAILS_BI_01
                         
            testcase TP_TSP_USERDETAILS_BI_02() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_02: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing non-supported user details
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */          
             // Local variables
                var AckADU v_receivedAck;
				var InfoExchangeContent v_infoExchangeContent;
                var ProvideUserDetailsADU v_userDetails;
				var UserId v_Userid; // value to be taken from PIXIT
				var ApduIdentifier v_receivedAPDUIdentifier;
				var record of integer v_SupportedParameters; // should be initialised with PIXIT value supportedListOfParameters
                
                // Preamble - Initial Conditions
                f_Backoffice_Preamble();

// Front End shall initially receive a Request named as Transaction sequence #1
// Create a value that is not supported by the IUT
				for (var integer v_Support :=1; v_Support:=v_Support+1)
					if not(isvalue(v_SupportedParameters{v_Support}) ) v_unsupported := v_Support; break;
					continue;
// Invalid Parameter to be requested found and to be sent to IuT	
                f_SendRequestAPDU(m_user_Details_Request {userId := v_Userid,listOfParametersRequested := v_unsupported}) -> value v_APDUIdentifier; // Store assigned identifier for checking correct AcK

                // Preamble done

                // Test body start
                t_UserDetails_Time1.start;
                // transaction sequence #2: Wait for Nack message
// Either we receive an APDU containing Nack or the timeout expires
// timeout expiration handling is in the altstep branch	
                alt {
                    [] f_receiveAPDUs(mw_userDetails {userid := v_Userid, listOfUserParameters.userParameterStatus := 1, listOfUserParameters.UserParameterResponse := omit, listOfUserParameters.userInfoValidityPeriod := omit }, v_apci, v_userDetails,  v_apci, v_receivedAck) { // No specific test was required
                        // Stop timer
                        t_UserDetails_Time1.stop;
                       //  Set verdict pass
                        setverdict(pass);
                    }
                } // End of alt statement
                // Test body done

             } // End of TP_TSP_USERDETAILS_BI_02

            testcase TP_TSP_USERDETAILS_BI_03() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_03: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of missing agreement
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */       

             // Local variables
                var AckADU v_receivedAck;
				var InfoExchangeContent v_infoExchangeContent;
                var ProvideUserDetailsADU v_userDetails;
				var UserId v_Userid; // value to be taken from PIXIT
				var ApduIdentifier v_receivedAPDUIdentifier;
				var record of integer v_NotAgreedParameters; // should be initialised with PIXIT value notAgreedListOfParameters
                
                // Preamble - Initial Conditions
                f_Backoffice_Preamble();

// Front End shall initially receive a Request named as Transaction sequence #1
// Create a value that is not supported by the IUT
				for (var integer v_Support :=1; v_Support:=v_Support+1)
					if isvalue(v_NotAgreedParameters{v_Support}) v_unsupported := v_Support; break;
					continue;
// Invalid Parameter to be requested found and to be sent to IuT	
                f_SendRequestAPDU(m_user_Details_Request {userId := v_Userid,listOfParametersRequested := v_unsupported}) -> value v_APDUIdentifier; // Store assigned identifier for checking correct AcK

                // Preamble done

                // Test body start
                t_UserDetails_Time1.start;
                // transaction sequence #2: Wait for Nack message
// Either we receive an APDU containing Nack or the timeout expires
// timeout expiration handling is in the altstep branch	
                alt {
                    [] f_receiveAPDUs(mw_userDetails {userid := v_Userid, listOfUserParameters.userParameterStatus := 3, listOfUserParameters.UserParameterResponse := omit, listOfUserParameters.userInfoValidityPeriod := omit }, v_apci, v_userDetails,  v_apci, v_receivedAck) { // No specific test was required
                        // Stop timer
                        t_UserDetails_Time1.stop;
                       //  Set verdict pass
                        setverdict(pass);
                    }
                } // End of alt statement
                // Test body done
            } // End of TP_TSP_USERDETAILS_BI_03
            
            testcase TP_TSP_USERDETAILS_BI_04() runs on IutComp system TestAdapter {

             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_04: Verify that a TSP responds correctly to a RequestADU sent earlier than allowed 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */

             // Local variables
                var AckADU v_receivedAck;
				var InfoExchangeContent v_infoExchangeContent;
                var ProvideUserDetailsADU v_userDetails;
				var ApduIdentifier v_receivedAPDUIdentifier;

                
                // Preamble - Initial Conditions
                f_Backoffice_Preamble();
// Front End shall initially receive a Request

                f_SendRequestAPDU(m_user_Details_Request)-> value v_APDUIdentifier;
                
                // Preamble done

                // Test body start
                // transaction sequence #1: Send a second request immediately
                f_SendRequestAPDU(m_user_Details_Request) -> value v_APDUIdentifier;

                t_UserDetails_Time1.start;
                // transaction sequence #2: Wait for Nack message
                alt {
                    [] f_receiveAPDUs(m_defaultAck {ApduIdentifier := v_APDUIdentifier, apduAckCode:= NAck_requestSentTooOften},  v_apci, v_receivedAck)  {
                        // Stop timer
                        t_UserDetails_Time1.stop;

                        //  Set verdict pass
                        setverdict(pass);
                    }
                } // End of alt statement

                // Test body done
        	} // End of TP_TSP_USERDETAILS_BI_04


        } // End of group Invalid_Behaviour
 
    } // End of group USERDETAILS
    
    group EXCEPTIONLIST {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group EXCEPTIONLIST
    
    group TRUSTOBJECTS {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group TRUSTOBJECTS
    
    group PAYMENTCLAIM {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group PAYMENTCLAIM
    
    group DSRC_CONTRACTISSUERLIST {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.CONTRACTISSUERLIST
    
    group DSRC_EFCCONTEXTDATA {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.EFCCONTEXTDATA
    
    group DSRC_BILLINGDETAILS {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.BILLINGDETAILS
    
    group DSRC_REPORTABNORMALOBE {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.REPORTABNORMALOBE
    
    group GNSS_TOLLDECLARATION {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.TOLLDECLARATION
    group GNSS_BILLINGDETAILS_TSP {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS_TSP
    
    group GNSS_BILLINGDETAILS_TC {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS.TC
    
    group GNSS_PAYMENTANNOUNCEMENT {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.PAYMENTANNOUNCEMENT
} // End of module Toll_Service_Provider
