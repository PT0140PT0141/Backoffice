/**
 * @author  PT0140 
 * @desc    This module provides test cases based on TS 16986 TPs
 * @see     [xxxx-1:2017]: Test suite structure and test purpose
 * @see     [xxxx-1:2016], Clause 5.2.1  Namimg conventions
 * @version $id$
 */
module Backoffice_TestCases_TSP {
    /**
     * @desc    [12855:2015]: 
     * @see     Annex A (normative)  data type specifications
     */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     *          Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
     */
    import from Common_Parameterised_Asn1_Data all;
    import from Backoffice_Interfaces all;
    import from Backoffice_Functions all;
    import from Backoffice_Pixits all;
    import from Backoffice_Pics all;
    import from Backoffice_Templates all;
	
    /**
     /**
      * @desc    These Test Cases apply to Toll Service Provider claiming conformance to [16986:2016] and applying Test Purposes as from TS xxxxx:2018 Annex B
      * @remark  nn TCs
      */
    group Base {
         /**
          * @desc    Test subgroup objective:
          * - to test IUT with respect to the correctness of base and general functionalities that are required in many or all transaction types;
          */
     	group Valid_Behaviour {
             /**
              * @desc    TP_TSP_Base_BV_01: Verify that a TC validates correct infoExchanceAuthenticators in received APDUs and generates correct infoExchangeAuthenticators 
              * @remark  [16986:2016], Clause 6.2.2 and Table A.1/2 
              */
             testcase TP_TSP_Base_BV_01() runs on IutComp system TestAdapter {
                 
             } // TP_TSP_Base_BV_01
        } // End of group Valid_Behaviour
         
        group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour
        
    } // End of group Base
    
    group LISTOFUSERS {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour
        
    } // End of group LISTOFUSERS

    group USERDETAILS {
    
          group Valid_Behaviour {

             testcase TP_TSP_USERDETAILS_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_USERDETAILS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserDetailsADUs 
                  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                var ProvideUserDetailsADUs v_userDetails;
				var ApduIdentifier v_receivedAPDUIdentifier;
				var UserId v_Userid; // value to be taken from PIXIT
				var listOfParametersRequested v_ListOfParameters;   
                   
                 // Preamble - Initial Conditions
                 v_Userid := DEFINED_USERID; // value to be taken from PIXIT 
                 
// we want to ask for a random number of parameters randomly chosen among those supported
// the v_listOfParameters record will be made of a random number of elements containing randomly picked up
// parameter identifiers from the list of supported parameters (PIXIT value)

                 const integer maxParms := float2int(rnd()) mod sizeof(SUPPORTED_LIST_OF_PARAMETERS);
                 for (var integer v_ct :=0; v_ct<maxParms;v_ct:=v_ct+1) {
                   v_ListOfParameters[v_ct] := SUPPORTED_LIST_OF_PARAMETERS[float2int(rnd()) mod sizeof(SUPPORTED_LIST_OF_PARAMETERS)];
                 };
// IUT shall initially receive a Request as per Transaction sequence #1
// the request is made with the list of parameters just elaborated and stored as the only field
// of the record of type requestAdus
// The f_prepare_toSend_InfoExchange function builds the APDU to be sent from the record of ADUs provided
                
                 v_Request[0] := f_prepare_toSend_InfoExchange(m_user_Details_Request {listOfParametersRequested := v_ListOfParameters});
 
 // The ADU is sent by the f_sendAPDU function, which builds the apci for InfoExchangeContent and appends
 // the ApduAuthenticator if so requirered by the PICS               
                
                 f_SendAPDU(v_Request);
                 
 // Prepare data to receive
				v_userDetails := mw_userDetails;
// The f_prepare_toReceive_InfoExchange function prepares the InfoExchangeContent by concatenating the expected
// ADU to be received with the proper apci and returns the complete APDU to be received
				
				v_infoExchange := f_prepare_toReceive_InfoExchange (v_userDetails) ;  
    
// Test body start
                 t_UserDetails_Time1.start;
// Transaction sequence #2: Wait for UserDetails message
				 					
// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
// timeout expiration handling is supposedly in the altstep branch

                 alt {
 // Storing what we received in the same variable (not very clean ...)
                      [] IutComp.receive(v_infoExchange) -> value v_infoExchange {
                      		
						// User Details ADU arrived. Stop timer
                        	t_UserDetails_Time1.stop;
                            
                        // Transaction sequence #3: Send DefaultACK with correct identifier and set verdict
                        
                        v_receivedAPDUIdentifier := v_infoExchange.apci.apduIdentifier;

						// The f_prepare_toSend_InfoExchange function builds the APDU to be sent from the record of ADUs provided
                
                 		v_Ack[0] := f_prepare_toSend_InfoExchange(m_defaultAck);
 
 // The ADU is sent by the f_sendAPDU function, which builds the apci for InfoExchangeContent and appends
 // the ApduAuthenticator if so requirered by the PICS
 // Note that this time we pass the identifier of the APDU to be Acked, because that is required by 16986 for Acks               
                
						f_SendAPDU(v_Ack, v_receivedAPDUIdentifier);

//                       
						setverdict(pass);
                      }
                    } // End of alt statement

             } // End of TP_TSP_USERDETAILS_BV_01
            
            testcase TP_TSP_USERDETAILS_BV_02() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BV_02: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of data privacy issues 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */
              
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var Apci v_apci;
                var ProvideUserDetailsADUs v_userDetails;
				var ApduIdentifier v_receivedAPDUIdentifier;
 				var UserId v_Userid;
				var listOfParametersRequested v_ListOfParameters;    				                   
                   
                 // Preamble - Initial Conditions
                v_Userid := DEFINED_USERID; // value to be taken from PIXIT 
				v_ListOfParameters := PRIVACYBOUND_LIST_OF_PARAMETERS;   

                 f_Backoffice_Preamble();
                 // Front End shall initially receive a Request
                 // named as Transaction sequence #1
                
				 f_SendAPDU(m_user_Details_Request {listOfParametersRequested := v_ListOfParameters});

                // Preamble done

                // Test body start
				t_UserDetails_Time1.start;
                // transaction sequence #2: Wait for UserDetails message


// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
// timeout expiration handling is in the altstep branch

                  alt {
                	    [] f_receiveAPDUs(mw_userDetailsPrivacy_apduIdentifier userId := v_Userid,  v_apci, v_userDetails)  { 

                        // Stop timer
                	       t_UserDetails_Time1.stop;
                        
                 // Transaction sequence #3: Send DefaultACK
                 
                  			v_receivedAPDUIdentifier := v_apci.apduIdentifier;

                			f_SendAPDU(m_defaultAck apci.apduIdentifier := v_receivedAPDUIdentifier);
                 //  Set verdict pass
                 	    	setverdict(pass);
                    		}
                 }// End of alt statement

             } // End of TP_TSP_USERDETAILS_BV_02
                         
 		} // End of group Valid_Behaviour
         
        group Invalid_Behaviour {

            testcase TP_TSP_USERDETAILS_BI_01() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_01: Verify that the TSP correctly responds to an incorrect RequestADUs of type userDetailsRequest 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */
          
             // Local variables

                var AckADU v_receivedAck;
				var InfoExchangeContent v_infoExchangeContent;
				var ApduIdentifier v_APDUIdentifier;				
                
                
                // Preamble - Initial Conditions
                
               f_Backoffice_Preamble();
                 // Front End shall initially receive a Request
                 // named as Transaction sequence #1

                f_SendRequestAPDU(m_user_Details_Invalid_Request) -> value v_APDUIdentifier; // Store assigned identifier for checking correct AcK

                // Preamble done

                // Test body start

                t_UserDetails_Time1.start;

                // transaction sequence #2: Wait for Nack message with semantic error code
// Either we receive an APDU containing Nack or the timeout expires
// timeout expiration handling is in the altstep branch				
                alt {
                    [] f_receiveAPDUs(m_defaultAck {ApduIdentifier := v_APDUIdentifier, apduAckCode:= 3000},  v_apci, v_receivedAck) { // No specific test was required
                        // Stop timer
                        t_UserDetails_Time1.stop;
                       //  Set verdict pass
                        setverdict(pass);
                    }
                } // End of alt statement
                
                // Test body done

             } // End of TP_TSP_USERDETAILS_BI_01
                         
            testcase TP_TSP_USERDETAILS_BI_02() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_02: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing non-supported user details
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */          
             // Local variables
                var AckADU v_receivedAck;
				var InfoExchangeContent v_infoExchangeContent;
                var ProvideUserDetailsADU v_userDetails;
				var UserId v_Userid; // value to be taken from PIXIT
				var ApduIdentifier v_receivedAPDUIdentifier;
				var listOfParametersRequested v_SupportedParameters; // should be initialised with PIXIT value supportedListOfParameters
                var integer v_unsupported;
                var boolean found;
                
                // Preamble - Initial Conditions
                f_Backoffice_Preamble();

// Front End shall initially receive a Request named as Transaction sequence #1
// Create a value that is not supported by the IUT
				v_SupportedParameters := SUPPORTED_LIST_OF_PARAMETERS;
				found := false;
				for (var integer v_Support :=0;  v_Support:=v_Support+1, found := false)
					for (var integer v_ind := 0, v_ind < sizeof(SUPPORTED_LIST_OF_PARAMETERS), v_ind := v_ind + 1)
						if NOT( v_SupportedParameters[v_IND]  := v_Support) v_unsupported := v_Support; found := true; break;
						continue;
					continue;
// Invalid Parameter to be requested found and to be sent to IuT	
                f_SendRequestAPDU(m_user_Details_Request {userId := v_Userid,listOfParametersRequested[0] := v_unsupported}) -> value v_APDUIdentifier; // Store assigned identifier for checking correct AcK

                // Preamble done

                // Test body start
                t_UserDetails_Time1.start;
                // transaction sequence #2: Wait for Nack message
// Either we receive an APDU containing Nack or the timeout expires
// timeout expiration handling is in the altstep branch	
                alt {
                    [] f_receiveAPDUs(mw_userDetails {userid := v_Userid, listOfUserParameters.userParameterStatus := 1, listOfUserParameters.UserParameterResponse := omit, listOfUserParameters.userInfoValidityPeriod := omit }, v_apci, v_userDetails,  v_apci, v_receivedAck) { // No specific test was required
                        // Stop timer
                        t_UserDetails_Time1.stop;
                       //  Set verdict pass
                        setverdict(pass);
                    }
                } // End of alt statement
                // Test body done

             } // End of TP_TSP_USERDETAILS_BI_02

            testcase TP_TSP_USERDETAILS_BI_03() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_03: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of missing agreement
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */       

             // Local variables
                var AckADU v_receivedAck;
				var InfoExchangeContent v_infoExchangeContent;
                var ProvideUserDetailsADU v_userDetails;
				var UserId v_Userid; // value to be taken from PIXIT
				var ApduIdentifier v_receivedAPDUIdentifier;
				var integer v_unsupported; // should be initialised with PIXIT value notAgreedListOfParameters
                
                // Preamble - Initial Conditions
                f_Backoffice_Preamble();

// Front End shall initially receive a Request named as Transaction sequence #1
/// Take a random value among those  not agreed upon by the IUT
				v_unsupported := NOT_AGREED_LIST[float2int(rnd()) mod sizeof(NOT_AGREED_LIST)];

                f_SendRequestAPDU(m_user_Details_Request {listOfParametersRequested[0] := v_unsupported}) -> value v_APDUIdentifier; // Store assigned identifier for checking correct AcK

                // Preamble done

                // Test body start
                t_UserDetails_Time1.start;
                // transaction sequence #2: Wait for Nack message
// Either we receive an APDU containing Nack or the timeout expires
// timeout expiration handling is in the altstep branch	
                alt {
                    [] f_receiveAPDUs(mw_userDetails {listOfUserParameters.userParameterStatus := 3, listOfUserParameters.UserParameterResponse := omit, listOfUserParameters.userInfoValidityPeriod := omit }, v_apci, v_userDetails,  v_apci, v_receivedAck) { // No specific test was required
                        // Stop timer
                        t_UserDetails_Time1.stop;
                       //  Set verdict pass
                        setverdict(pass);
                    }
                } // End of alt statement
                // Test body done
            } // End of TP_TSP_USERDETAILS_BI_03
            
            testcase TP_TSP_USERDETAILS_BI_04() runs on IutComp system TestAdapter {

             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_04: Verify that a TSP responds correctly to a RequestADU sent earlier than allowed 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */

             // Local variables
                var AckADU v_receivedAck;
				var InfoExchangeContent v_infoExchangeContent;
                var ProvideUserDetailsADU v_userDetails;
				var ApduIdentifier v_receivedAPDUIdentifier;

                
                // Preamble - Initial Conditions
                f_Backoffice_Preamble();
// Front End shall initially receive a Request

                f_SendRequestAPDU(m_user_Details_Request)-> value v_APDUIdentifier;
                
                // Preamble done

                // Test body start
                // transaction sequence #1: Send a second request immediately
                f_SendRequestAPDU(m_user_Details_Request) -> value v_APDUIdentifier;

                t_UserDetails_Time1.start;
                // transaction sequence #2: Wait for Nack message
                alt {
                    [] f_receiveAPDUs(m_defaultAck {ApduIdentifier := v_APDUIdentifier, apduAckCode:= NAck_requestSentTooOften},  v_apci, v_receivedAck)  {
                        // Stop timer
                        t_UserDetails_Time1.stop;

                        //  Set verdict pass
                        setverdict(pass);
                    }
                } // End of alt statement

                // Test body done
        	} // End of TP_TSP_USERDETAILS_BI_04


        } // End of group Invalid_Behaviour
 
    } // End of group USERDETAILS
    
    group EXCEPTIONLIST {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group EXCEPTIONLIST
    
    group TRUSTOBJECTS {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group TRUSTOBJECTS
    
    group PAYMENTCLAIM {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group PAYMENTCLAIM
    
    group DSRC_CONTRACTISSUERLIST {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.CONTRACTISSUERLIST
    
    group DSRC_EFCCONTEXTDATA {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.EFCCONTEXTDATA
    
    group DSRC_BILLINGDETAILS {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.BILLINGDETAILS
    
    group DSRC_REPORTABNORMALOBE {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.REPORTABNORMALOBE
    
    group GNSS_TOLLDECLARATION {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.TOLLDECLARATION
    group GNSS_BILLINGDETAILS_TSP {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS_TSP
    
    group GNSS_BILLINGDETAILS_TC {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS.TC
    
    group GNSS_PAYMENTANNOUNCEMENT {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.PAYMENTANNOUNCEMENT
} // End of module Toll_Service_Provider
