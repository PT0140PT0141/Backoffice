/**
 * @author  PT0140 
 * @desc    This module provides test cases based on TS 16986 TPs
 * @see     [xxxx-1:2017]: Test suite structure and test purpose
 * @see     [xxxx-1:2016], Clause 5.2.1  Namimg conventions
 * @version $id$
 */
  /**
 * work in progress Status overview
 *
 *	Transaction type			!	BV					! BI			! Comments
 * 	----------------------------!-----------------------!---------------!--------------------------------
 *	Base						! done					! done			! TrustObject templates to be defined
 *	Userdetails					! done					! done			! to be compiled
 *	ListOfUsers					! done					! done			! to be compiled
 *	ExceptionList				! done					! done			! to be compiled
 *	TrustObjects				! done    				! done			! TrustObject templates to be defined.
 *	PaymentClaim				! done					! done			! BillingDetails and PaymentClaim templates to be defined
 *	DSRC.ContractIssuerList		! done					! done			! Template mw_aduContractIssuerList to be defined
 *	DSRC.EFCContextData			! open					! open			! 
 *	DSRC.BillingDetails			! done					! done			! Billingdetails templates to be defined.
 *	DSRC.ReportAbnormalOBE		! done					! done			! mw_aduReportAbnormalOBE to be defined.
 *	GNSS.TollDeclaration		! done					! done			! mw_aduGnssTollDeclaration template to be defined
 *	GNSS.BillingDetails.TSP		! done					! done			! mw_apduGnssBillingDetails_TSP to be defined
 *	GNSS.BillingDetails.TC		! done					! done			! templates to be defined.
 *	GNSS.PaymentAnnouncement	! done					! done			! mw_aduGnssPaymentAnnouncement template to be defined
 */
 
module EfcInfoExchange_TestCasesTspDev {
    /**
     * @desc    [12855:2015]: 
     * @see     Annex A (normative)  data type specifications
     */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     *          Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
     */
    import from Common_ParametrisedAsn1Data all;
    import from EfcInfoExchange_Interfaces all;
    import from EfcInfoExchange_Functions all;	
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Ics all;
    import from EfcInfoExchange_Templates all;
    import from EfcInfoExchangeProfile all;
    
    
    /**
     /**
      * @desc    These Test Cases apply to Toll Service Provider claiming conformance to [16986:2016] and applying Test Purposes as from TS xxxxx:2018 Annex B
      * @remark  nn TCs
      */
    group Base {
         /**
          * @desc    Test subgroup objective:
          * - to test IUT with respect to the correctness of base and general functionalities that are required in many or all transaction types;
          */
     	group Valid_Behaviour {
			testcase TP_TSP_Base_BV_01() runs on MainTestComponent system TestAdapter {
             /**
              * @desc    TP_TSP_Base_BV_01: Verify that a TC validates correct infoExchanceAuthenticators in received APDUs and generates correct infoExchangeAuthenticators 
              * @remark  [16986:2016], Clause 6.2.2 and Table A.1/2 
              */            
               
               // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS and ICS_A3_3_useAuthenticator;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
                              
               // Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
               // and in addition an infoExchangeAuthenticator = value calculated according to clause 7.3 of EN ISO 12855

				// Prepare the APDU without authenticator
				var InfoExchange apduToBeSent := m_apduSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests), infoExchangeAuthenticator := 1}
					);

				// Compute the authenticator and send the APDU
				apduToBeSent.infoExchangeAuthenticator := fx_computeAuthenticator(apduToBeSent);
                
				// send RequestADU
				f_sendAndLogApdu(apduToBeSent);                                          
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an authenticated APDU containing Provide User Details ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[]	mtcPort.receive(mw_apduAuthenticatedProvideUserDetails) -> value v_apduReceived{    		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						if (fx_evaluateAuthenticator(v_apduReceived)) {
							setverdict(pass);
							// Step3: Send DefaultAck with correct identifier and set verdict
							f_wait(USERDETAILS_TIME2_MIN_TSP);
							f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));							  
							}
						else {
							setverdict(fail)
						};
					}
				} // End of alt statement
				
				f_closeDownMtc();    
             } // TP_TSP_Base_BV_01
        } // End of group Valid_Behaviour
         
        group Invalid_Behaviour {
			testcase TP_TSP_Base_BI_01() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_Base_BI_01: Verify that the TSP correctly responds to invalid aidIdentifier in the APCI field received inside an APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
				
				// Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
				// and in addition containing APCI parameter field containing aidIdentifier â‰  â€œ0â€� and valid RequestADU with requestedADUType=provideUserDetailsADU
				// Just modify the APCI
				template (value) ApciFields m_apciSendFirstInvalidAid modifies m_apciSendFirst:= {aidIdentifier:=0};
				// Then send it together with the request ADU
  				f_sendAndLogApdu(
                             m_apciSendFirstInvalidAid, {m_aduRequestProvideUserDetails(v_userParameterRequests)}
							);
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = protocolVersionError (6)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, ApduReasonCode_protocolVersionError_}}
				var NAckParams v_nAckParams2 :={{1, ApduReasonCode_protocolVersionError_},{2,ApduReasonCode_protocolVersionError_}}
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
			}  // End of Testcase TP_TSP_Base_BI_01
			
			testcase TP_TSP_Base_BI_02() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_Base_BI_02: Verify that the TSP correctly responds to invalid apduOriginator in APCI field received inside an APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
				
				// Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
				// containing apduOriginator â‰  value declared in the PIXIT
				// Retrieve and alter apduOriginator value
				var Provider apduWrongOriginator := APDU_ORIGINATOR_FOR_TESTER;
				apduWrongOriginator.providerIdentifier := apduWrongOriginator.providerIdentifier + 1;
				template (value) ApciFields m_apciSendFirstInvalidAid modifies m_apciSendFirst:= {apduOriginator := apduWrongOriginator};
				// Then send it together with the request ADU
  				f_sendAndLogApdu(
                             m_apciSendFirstInvalidAid, {m_aduRequestProvideUserDetails(v_userParameterRequests)}
							);
 				               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = originatorRejected (7)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, ApduReasonCode_originatorRejected_}};
				var NAckParams v_nAckParams2 :={{1, ApduReasonCode_originatorRejected_},{2,ApduReasonCode_originatorRejected_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_Base_BI_02

			testcase TP_TSP_Base_BI_03() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_Base_BI_03: Verify that the TSP correctly responds to invalid or unknown informationSenderID in APCI field received inside an APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
				
				// Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
				// containing informationSenderID â‰  value declared in the PIXIT
				// Retrieve and alter informationSenderID value
				var Provider apduWrongSender := INFORMATION_SENDER_ID_FOR_TESTER;
				apduWrongSender.providerIdentifier := apduWrongSender.providerIdentifier + 1;
				template (value) ApciFields m_apciSendFirstInvalidAid modifies m_apciSendFirst:= {informationSenderID := apduWrongSender};
				// Then send it together with the request ADU
  				f_sendAndLogApdu(
                             m_apciSendFirstInvalidAid, {m_aduRequestProvideUserDetails(v_userParameterRequests)}
							);
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = originatorRejected (7)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, ApduReasonCode_originatorRejected_}}
				var NAckParams v_nAckParams2 :={{1, ApduReasonCode_originatorRejected_},{2, ApduReasonCode_originatorRejected_}}
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_Base_BI_03
			
			testcase TP_TSP_Base_BI_04() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_Base_BI_04: Verify that the TSP correctly responds to an informationRecipientID in APCI field which does not address the TSP itself 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
				
				// Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
				// containing informationrecipientID  â‰  value declared in the PIXIT
				// Retrieve and alter informationrecipientID value
				var Provider apduWrongRecipient := INFORMATION_SENDER_ID_FOR_IUT;
				apduWrongRecipient.providerIdentifier := apduWrongRecipient.providerIdentifier + 1;
				template (value) ApciFields m_apciSendFirstInvalidAid modifies m_apciSendFirst:= {informationrecipientID := apduWrongRecipient};
				// Then send it together with the request ADU
  				f_sendAndLogApdu(
                             m_apciSendFirstInvalidAid, {m_aduRequestProvideUserDetails(v_userParameterRequests)}
							);
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = recipientUnknown (8)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, ApduReasonCode_recipientUnknown_}};
				var NAckParams v_nAckParams2 :={{1, ApduReasonCode_recipientUnknown_},{2, ApduReasonCode_recipientUnknown_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_Base_BI_04

			testcase TP_TSP_Base_BI_05() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_Base_BI_05: Verify that the TSP correctly responds to invalid apduIdentifier in APCI field received inside an APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                

				// First, get the apdu to be sent in a variable to avoid apduIdentifier to be re-generated, then send the Apdu
				var InfoExchange apduToBeSent := m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests)}
					);
                
				// send RequestADU
				f_sendAndLogApdu(apduToBeSent);
                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						// Step3: Send DefaultAck with correct identifier
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					}
				} // End of alt statement
				
				// Step 1: Send exactly the same APDU sent previously, including the same apduIdentifier
				
				f_sendAndLogApdu(apduToBeSent);			

               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, ApduReasonCode_apduNotOK_}};
				var NAckParams v_nAckParams2 :={{1, ApduReasonCode_apduNotOK_},{2, ApduReasonCode_apduNotOK_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 												
			}	//End of 	TP_TSP_Base_BI_05

			testcase TP_TSP_Base_BI_06() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_Base_BI_06: Verify that the TSP correctly responds to an APDU which contains the nextAPDUId field  inside the APCI field 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
				
				// Step 1: Send Initiating APDU containing a valid RequestADU with APCI parameter field containing nextApduId
				template (value) ApciFields m_apciSendFirstInvalidAid modifies m_apciSendFirst:= {nextApduId := 1};
				// Then send it together with the request ADU
  				f_sendAndLogApdu(
                             m_apciSendFirstInvalidAid, {m_aduRequestProvideUserDetails(v_userParameterRequests)}
							);
               
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, ApduReasonCode_apduNotOK_}};
				var NAckParams v_nAckParams2 :={{1, ApduReasonCode_apduNotOK_},{2, ApduReasonCode_apduNotOK_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_Base_BI_06
			
			testcase TP_TSP_Base_BI_07() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_Base_BI_07: Verify that the TSP correctly responds to an APDU which contains the inResponseToApduId inside the APCI field but the received APDU is not in response to a previous APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
				
				// Step 1: Send Initiating APDU containing a valid RequestADU with APCI parameter field containing inResponseToApduId
				template (value) ApciFields m_apciSendFirstInvalidAid modifies m_apciSendFirst:= {inResponseToApduId := 1};
				// Then send it together with the request ADU
  				f_sendAndLogApdu(
                             m_apciSendFirstInvalidAid, {m_aduRequestProvideUserDetails(v_userParameterRequests)}
							);
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = sequenceError (4) or apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, ApduReasonCode_sequenceError_}};
				var NAckParams v_nAckParams2 :={{1, ApduReasonCode_sequenceError_},{2, ApduReasonCode_sequenceError_}};
				var NAckParams v_nAckParams3 :={{0, ApduReasonCode_apduNotOK_}};
				var NAckParams v_nAckParams4 :={{1, ApduReasonCode_apduNotOK_},{2, ApduReasonCode_apduNotOK_}};
				

				// Either apduNotOk or sequenceError error codes may be sent by the IUT
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
						
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams3)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams4)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);					
					}
				} // End of Alt statement 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_Base_BI_07				

			testcase TP_TSP_Base_BI_08() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_Base_BI_08: Verify that the TSP correctly responds to an APDU which contains an invalid inResponseToApduId value inside  the APCI field 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// PT140 TODO: Note that the following code is identical to the one in TSP_TRUSTOBJECTS_BV_01
				// TODO PT140 TrustObject ADU templates to be defined
				var boolean isCertificateOrPublicKey:=false;
				var boolean isDsrcKeyRef := false;
				var boolean isMacMasterKey := false;
				var boolean isDsrcMasterKey := false;
				// Send the IUT a  trigger to send one initial APDU with requestedADUType=trustObjectRequestADU and complete its transaction
				f_sendAndLogTrigger(TRUSTOBJECTS_TR_1);				
				//  Wait for request for TrustObjectAdu
				// PT140 TODO: Seems that alt inside a loop is not allowed. Repeat statement used instead
				alt {
					[] mtcPort.receive(m_apduTrustObject) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();	
						//send Ack whichever object received
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived)); 							
						//Read the trustObjectPurpose received and add to set 				
						if ((match(v_apduReceived, m_apduTrustObjectCertificateObject)) or 
						    (match(v_apduReceived, m_apduTrustObjectPublicKeyObject))) {
							isCertificateOrPublicKey:=true;
						    }
						if (match(v_apduReceived, m_apduTrustObjectGenericTONotCrl)) {
							setverdict(fail);
							stop;
						};
						if (match(v_apduReceived ,m_apduTrustObjectDsrcKeyRef)){ 
							isDsrcKeyRef:=true;
						}
						if (match(v_apduReceived ,m_apduTrustObjectMacMasterKey)) {
							isMacMasterKey:=true;
						}
						if (match(v_apduReceived ,m_apduTrustObjectDsrcMasterKey)) {
							isDsrcMasterKey:=true;
						}
					}										
				} // End of alt statement
				// Only allowed combinations according to profile
				if (not (
					(ICS_A2_1_isDsrc and isCertificateOrPublicKey and isDsrcKeyRef and isMacMasterKey and isDsrcMasterKey) or			 				
					(ICS_A2_2_isGnss and isCertificateOrPublicKey and isDsrcKeyRef)
				)) {
					setverdict(fail);  
					stop;
				};			 				

				// TODO PT140: Templates to be defined
				// Step 1: Send Initiating APDU containing a valid TrustObjectADU with inResponseToApduId not equal to the value of the previously sent APDU
				
				// Answer with the requested Trust Object, altering the inResponseToApduId field to a zero value											
						if (match(v_apduReceived ,m_apduTrustObjectDsrcKeyRef)) 
							{
								template (value) ApciFields m_apciSendInvalidInResponseToAid modifies mw_apduTrustObjectDsrcKeyRef:= {infoExchangeContent.apci.inResponseToApduId.apduIdentifier := 0};							  
								f_sendAndLogApdu(m_apciSendInvalidInResponseToAid);			  
							}; 							
						if (match(v_apduReceived ,m_apduTrustObjectDsrcKeyRef)) 
							{
								template (value) ApciFields m_apciSendInvalidInResponseToAid modifies m_apduTrustObjectMacMasterKey:= {infoExchangeContent.apci.inResponseToApduId.apduIdentifier := 0};							  
								f_sendAndLogApdu(m_apciSendInvalidInResponseToAid);			  
							}; 							
						if (match(v_apduReceived ,m_apduTrustObjectDsrcKeyRef)) 
							{
								template (value) ApciFields m_apciSendInvalidInResponseToAid modifies m_apduTrustObjectDsrcMasterKey:= {infoExchangeContent.apci.inResponseToApduId.apduIdentifier := 0};							  
								f_sendAndLogApdu(m_apciSendInvalidInResponseToAid);			  
							}; 							
               //Set timer
				t_step.start(TRUSTOBJECT_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = sequenceError (4) or apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, ApduReasonCode_sequenceError_}};
				var NAckParams v_nAckParams2 :={{1, ApduReasonCode_sequenceError_},{2, ApduReasonCode_sequenceError_}};
				var NAckParams v_nAckParams3 :={{0, ApduReasonCode_apduNotOK_}};
				var NAckParams v_nAckParams4 :={{1, ApduReasonCode_apduNotOK_},{2, ApduReasonCode_apduNotOK_}};
								
				// Either apduNotOk or sequenceError error codes may be sent by the IUT
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TIME2_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TIME2_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
						
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams3)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TIME2_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams4)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TIME2_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);					
					}
				} // End of Alt statement 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_Base_BI_08
			
			testcase TP_TSP_Base_BI_09() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_Base_BI_09: Verify that the TSP correctly responds to an invalid apduDate inside the APCI field of a received APDU
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
				
				// Step 1: Send an Initiating_Apdu containing APCI parameter field with apduDate = invalid
				// and valid RequestADU with requestedADUType=provideUserDetailsADU

				template (value) ApciFields m_apciSendFirstInvalidAid modifies m_apciSendFirst:= {apduDate := 0};
				// Then send it together with the request ADU
  				f_sendAndLogApdu(
                             m_apciSendFirstInvalidAid, {m_aduRequestProvideUserDetails(v_userParameterRequests)}
							);
               
 
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{1, ApduReasonCode_apduNotOK_},{2, ApduReasonCode_apduNotOK_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 												
			}	//End of 	TP_TSP_Base_BI_09

			testcase TP_TSP_Base_BI_10() runs on MainTestComponent system TestAdapter {
             /**
              * @desc    TP_TSP_Base_BI_10: Verify that the TSP correctly responds to an APDU bearing an incorrect infoExchangeAuthenticator 
              * @remark  [16986:2016], Clause 6.2.2 and 6.3.2 and Table A.1/2 
              */
               
               // Initialisation
                              
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS and ICS_A3_3_useAuthenticator;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
				
				// Step 1: Send an Initiating_Apdu containing invalid authenticator
				// and valid RequestADU with requestedADUType=provideUserDetailsADU
				var InfoExchange apduToBeSent := m_aduRequestProvideUserDetails(v_userParameterRequest);
				// TODO PT140: UPDATE the corrupted autentuicator. you cannot add a number to a data structure
				var ApduAuthenticator corruptedAuthenticator:= fx_computeAuthenticator(apduToBeSent);
				var octetstring newAuthenticator := corruptedAuthenticator.authenticatorEfc.tbsAuthenticatorEfc.apduContentDigest.hashedMessageContent;
				newAuthenticator := int2oct(oct2int(newAuthenticator) + 1, len(newAuthenticator));
				corruptedAuthenticator.authenticatorEfc.tbsAuthenticatorEfc.apduContentDigest.hashedMessageContent := newAuthenticator;
				var Infoexchange apduToBeSent := m_apduNoSec({
				  	m_aduRequestProvideUserDetails(v_userParameterRequests), 				  
					infoExchangeAuthenticator := corruptedAuthenticator});
				// Then send it together with the request ADU
  				f_sendAndLogApdu(apduToBeSent);
                        
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, ApduReasonCode_apduNotOK_}};
				var NAckParams v_nAckParams2 :={{1, ApduReasonCode_apduNotOK_},{2, ApduReasonCode_apduNotOK_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();    
             } // TP_TSP_Base_BI_10					
        } // End of group Invalid_Behaviour
        
    } // End of group Base
    
	group USERDETAILS {
		group Valid_Behaviour {
			testcase TP_TSP_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
            	 	          
				/**
				 * @desc    TP_TSP_USERDETAILS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserDetailsADUs 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Prepare a list of parameters to be requested
				
				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();
                
				// Step1: send RequestADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests)}
					)
				);
                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						// TODO PT140: Check the ADU record and find the one we are expecting. Either function or template
 
						//Set verdict
						setverdict(pass);
 					    			                              
						// Step3: Send DefaultAck with correct identifier and set verdict
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TSP_USERDETAILS_BV_01
            
			testcase TP_TSP_USERDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_USERDETAILS_BV_02: TP_TSP_USERDETAILS_BV_02: Verify that the TSP correctly receives a RequestADU of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of data privacy issues  
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequests v_userParameterRequests := PRIVACYBOUND_LIST_OF_PARAMETERS;   
				// Check if there are parameters that are privacy bound
				// If not, exit test
				if (sizeof (v_userParameterRequests) == 0) {
					setverdict(inconclusive);
					f_addLogEntry("Privacy bound parameters missing. Test cannot be executed");
					stop;
					};
                
				// Step1: send RequestADU
				// f_SendAPDU does all necessary filling of fields (if not already done in the template), sends the APDU, logs it together with time
				
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(
					m_apduNoSecInit(v_apduRespondedTo)
				);   	  
                                
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU or the timeout expires
				// timeout expiration is handled in the altstep branch
				// The received Provide Use Details ADU shall have status flag = 2, and an empty list of user details

				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails(v_apduRespondedTo)) -> value v_apduReceived{

						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;
						                        
						//Set verdict
						setverdict(pass);
						if (sizeof(v_apduReceived.adus.provideUserDetailsADUs) > 1) {
						  setverdict (fail);
						  stop;
						}
						if (not match(
							v_apduReceived.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU : modifies mw_aduProvideUserDetails := {
								statusFlag:=2,
								listOfUserParameters := omit
								}
							)) {
							setverdict(fail);
							stop;
							}	
						// Step3: Send DefaultAck with correct identifier
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TSP_USERDETAILS_BV_02
		} // End of group Valid_Behaviour
        
		group Invalid_Behaviour {
		  testcase TP_TSP_USERDETAILS_BI_01() runs on MainTestComponent system TestAdapter {
             
			  /**
			  * @desc    TP_TSP_USERDETAILS_BI_01: Verify that the TSP correctly responds to an incorrect RequestADU of type userDetailsRequest 
			  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
			  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
             
				// Step 1: Send two incorrect ADUs with 2 incorrect ADUs
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(v_apduRespondedTo);                               

				// Step 2: wait for a Semantic Error code Nack 

				t_step.start(USERDETAILS_TIME1_MAX_TSP);

				// Either we receive an APDU containing Nack with semantic error as error code or the timeout expires
				// timeout expiration handling is in the altstep branch				

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();  

			 } // End of testcase TP_TSP_USERDETAILS_BI_01
            
			testcase TP_TSP_USERDETAILS_BI_02() runs on MainTestComponent system TestAdapter {
            
			  /**
			  * @desc    TP_TSP_USERDETAILS_BI_02: Verify that the TSP correctly handles a RequestADUs of type userDetailsRequest with 
			  * listOfUsersParametersRequested containing non-supported user details
			  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
			  */          
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
             

				// Front End shall initially receive a Request named as Transaction sequence #1
				// Find a parameter whose value  is not supported by the IUT
				// Prepare the list of requested parameters with one element which is unsupported

				var integer v_notSupportedUserDetailsParameter;
				for (
					v_notSupportedUserDetailsParameter := 0; 
					v_notSupportedUserDetailsParameter < sizeof(USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS); 
					v_notSupportedUserDetailsParameter := v_notSupportedUserDetailsParameter + 1
				) {
					if (
							match(v_notSupportedUserDetailsParameter, integer:complement(USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS))
					) {break;}
				}
				
				
				var InfoExchange v_apduNoSecInit := m_apduNoSecInit(
					{
						m_aduRequestProvideUserDetails({v_notSupportedUserDetailsParameter})
					}
				);
				f_sendAndLogApdu(v_apduNoSecInit);                              
                                
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU or the timeout expires
				// timeout expiration is handled in the altstep branch
				// The received Provide Use Details ADU shall have status flag = 1, and no  list of user details

				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails(v_apduRespondedTo)) -> value v_apduReceived{

						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;
						
                        
						//Set verdict
						setverdict(pass);
						if (sizeof(v_apduReceived.adus.provideUserDetailsADUs) > 1 )
						  {
							setverdict (fail);
							stop;
						  }
						if (not match(
							v_apduReceived.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU: modifies mw_aduProvideUserDetails := {
								statusFlag:=1, //PT140 TODO add userParameterStatus = 1 
								listOfUserParameters := omit
							}
						)) 
						{
						  setverdict(fail);
						  stop;
						  }
							
						// Step3: Send DefaultAck with correct identifier
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
						}
					} // End of alt statement
                
				f_closeDownMtc();  
                			
				} // End of testcase TP_TSP_USERDETAILS_BI_02 

            testcase TP_TSP_USERDETAILS_BI_03() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_03: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of missing agreement
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */       

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequests v_userParameterRequests := USERDETAILS_NOT_AGREED_LIST;   
				// Check if there are parameters that are privacy bound
				// If not, exit test
				if (sizeof (v_userParameterRequests) == 0) {
					setverdict(inconclusive);
					f_addLogEntry("Not agreed parameters missing. Test cannot be executed");
					stop;
					};
                
				// Step1: send RequestADU
				// f_SendAPDU does all necessary filling of fields (if not already done in the template), sends the APDU, logs it together with time
				
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(
					m_apduNoSecInit(v_apduRespondedTo)
				);   	  
                                		
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);

               // Step #2: Wait for empty User Details
				// Either we receive an APDU containing empty User Details or the timeout expires
				// timeout expiration handling is in the altstep branch	
                alt {
					[] mtcPort.receive(mw_apduProvideUserDetails(v_apduRespondedTo)) -> value v_apduReceived{

						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;
						                        
						//Set verdict
						setverdict(pass);
						if (sizeof(v_apduReceived.adus.provideUserDetailsADUs) > 1) {
						  setverdict (fail);
						  stop;
						}
						if (not match(
							v_apduReceived.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU: modifies mw_aduProvideUserDetails := {
								userId := omit,
								statusFlag:=2,
								listOfUserParameters.useParameterStatus := 3,
								listOfUserParameters := omit
							}
						)) {
						  setverdict(fail);
						  stop;
						}
                    }
                } // End of alt statement

				f_closeDownMtc();  
 
            } // End of TP_TSP_USERDETAILS_BI_03
            
            testcase TP_TSP_USERDETAILS_BI_04() runs on MainTestComponent system TestAdapter {

             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_04: Verify that a TSP responds correctly to a RequestADU sent earlier than allowed 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequest v_userParameterRequests := f_userDetailsParameters();                
                
				// Step1: send RequestADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests)}
					)
				);
       			// Send again immediately same ADU with different  valid user
				var InfoExchange v_apduToSend := m_apduNoSecInit(
					{modifies m_aduProvideUserDetails:= {
					  	userId:= EMPTYLIST_USER_ID
					  	}
					});
				f_sendAndLogApdu(v_apduToSend);

                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduToSend)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
                } // End of alt statement
				f_closeDownMtc();  			
                
        	} // End of TP_TSP_USERDETAILS_BI_04

        } // End of group Invalid_Behaviour
 
    } // End of group USERDETAILS

    group LISTOFUSERS {
         group Valid_Behaviour {

             testcase TP_TSP_LISTOFUSERS_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserIdListADUs with available user Id data 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestListOfUsers});
				f_sendAndLogApdu(v_apduRespondedTo);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for UserList ADU
				// Either we receive an APDU containing  User List ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch

                 alt {
                      [] mtcPort.receive(mw_apduListOfUsers(v_apduRespondedTo)) -> value v_apduReceived {
                      		
						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;

						//Set verdict
						setverdict(pass);
 						
 						//	Check whether the list of users contains elements
 						// If not, set verdict fail
 						                              
                        if (lengthof(v_apduReceived.adus.provideUserIdListADUs.userIdList) == 0) {
                          f_addLogEntry("Empty user list received");
                          setverdict(fail);
                          stop;
                        };
                        
                        if (not (v_apduReceived.adus.provideUserIdListADUs.userId == EXISTING_USER_ID)) {
                          f_addLogEntry("Wrong User ID received");
                          setverdict(fail);
                          stop;
                        };
                        
                        // Step #3: Send DefaultACK with correct identifier
                        
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
                      }
                    } // End of alt statement
				
				f_closeDownMtc();  

             } // End of TP_TSP_LISTOFUSERS_BV_01           

             testcase TP_TSP_LISTOFUSERS_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BV_02: Verify that the TSP correctly receives an APDU containing valid RequestADUs to user Id data not available and provides valid ProvideUserIdListADUs 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= EMPTYLIST_USER_ID
						}
					});
				f_sendAndLogApdu(v_apduRespondedTo);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for UserList ADU
				// Either we receive an APDU containing  User List ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch

                 alt {
                      [] mtcPort.receive(mw_apduListOfUsers(v_apduRespondedTo)) -> value v_apduReceived {
                      		
						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;

						//Set verdict
						setverdict(pass);
 						
 						//	Check whether the list of users contains elements
 						// If yes, set verdict fail
 						                              
                        if (lengthof(v_apduReceived.adus.provideUserIdListADUs.userIdList) > 0) {
                          f_addLogEntry("Not empty user list received");
                          setverdict(fail);
                          stop;
                        };
                        if (not(v_apduReceived.adus.provideUserIdListADUs.userId == EMPTYLIST_USER_ID)) {
                          f_addLogEntry("Wrong User ID received");
                          setverdict(fail);
                          stop;
                        };
                        
                        // Step #3: Send DefaultACK with correct identifier
                        
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
                      }
                    } // End of alt statement
				
				f_closeDownMtc();  

             } // End of TP_TSP_LISTOFUSERS_BV_02  		
 		
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
			  testcase TP_TSP_LISTOFUSERS_BI_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_01: Verify that the TSP correctly receives an invalid requestADU with userIdRequestType â‰  0 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var integer wrongUserIdRequestType := float2int(rnd() * 254) + 1;
				// Save the apdu to be sent to check later in the received Nack
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestType := wrongUserIdRequestType
						}
					});
				f_sendAndLogApdu(v_apduRespondedTo);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();  			
			} // End of TP_TSP_LISTOFUSERS_BI_01
             
			  testcase TP_TSP_LISTOFUSERS_BI_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_02: Verify that the TSP correctly receives an invalid request ADU with no PAN, LicensePlateNumber, OBEID or ContractSerialNumber present in the userId field 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				// Save the apdu to be sent to check later in the received Nack
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId := {}
						}
					});
				f_sendAndLogApdu(v_apduRespondedTo);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();		
             } // End of TP_TSP_LISTOFUSERS_BI_02
             
			  testcase TP_TSP_LISTOFUSERS_BI_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_03: Verify that the TSP correctly receives an invalid request ADU with userIdRequestTime not present 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation

				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				// Save the apdu to be sent to check later in the received Nack			
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime := omit
						}
					});
				f_sendAndLogApdu(v_apduRespondedTo);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();				
			} // End of TP_TSP_LISTOFUSERS_BI_03
             
			  testcase TP_TSP_LISTOFUSERS_BI_04() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_04: Verify that the TSP correctly receives an invalid request ADU with invalid userIdRequestTime 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */

				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				// Save the apdu to be sent to check later in the received Nack					
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime := fx_getUtc() + 1000
						}
					});
				f_sendAndLogApdu(v_apduRespondedTo);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				}

				f_closeDownMtc();  			
 
             } // End of TP_TSP_LISTOFUSERS_BI_04
             
			  testcase TP_TSP_LISTOFUSERS_BI_05() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_05: Verify that a TSP responds correctly to a RequestADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestListOfUsers}
					)
				);

				// Send again immediately same ADU with different  valid user
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= EMPTYLIST_USER_ID
					  	}
					});
				f_sendAndLogApdu(v_apduRespondedTo);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				}

				f_closeDownMtc();  			

             } // End of TP_TSP_LISTOFUSERS_BI_05
                      
           } // End of group Invalid_Behaviour
        
    } // End of group LISTOFUSERS
    
    group EXCEPTIONLIST {
         group Valid_Behaviour {
           testcase TP_TSP_EXCEPTIONLIST_BV_01() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_EXCEPTIONLIST_BV_01: Verify that the TSP correctly performs an EXCEPTIONLIST transaction for blacklist and whitelist 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 AND Table A.7/3 
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Step 1a: Trigger IUT with EXCEPTIONLIST.TR_TSP_1 LIST_TYPE=BLACK
				f_sendAndLogTrigger(EXCEPTIONLIST_TR_TSP_1_A);
				//  Wait for EXCEPTIONLIST with LIST_TYPE=BLACK
				alt {
					[] mtcPort.receive(mw_apduExceptionListOneBlackList) -> value v_apduReceived {
						
						// Log what we received
						f_logApduReceivedAndTStep();					
               		
						// Send Ack within time constraints
						f_wait(EXCEPTIONLIST_TIME1_TC);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					}
				} // End of first alt statement
					
				// Step 1b: Trigger IUT with EXCEPTIONLIST.TR_TSP_1 LIST_TYPE=WHITE within time constraints
				f_sendAndLogTrigger(EXCEPTIONLIST_TR_TSP_1_B);
				//  Wait for EXCEPTIONLIST with LIST_TYPE=WHITE
				alt {
					[] mtcPort.receive(mw_apduExceptionListOneWhiteList) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
							
						// Send Ack within time constraints
						f_wait(EXCEPTIONLIST_TIME1_TC);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
							
						// Set test success
						setverdict(pass);						
					}
 				} // End of second alt statement
				f_closeDownMtc();   						           
           } // End of TP_TSP_EXCEPTIONLIST_BV_01
           
           testcase TP_TSP_EXCEPTIONLIST_BV_02() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_EXCEPTIONLIST_BV_02: Verify that the TSP correctly performs an EXCEPTIONLIST transaction for discounted users 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 AND Table A.7/3 
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Step 1: Trigger IUT with EXCEPTIONLIST.TR_TSP_1 LIST_TYPE=DISCOUNT
				f_sendAndLogTrigger(EXCEPTIONLIST_TR_TSP_1_C);
				//  Wait for EXCEPTIONLIST with LIST_TYPE=DISCOUNT
				alt {
					[] mtcPort.receive(mw_apduExceptionList modifies mw_aduExceptionList := {exceptionListType := ExceptionListType_discountList_}) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               			if (not ispresent(v_apduReceived.adus.ExceptionListADU.exceptionListEntries.ExceptionListEntry.vatId)) {
               				// Send NAck within time constraints
							var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
							f_wait(EXCEPTIONLIST_TIME1_TC);
							f_sendAndLogApdu(m_apduNAck(v_apduReceived, v_nAckParams1));   
               				setverdict(fail);             				
               				}
               			else {
							// Send Ack within time constraints
							f_wait(EXCEPTIONLIST_TIME1_TC);
							f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived)); 			
							// Set test success
							setverdict(pass);
               				};
					} // End of alt statement
				
				f_closeDownMtc(); 
				              
           } // End of TP_TSP_EXCEPTIONLIST_BV_02
 		
 		
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {	
           // No Invalid Behaviour Test Cases defined	
        } // End of group Invalid_Behaviour

    } // End of group EXCEPTIONLIST
    
    group TRUSTOBJECTS {
         group Valid_Behaviour {
           
         testcase TP_TSP_TRUSTOBJECTS_BV_01() runs on MainTestComponent system TestAdapter {
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BV_01: Verify that the TSP correctly provides a TrustObjectADU without TC request
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2
              * @remark  Same as  TP_TC_TRUSTOBJECTS_BV_01
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				var boolean isCertificateOrPublicKey:=false;
				var boolean isDsrcKeyRef := false;
				var boolean isMacMasterKey := false;
				var boolean isDsrcMasterKey := false;
				var integer ObjectsReceived := 0;
				// Step 1: Trigger IUT with TRUSTOBJECTS_TR_2
				f_sendAndLogTrigger(TRUSTOBJECTS_TR_2);
				//  Wait for TRUSTOBJECTS
				// We expect to receive as many TRUSTOBJECTS as the declared supported number
				// PT140 TODO: TrustObjects templates to be defined
				// PT140 Seems that alt inside a loop is not allowed. Use repeat statement instead
				alt {
					[] mtcPort.receive(m_apduTrustObject) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();	
						//send Ack whichever object received
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived)); 							
						//Read the trustObjectPurpose received and add to set 				
						if ((match(v_apduReceived, m_apduTrustObjectCertificateObject)) or 
						    (match(v_apduReceived, m_apduTrustObjectPublicKeyObject))) 
							isCertificateOrPublicKey:=true;
						if (match(v_apduReceived, m_apduTrustObjectGenericTONotCrl)) {
							setverdict(fail);
							stop;
						};
						if (match(v_apduReceived ,m_apduTrustObjectDsrcKeyRef)) 
							isDsrcKeyRef:=true;
						if (match(v_apduReceived ,m_apduTrustObjectMacMasterKey)) 
							isMacMasterKey:=true;
						if (match(v_apduReceived ,m_apduTrustObjectDsrcMasterKey)) 
							isDsrcMasterKey:=true;
						ObjectsReceived := ObjectsReceived + 1; // Count the number of trust objects received
						repeat;
						}										
					} // End of alt statement
				if (ICS_A2_1_isDsrc and isCertificateOrPublicKey and isDsrcKeyRef and isMacMasterKey and isDsrcMasterKey) setverdict(pass);			 				
				if (ICS_A2_2_isGnss and isCertificateOrPublicKey and isDsrcKeyRef) setverdict(pass);			 				
				if ObjectsReceived < NUMBER_OF_TRUSTOBJECT_TYPES_SUPPORTED setverdict(fail); // We must receive at least as many Trust Objects as supported
				f_closeDownMtc();              
           } // End of TP_TSP_TRUSTOBJECTS_BV_01

           testcase TP_TSP_TRUSTOBJECTS_BV_02() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BV_02: Verify that the TSP correctly responds to a TrustObjectADU received from a TC without having issued a request 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              * @remark  Same as TP_TC_TRUSTOBJECTS_BV_02
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
                 // Step 1: Send one valid APDU containing one valid TrustObjectADU
                 // PT140 TODO : mw_aduTrustObjects template to be defined 
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(mw_aduTrustObjects);                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within TRUSTOBJECTS.TIME2
				// Set timer
                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                  
             
           } // End of TP_TSP_TRUSTOBJECTS_BV_02

           testcase TP_TSP_TRUSTOBJECTS_BV_03() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BV_03: Verify that the TSP correctly provides a TrustObjectADU following a TC request 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              * @remark  Same as TP_TC_TRUSTOBJECTS_BV_03
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// PT140 TODO: m_aduRequestTrustObjects template to be defined
				// Loop in all available types of trustobject supported by the IUT as specified by the length of SENT_TRUST_OBJECTS_SUPPORTED Pixit record
				var integer v_trustObjectsToBeSent := sizeof(RECEIVED_TRUST_OBJECTS_SUPPORTED);
				for (var integer v_trustObjectsReceived :=1; v_trustObjectsReceived<v_trustObjectsToBeSent;v_trustObjectsReceived:=v_trustObjectsReceived+1)
					{
						// Prepare a request of a Trust Object by taking allowed type and purpose from the RECEIVED_TRUST_OBJECTS_SUPPORTED Pixit value
						var InfoExchange v_apduRequestForTrustObject := m_apduNoSecInit( modifies m_aduRequestTrustObjects:={
						  	trustObjectRequest.requestedTrustObject.trustObjectSpec.typeOfTrustObject := SENT_TRUST_OBJECTS_SUPPORTED[v_trustObjectsReceived].trustObjectType,
						  	trustObjectRequest.requestedTrustObject.trustObjectSpec.purposeOfTrustObject := SENT_TRUST_OBJECTS_SUPPORTED[v_trustObjectsReceived].trustObjectPurpose	
							}
						);
						f_sendAndLogApdu(v_apduRequestForTrustObject);

						// Set timer
                		 t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TSP);
						// Step #2: Wait for TrustObjects ADU
						// Either we receive an APDU containing  TrustObject or the timeout expires
						// timeout expiration is handled in the altstep branch
						// PT140 TODO: m_apduTrustObjects to be defined
                 		alt {
                      		[] mtcPort.receive(m_apduTrustObjects(v_apduRespondedTo)) -> value v_apduReceived {
								// Log what we received 					
								f_logApduReceivedAndTStep();
								// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
								f_checkMinimumTime(t_step, TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); // 
								// Trust Object ADU correctly arrived. Stop timer
								t_step.stop;
                        		// Step #3: Send DefaultACK with correct identifier
								f_wait(TRUSTOBJECTS_TYPE1_TIME2_MIN_TSP);
								f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
                      			}
                    		} // End of alt statement
						}; // end of for statement
				//Set verdict
				setverdict(pass);
				f_closeDownMtc(); 
				 
           } // End of TP_TSP_TRUSTOBJECTS_BV_03

           testcase TP_TSP_TRUSTOBJECTS_BV_04() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BV_04: Verify that the TSP correctly requests and responds to a TrustObjectADU
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              * @remark  Same as TP_TC_TRUSTOBJECTS_BV_04
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Step 1: Trigger IUT with TRUSTOBJECTS_TR_1
				f_sendAndLogTrigger(TRUSTOBJECTS_TR_1);
				//  Wait for request for TRUSTOBJECTS
				// PT140 TODO: m_aduRequestTrustObjects template to be defined
				// PT140 TODO: loop in all available types of trustobject requested supported by the IUT by repeating receive
				// Set timer
				var integer v_expectedTrustObjectRequests := sizeof(SENT_TRUST_OBJECTS_SUPPORTED);
				var integer v_receivedTrustObjects := 0;
                t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_aduRequestTrustObjects) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						v_receivedTrustObjects := v_receivedTrustObjects + 1;
                		// Step 1: Send one valid APDU containing one valid TrustObjectADU
                		// PT140 TODO : m_aduTrustObjects template to be defined
						// PT140 TODO: Analysis of what requested and what to be sent missing
						var integer v_requestedTrustObjectType := v_apduReceived.Adus.requestAdus.trustObjectRequest.trustObjectSpec.typeOfTrustObject;
						var record v_requestedTrustObjectPurpose := v_apduReceived.Adus.requestAdus.trustObjectRequest.trustObjectSpec.purposesOfTrustObject;
						template (value) ApciFields m_apciSendFirstInvalidAid modifies m_apciSendFirst:= {aidIdentifier:=0};
						if (v_requestedTrustObjectType == certificate){
							var InfoExchange v_apduRespondedTo := m_apduNoSecInit(modifies m_aduTrustObjects{
						  		trustObjectID := float2int(rnd());
						  		purposesOfTrustObject := v_requestedTrustObjectPurpose;
						  		startValidity := now;
						  		endValidity := omit;
						  		trustObjectStatus := valid;
								trustObject := TESTER_CERTIFICATE_OBJECT
								});                 												
							};
						if (v_requestedTrustObjectType == publicKey){
							var InfoExchange v_apduRespondedTo := m_apduNoSecInit(modifies m_aduTrustObjects{
						  		trustObjectID := float2int(rnd());
						  		purposesOfTrustObject := v_requestedTrustObjectPurpose;
						  		startValidity := now;
						  		endValidity := omit;
						  		trustObjectStatus := valid;
								trustObject := TESTER_PUBLICKEY_OBJECT
								});                 												
							};

						if (v_requestedTrustObjectType == symmetricKey){
							var InfoExchange v_apduRespondedTo := m_apduNoSecInit(modifies m_aduTrustObjects{
						  		trustObjectID := float2int(rnd());
						  		purposesOfTrustObject := v_requestedTrustObjectPurpose;
						  		startValidity := now;
						  		endValidity := omit;
						  		trustObjectStatus := valid;
								trustObject := TESTER_DSRCKEY_OBJECT
								});                 												
							};
						
						f_sendAndLogApdu(v_apduRespondedTo);                 
                
                		// Step 2: Wait for positive Ack within TRUSTOBJECTS.TIME2
						// Set timer
                 		t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                 
						alt {
							[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
								// Log what we received
								f_logApduReceivedAndTStep();
								t_step.stop;
								}
							} // End of second alt 
						}
					if (v_receivedTrustObjects == v_expectedTrustObjectRequests) {
						setverdict(pass);
						break;  
						};
                	t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TSP);  // Restart timer               
					repeat;	
					} // End of first alt 					
				f_closeDownMtc();                  


           } // End of TP_TSP_TRUSTOBJECTS_BV_04
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_TRUSTOBJECTS_BI_01() runs onMainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_01: Verify that the TSP correctly responds to a TrustObjectADU received without having issued a request and containing incorrect ADU parameters
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              * @remark  Same as TP_TC_TRUSTOBJECTS_BI_01
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// PT140 TODO: mw_aduTrustObject template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduTrustObject:= {TrustObjectStatus := 5} // Value 5 not supported
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
				// Set timer
                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                		
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);						
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                   
             
           } // End of TP_TSP_TRUSTOBJECTS_BI_01

           testcase TP_TSP_TRUSTOBJECTS_BI_02() runs onMainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_02: Verify that the TSP correctly responds to more than one correct Trust Object ADUs in the same APDU without having issued a request
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              * @remark  Same as TP_TC_TRUSTOBJECTS_BI_02
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// PT140 TODO: mw_aduTrustObject template to be defined
				// Set two different TrustObject adus by varying the type of trust object 
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduTrustObject:= {typeOfTrustObject := TrustObjectTypes_symmetricKey_} },
					{modifies mw_aduTrustObject:= {typeOfTrustObject := TrustObjectTypes_encryptedSymmetricKey_} }
					);                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
				// Set timer
                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                		
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;						
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                   
                          
           } // End of TP_TSP_TRUSTOBJECTS_BI_02

           testcase TP_TSP_TRUSTOBJECTS_BI_03() runs onMainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_03: Verify that the TSP correctly responds to a not supported Trust Object
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              * @remark  Same as TP_TC_TRUSTOBJECTS_BI_03
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Find a couple of TrustObjectType, TrustobjectPurpose not supported by the IUT
				var integer NotSupportedTypeOrPurpose[2];
				for (var integer v_types :=0; v_types < 8 ;v_types:=v_types+1) // Loop within types
					{
						for (var integer v_purposes :=0; v_purposes < 17; v_purposes:=v_purposes+1) // Loop within purposes
							{
							  NotSupportedTypeOrPurpose := {v_types,v_purposes}; // Set value of not supported parameters combination
							  // Check if this combination is supported						  
							  for (var integer v_cntl=0; v_cntl<sizeof(RECEIVED_TRUST_OBJECTS_SUPPORTED) ) {
							    if RECEIVED_TRUST_OBJECTS_SUPPORTED[v_cntl] == {v_types,v_purposes} {
							    	NotSupportedTypeOrPurpose := {100,100};	  // If supported, invalidate the value of not supported parameters combination
							    };							  
							  	continue; // Continue for all supported couples
							  	}
							  	If NotSupportedTypeOrPurpose != {100,100} {
							  		break;  // Found one invalid combination to be used in the test
							  	};
								continue; // Loop within Trust Object purposes
							}
					If NotSupportedTypeOrPurpose != {100,100} {
							break;  // Found one invalid combination to be used in the test
							};					
					continue;	// Loop within Trust Object types		
					};
				// Decide if test to be run (invalid couple of purpose and type found)
				If NotSupportedTypeOrPurpose == {100,100} {
				  setverdict(inconclusive);
				  stop;
				  }
				// Send a Trust Object with Type and Purpose as found
				// PT140 TODO: mw_aduTrustObject template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduTrustObject:= {typeOfTrustObject := NotSupportedTypeOrPurpose[1], purposesOfTrustObject := NotSupportedTypeOrPurpose[1]}			  
					}
					);                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
				// Set timer
                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                		
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;						
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                   
                          
           } // End of TP_TSP_TRUSTOBJECTS_BI_03

           testcase TP_TSP_TRUSTOBJECTS_BI_04() runs onMainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_04: Verify that the TSP correctly responds to a RequestADU sent earlier than allowed
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              * @remark  Same as TP_TC_TRUSTOBJECTS_BI_04
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// PT140 TODO: m_aduRequestTrustObject template to be defined
				// Step1: send RequestADU by specifying the type of trustobject
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{modifies m_aduRequestTrustObject:= {
					  	requestedTrustObject.trustObjectSpec.typeOfTrustObject := TrustObjectTypes_encryptedSymmetricKey_
					  	}
					}
					)
				);
       			// Send again immediately same ADU with different  valid type of trust object
				var InfoExchange v_apduToSend := m_apduNoSecInit(
					{modifies m_aduRequestTrustObject:= {
					  	requestedTrustObject.trustObjectSpec.typeOfTrustObject := TrustObjectTypes_symmetricKey_
					  	}
					});
				f_sendAndLogApdu(v_apduToSend);

                               
				//Set timer
				t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TSP);
                
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;						
						setverdict(pass);
					}
				} 
				f_closeDownMtc();            
           } // End of TP_TSP_TRUSTOBJECTS_BI_04

           testcase TP_TSP_TRUSTOBJECTS_BI_05() runs onMainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_05: Verify that the TSP correctly responds to a TrustObjectADU sent earlier than allowed
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              * @remark  Same as TP_TC_TRUSTOBJECTS_BI_05
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// PT140 TODO: mw_aduTrustObject template to be defined
				// Step1: send RequestADU by specifying the type of trustobject
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{modifies mw_aduTrustObject:= {typeOfTrustObject := TrustObjectTypes_symmetricKey_} }
					)
				);
       			// Send again immediately same ADU with different  valid type of trust object
				var InfoExchange v_apduToSend := m_apduNoSecInit(
					{modifies mw_aduTrustObject:= {typeOfTrustObject := TrustObjectTypes_encryptedSymmetricKey_} });
				f_sendAndLogApdu(v_apduToSend);
                              
				//Set timer
				t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);
                
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;						
						setverdict(pass);
					}
				} 
				f_closeDownMtc();              
           } // End of TP_TSP_TRUSTOBJECTS_BI_05
           		
        } // End of group Invalid_Behaviour

    } // End of group TRUSTOBJECTS
    
    group PAYMENTCLAIM {
         group Valid_Behaviour {
            testcase TP_TSP_PaymentClaim_BV_01() runs on MainTestComponent system TestAdapter {
                   /**    
				  * @desc	TP_TSP_PAYMENTCLAIM_BV_01: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when using the actionCode=send 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5 
                  */
 				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
                // PT 140: TODO Probably there is no need to have an initial PAYMENTCLAIM for this test case as stated in the TSS&TP
                // Step 1: First interaction
                	// Send one preset Billing Details
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, paymentFeeAmount := 45, actionCode := Send
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 					
                	// Send PAYMENTCLAIM with ActionCode=SEND and setting:
                		// UserId within declared valid values
                		// valid values of TypeOfFee
                		// paymentReference valid and not present
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 45,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				}
				
                // Step 1: Second interaction
                	// Note: no Billing Details sent to be referred by the following Payment Claim
                	// Send PAYMENTCLAIM with ActionCode=SEND and changing:
                		// UserId within declared valid values
                		// valid values of TypeOfFee
                		// paymentReference valid and not present
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	paymentClaimId := 2,
					  	startDateTime := now,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,					  	
					  	paymentClaimAmount := 33,
					  	typeOfFee := TypeOfFee_penalty_,
					  	paymentReference := "Lane jumping"
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						setverdict(pass);
					}
				} 
				 
				f_closeDownMtc();                              		
                
                } // End of TP_TSP_PAYMENTCLAIM_BV_01
                
            testcase TP_TSP_PaymentClaim_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BV_02: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when using the actionCode=revoke or adjust 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5 
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				                  
                // PT 140: TODO It is not possible to send two PAYMENTCLAM Adus in the same APDU as stated in the TSS&TP
                 // Send one preset Billing Details
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, paymentFeeAmount := 45, actionCode := ActionCode_send_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 					

                	// Send PAYMENTCLAIM with ActionCode=SEND
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 45,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				}

                // Step 1:
                	// Send PAYMENTCLAIM with ActionCode=ADJUST referring to the previoulsy sent PAYMENTCLAIM and changing the charged value

                	// Send PAYMENTCLAIM with ActionCode=SEND
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_adjust_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 44,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				}

                	// Send PAYMENTCLAIM with ActionCode=REVOKE referring to the previoulsy sent PAYMENTCLAIM
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_revoke_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 0,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						setverdict(pass);
					}
				}

				f_closeDownMtc();                              		
                     
                } // End of TP_TSP_PAYMENTCLAIM_BV_02
                


 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
            testcase TP_TSP_PaymentClaim_BI_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_01: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect paymentClaimId 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Send one preset Billing Details
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, paymentFeeAmount := 45, actionCode := ActionCode_send_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 					

                	// Send PAYMENTCLAIM with ActionCode=SEND
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 45,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				}

                // Step 1:
                	// Send PAYMENTCLAIM with ActionCode=REVOKE not referring to the previoulsy sent PAYMENTCLAIM
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 2,
					  	startDateTime := now,
					  	actionCode := ActionCode_revoke_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 0,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                		
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_paymentClaimIdRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_paymentClaimIdRejected_}};
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);						
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                   
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_01           		

            testcase TP_TSP_PaymentClaim_BI_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_02: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect paymentClaimStatus 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Send one preset Billing Details
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, paymentFeeAmount := 45, actionCode := ActionCode_send_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				}
                	// Send valid PAYMENTCLAIM with ActionCode=SEND and setting:
                		// UserId within declared valid values
                		// valid values of TypeOfFee
                		// paymentReference valid and not present
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	actionCode := ActionCode_send_,
					  	paymentClaimAmount := 45,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				}
					// Step 1: send invalid PAYMENTCLAIM				
				 					
                	// Send PAYMENTCLAIM with ActionCode=ADJUST, but with status = first version
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_adjust_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 45,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_paymentClaimStatusRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_paymentClaimStatusRejected_}};
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);		
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                 		          	      
                } // End of TP_TSP_PAYMENTCLAIM_BI_02           		

            testcase TP_TSP_PaymentClaim_BI_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_03: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect referenceDetailsList 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Send one preset Billing Details
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, paymentFeeAmount := 45, actionCode := ActionCode_send_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 					
                	// Send PAYMENTCLAIM with ActionCode=SEND and referring to a wrong reference details list
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 45,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {2}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				//Create parameters for the m_apduNAck: Note that the generic invalidADU reason code should be more precise (lack in the base standard)			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_}};
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);						
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                 		               
                } // End of TP_TSP_PAYMENTCLAIM_BI_03           		

            testcase TP_TSP_PaymentClaim_BI_04() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_04: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect actionCode 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Send one preset Billing Details
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, paymentFeeAmount := 45, actionCode := ActionCode_send_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 					
                // PT 140: TODO Probably there is no need to have an initial PAYMENTCLAIM for this test case as stated in the TSS&TP

                // Send PAYMENTCLAIM with ActionCode=SEND and with action code = credit (not allowed)
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_credit_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 45,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_paymentClaimStatusRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_paymentClaimStatusRejected_}};
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);						
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                 						                  
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_04   

            testcase TP_TSP_PaymentClaim_BI_05() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_05: Verify that the TSP correctly performs the PAYMENTCLAIM transaction when receiving a number of PaymenClaimADUs, each of them containing specific errors  
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Send two preset Billing Details
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo :=
					{m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, paymentFeeAmount := 400, actionCode := ActionCode_send_
					  	}
					}),
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 2, paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					})
            	};                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 					

                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the two performed BillingDetails transactions, and with endDateTime = Ã˜
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	endDateTime := 0,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 900,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1, 2}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimEndDateTimeRejected (804)

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_paymentClaimEndDateTimeRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_paymentClaimEndDateTimeRejected_}};
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;					
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				}

                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the two performed BillingDetails transactions, and containing userId unknown to the IUT
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := WRONG_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 900,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1, 2}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimUserIdRejected (805)

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_paymentClaimUserIdRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_paymentClaimUserIdRejected_}};
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;						
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
					}
				}
                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the two performed BillingDetails transactions, and containing paymentClaimAmount = 1000
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 1000,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1, 2}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimAmountRejected (806)

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_paymentClaimAmountRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_paymentClaimAmountRejected_}};
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;						
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
					}
				}

                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the two performed BillingDetails transactions, and containing paymentClaimStatus = 2
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := 2,
					  	paymentClaimAmount := 900,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1, 2}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimStatusRejected (807)

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_paymentClaimStatusRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_paymentClaimStatusRejected_}};
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;						
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
					}
				}

                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the two performed BillingDetails transactions, and containing typeOfFee omitted
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 900,
					  	typeOfFee := omit,
					  	referenceDetailsList := {1, 2}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimTypeOfFeeRejected	(808)

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_paymentClaimTypeOfFeeRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_paymentClaimTypeOfFeeRejected_}};
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);						
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
					}
				}											 
				f_closeDownMtc();				                 
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_05   

            testcase TP_TSP_PaymentClaim_BI_06() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_06: Verify that a TSP responds correctly to a PaymentClaimADU sent earlier than allowed  
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Send one preset Billing Details
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, paymentFeeAmount := 45, actionCode := ActionCode_send_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 					
				// Send one PAYMENTCLAIM related to the sent BILLINGDETAILS within allowed time constraints
                 // PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_send_,
					  	paymentClaimStatus := PaymentClaimStatus_firstVersion_,
					  	paymentClaimAmount := 45,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

                // Step 1:
                	// Send PAYMENTCLAIM with ActionCode=REVOKE before TIMEA_MIN
              		// Wait for negative Ack (if positive Ack or not received set test failure) 
              		// PT140 TODO : mw_aduPaymentClaim template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduPaymentClaim:= {
					  	userId := EXISTING_USER_ID,
					  	paymentClaimId := 1,
					  	startDateTime := now,
					  	actionCode := ActionCode_revoke_,
					  	paymentClaimStatus := PaymentClaimStatus_amendedVersion_,
					  	paymentClaimAmount := 0,
					  	typeOfFee := TypeOfFee_toll_,
					  	referenceDetailsList := {1}
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo); 
                		
              	// Wait for negative Ack  with NAck_requestSentTooOften code
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				
				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(PAYMENTCLAIM_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);						
					}
				} 
                
				f_closeDownMtc();  			
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_06  
        } // End of group Invalid_Behaviour

    } // End of group PAYMENTCLAIM
    
    group DSRC_CONTRACTISSUERLIST {
         group Valid_Behaviour {
           testcase TP_TSP_CONTRACTISSUERLIST_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_CONTRACTISSUERLIST_BV_01: Verify that the TSP correctly performs the DSRC.CONTRACTISSUERLIST transaction with three manufacturerIDs 
                  * @remark  [16986:2016], Clause 7.1 and Table A.1/2 AND Table A.2/1 AND Table A.26/1 
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_3_implementedCONTRACTISSUERLISTLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Step 1: Trigger IUT with CONTRACTISSUERLIST.TR_TSP_1
				f_sendAndLogTrigger(CONTRACTISSUERLIST_TR_TSP_1);

				//  Wait for apdu containing CONTRACISSUERLIST for three different manufacturers
                 // PT140 TODO : mw_aduContractIssuerList template to be defined
				var InfoExchange v_apduToBeReceived := {
				  	m_apduNoSecInit({modifies mw_aduContractIssuerList:= {manufacturerIdId := MANUFACTURERID1}}),
					m_apduNoSecInit({modifies mw_aduContractIssuerList:= {manufacturerIdId := MANUFACTURERID2}}),
					m_apduNoSecInit({modifies mw_aduContractIssuerList:= {manufacturerIdId := MANUFACTURERID3}})
           		};                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
					// Send Ack within time constraints
						f_wait(CONTRACTISSUERLIST_TIME1_TC);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						setverdict(pass);			
					} // End of alt statement
				
				f_closeDownMtc(); 
				                
                } // End of TP_TSP_CONTRACTISSUERLIST_BV_01
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
           // No Invalid Behaviour Test cases defined		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.CONTRACTISSUERLIST
    
    group DSRC_EFCCONTEXTDATA {
         group Valid_Behaviour {
           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_01: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing only mandatory context data for a domain type = dsrcContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
                 
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// iso17573ADU containing only mandatory field with valid values
                 	// feeModifiers set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_01

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_02: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing only mandatory context data for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
                  
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with valid values and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_02

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_03: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus tariffClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
                  
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with tariffClassDefinition = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_03

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_04() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_04: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus localVehicleClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
                  
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with localVehicleClassDefinition  = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_04

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_05() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_05: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus timeClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with timeClassDefinition  = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_05

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_06() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_06: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus userClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with userClassDefinition  = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_06

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_07() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_07: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus feeDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with feeDefinition  = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_07
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BI_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BI_01: Verify that the TSP correctly responds to an EFCContextDataADU containing only mandatory context data for a domain type = dsrcContext with a wrong data field 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// iso17573ADU containing only mandatory field with one invalid value
                 	// feeModifiers set to null
                 // Step 2: Wait for negative Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BI_01

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BI_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BI_02: Verify that the TSP correctly responds to an EFCContextDataADU containing only mandatory context data for a domain type = dsrcClosedContext with a wrong data field 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// dsrcClosedContext containing invalid values
                 	// feeModifiers set to null
                 	// all other mandatory fields set to valid values
                 // Step 2: Wait for negative Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BI_02

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BI_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BI_03: Verify that the TSP responds correctly to an EfcContextDataADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

				// Start by setting test success
				// Send one valid DSRC.EFCCONTEXTDATA
				// Wait for positive Ack

                // Step 1:
                	// Send one valid DSRC.EFCCONTEXTDATA before TIME1
              		// Wait for negative Ack (if positive Ack or not received set test failure)                	
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BI_03
           		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.EFCCONTEXTDATA
    
    group DSRC_BILLINGDETAILS {
         group Valid_Behaviour {

           testcase TP_TSP_DSRC.BILLINGDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BV_01: Verify that the TSP correctly performs a DSRC.BILLINGDETAILS transaction when a TC sends a single BillingDetailsADU with no optional fields except includedDiscounts and actionCode=send 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with no optional fields except includedDiscounts
                 // PT140 TODO : mw_aduBillingDetails template to be defined and includedDiscounts to be set
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, 
					  	includedDiscounts.discounts := 10, billingDetailsAmount.paymentFeeAmount := 400,
					  	includedDiscounts.discountQualifier := DiscountQualifier_userDiscount_,
					  	actionCode := ActionCode_send_
						}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                  
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BV_01

           testcase TP_TSP_DSRC.BILLINGDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BV_02: Verify that the TSP correctly performs a DSRC.BILLINGDETAILS transaction when the TC provides multiple BillingDetailsADUs with no optional fields  
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc


                 // Step 1: Send one valid APDU containing 10 valid BillingDetailsADU with actionCode = SEND
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo :=
					{m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1,
					  	billingDetailsAmount.paymentFeeAmount := 400,
					  	actionCode := ActionCode_send_
					  	}
					}),
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 2, billingDetailsAmount.paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					}),
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 3, billingDetailsAmount.paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					}),					
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 4, billingDetailsAmount.paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					}),					
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 5, billingDetailsAmount.paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					}),					
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 6, billingDetailsAmount.paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					}),					
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 7, billingDetailsAmount.paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					}),					
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 8, billingDetailsAmount.paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					}),					
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 9, billingDetailsAmount.paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					}),					
					m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 10, billingDetailsAmount.paymentFeeAmount := 500, actionCode := ActionCode_send_
					  	}
					})          	
            	};                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 					

				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BV_02

           testcase TP_TSP_DSRC.BILLINGDETAILS_BV_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BV_03: Verify that the TSP correctly performs a DSRC.BILLINGDETAILS transaction when the TC sends a single BillingDetailsADU with actionCode = adjust and no optional fields 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Prepare a billingdetails with excessive amount
				var InfoExchange v_apduRespondedTo :=
					{m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1,
					  	billingDetailsAmount.paymentFeeAmount := MAX_ACCEPTED_BILLINGDETAILS_AMOUNT.paymentFeeAmount + 4000,
					  	actionCode := ActionCode_send_
					  	}
					})};				
				// Wait for a negative ack
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimEndDateTimeRejected (804)
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_billingDetailsAmountRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_billingDetailsAmountRejected_}};
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;					
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				}
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with only mandatory fields and with
                 	// actionCode = adjust
                 	// billingDetailsNum = 1
                 	// paymentFeeAmount = 45
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_adjust_, billingDetailsAmount.paymentFeeAmount := 45
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);
				                 
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();  			
                          
           } // End of TP_TSP_DSRC.BILLINGDETAILS_BV_03

           testcase TP_TSP_DSRC.BILLINGDETAILS_BV_04() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BV_05: Verify that the TSP correctly performs a DSRC.BILLINGDETAILS transaction when the TC sends a single BillingDetailsADU with actionCode = revoke and no optional fields 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc


                 // Send one valid APDU containing one valid BillingDetailsADU numbered 1 with only mandatory field
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_, billingDetailsAmount.paymentFeeAmount := 45
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with only mandatory fields and with
                 	// actionCode = revoke
                 	// billingDetailsNum = 1
                 // PT140 TODO : mw_aduBillingDetails template and related fields to be defined

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_revoke_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);
				                 
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				}
				f_closeDownMtc();  			
				                 
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BV_04
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_DSRC.BILLINGDETAILS_BI_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BI_01: Verify that the TSP correctly responds to a series of BillingDetailsADUs bearing only mandatory fields, each BillingDetailsADU having one mandatory field bearing an incorrect value 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 3, actionCode := ActionCode_send_, billingDetailsAmount.paymentFeeAmount := 50
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 
                 
                 // Step 1: Send one valid APDU containing 10  BillingDetailsADUs with actionCode = SEND numbered from 4 to 13, each one with the following parameters respectively set to one incorrect value:
                 	// billingDetailsId.issuerId, tollContext, userId, billingDetailsAmount, usageDetails.contextName, usageDetails.appliedUserClass, usageDetails.perDeclaredVehicleClasses, usageDetails.appliedTimeClass, usageDetails.entranceTime, usageList.ListofSections.chargeObjectId
				var InfoExchange v_apduRespondedTo :=
					{m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 4, actionCode := ActionCode_send_, billingDetailsId.issuerId := 0}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 5, actionCode := ActionCode_send_, tollContext := 0}}),	
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 6, actionCode := ActionCode_send_, userId := omit}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 7, actionCode := ActionCode_send_, billingDetailsAmount.paymentFeeAmount := -5}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 8, actionCode := ActionCode_send_, usageDetails.contextName := 42}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 9, actionCode := ActionCode_send_, usageDetails.appliedUserClass := 0}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 10, actionCode := ActionCode_send_, usageDetails.perDeclaredVehicleClasses := omit}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 11, actionCode := ActionCode_send_, usageDetails.appliedTimeClass := 0}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 12, actionCode := ActionCode_send_, usageDetails.entranceTime := 0}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 13, actionCode := ActionCode_send_, usageList.ListofSections.chargeObjectId := 0}})
					};                 
				f_sendAndLogApdu(v_apduRespondedTo);
                 	
                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 with issue list present and the following issue codes:
                 	// billingDetailsIssuerIdRejected, billingDetailsContextIdRejected, billingDetailsUserIdRejected, billingDetailsAmountRejected, billingDetailsContextNameRejected, billingDetailsAppliedUserClassRejected, billingDetailsDeclaredVehicleClassRejected, billingDetailsAppliedTimeClassRejected, billingDetailsEntranceTimeRejected, billingDetailsIntermediateSectionRejected
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(BILLINGDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						// Check the issue list presence and contents
						If ispresent (m_apduNack, NackParams) and
							if (NackParams == {
							{1,AduReasonCode_billingDetailsIssuerIdRejected_},
							{2,AduReasonCode_billingDetailsContextIdRejected_},
							{3,AduReasonCode_billingDetailsUserIdRejected_}, 
							{4,AduReasonCode_billingDetailsAmountRejected_}, 
							{5,AduReasonCode_billingDetailsContextNameRejected_}, 
							{6,AduReasonCode_billingDetailsAppliedUserClassRejected_}, 
							{7,AduReasonCode_billingDetailsDeclaredVehicleClassRejected_}, 
							{8,AduReasonCode_billingDetailsAppliedTimeClassRejected_}, 
							{9,AduReasonCode_billingDetailsEntranceTimeRejected_}, 
							{10,AduReasonCode_billingDetailsIntermediateSectionRejected_} 					  
							})
						//Set verdict
						setverdict(pass);
					}
				}                  	
				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BI_01

           testcase TP_TSP_DSRC.BILLINGDETAILS_BI_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BI_02: Verify that the TSP correctly responds to a BillingDetailsADU adjusting the fee of a not previously issued BillingDetailsADU 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 3, actionCode := ActionCode_send_, billingDetailsAmount.paymentFeeAmount := 50
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						}
					}

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU numbered 14 with only mandatory fields with the following values:
                 	// actionCode = adjust
                 	// paymentFeeAmount = 45
                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 14, actionCode := ActionCode_adjust_, billingDetailsAmount.paymentFeeAmount := 45
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 identifying the APDU containing the BillingDetailsADU numbered 14 and with issueCode= semanticError 
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}};

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(BILLINGETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(BILLINGDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				}				
				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BI_02

           testcase TP_TSP_DSRC.BILLINGDETAILS_BI_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BI_03: Verify that the TSP correctly responds to a BillingDetailsADU revoking a not previously issued BillingDetailsADU 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 3, actionCode := ActionCode_send_, billingDetailsAmount.paymentFeeAmount := 50
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						}
					}

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU numbered 14 with only mandatory fields with the following values:
                 	// actionCode = revoke
                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 14, actionCode := ActionCode_revoke_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 identifying the APDU containing the BillingDetailsADU numbered 14 and with issueCode= semanticError 
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}};

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(BILLINGDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(BILLINGDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				}
				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BI_03

           testcase TP_TSP_DSRC.BILLINGDETAILS_BI_04() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BI_04: Verify that the TSP responds correctly to a BillingDetailsADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc


				// Start by setting test success
				// Send one valid DSRC.BILLINGDETAILS numbered 3
                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 3, actionCode := ActionCode_send_, billingDetailsAmount.paymentFeeAmount := 50
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Do not wait for positive Ack

                // Step 1:
                // Send one valid DSRC.BILLINGDETAILS numbered 4  before TIME1
                 //  Send one valid APDU containing one BillingDetailsADU numbered 4 with actionCode = SEND and only mandatory fields
                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 4, actionCode := ActionCode_send_, billingDetailsAmount.paymentFeeAmount := 45
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

              		// Wait for negative Ack with ADUReasonCode field = requestSentTooOften (if positive Ack or not received set test failure)                	
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch
				// Set timer
                 t_step.start(BILLINGDETAILS_TIME1_MAX_TSP);
				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(BILLINGDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				}
                
                f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BI_04

		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.BILLINGDETAILS
    
    group DSRC_REPORTABNORMALOBE {
         group Valid_Behaviour {

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BV_01: Verify that the TSP correctly performs a DSRC.REPORTABNORMALOBE transaction in response to an APDU containing valid ReportAbnormalOBEADUs 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                // Send one valid DSRC.REPORTABNORMALOBE
                 // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within DSRC_REPORTABNORMALOBE_TIME1
				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                  
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BV_01


 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_01: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no userId field present 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                // Send one  DSRC.REPORTABNORMALOBE with userId field missing
                // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduReportAbnormalOBE:= {
					  	userId := omit,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)                	
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}};

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
				}				
				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_01

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_02: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no value or invalid values in the field userId 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                // Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with missing and second one with userID set to an invalid value

                // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := {
					m_apduNoSecInit({modifies mw_aduReportAbnormalOBE:= {
					  	userId := omit,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					}),
					m_apduNoSecInit({modifies mw_aduReportAbnormalOBE:= {
					  	userId := WRONG_USER_ID,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					})	
           		};                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeUserIdRejected
              			                	
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_abnormalObeUserIdRejected_}}

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					} // End of alt statement				
               	
               	f_closeDownMtc();  			
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_02

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_03: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no dateAndTime field 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Step 1:
                // Send one  DSRC.REPORTABNORMALOBE with dateAndTime field missing
                // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := {
					m_apduNoSecInit({modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	dateAndTime := omit,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					})	
           		};                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)                	
              			                	
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}};

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					} //End of alt statement				
               	
               	f_closeDownMtc();  
                                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_03

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_04() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_04: Verify that the TSP correctly responds to an APDU containing ReportAbnormalOBEADU with no value or invalid values in field dateAndTime 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                	// Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with dateAndTime missing and second one with dateAndTime set to a future value

                // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := {
					m_apduNoSecInit({modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	dateAndTime := omit,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					}),
					m_apduNoSecInit({modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	dateAndTime := now + 1000;
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					})	
           		};                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              		// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeDateAndTimeRejected
              			                	
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,abnormalObeDateAndTimeRejected_}}

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					} // End of alt statement				
               	
               	f_closeDownMtc(); 
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_04

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_05() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_05: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no efcContextMark field 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                // Send one  DSRC.REPORTABNORMALOBE with efcContextMark field missing
                // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := {
					m_apduNoSecInit({modifies mw_aduReportAbnormalOBE:= {					  	
					  	userId := EXISTING_USER_ID,
					  	efcContextMark := omit,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					})	
           		};                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	
              	// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)                	
              			                	
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_}};

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					}	// End of alt statement			
               	
               	f_closeDownMtc();
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_05

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_06() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_06: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no value or invalid values in the field efcContextMark 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                	// Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with efcContextMark missing and second one with efcContextMark set to an invalid value

                // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := {
					m_apduNoSecInit({modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	efcContextMark := omit,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					}),
					m_apduNoSecInit({modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	efcContextMark := 0,
					  	dateAndTime := now + 1;
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					})	
           		};                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	// Step 2:
              		// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeDateAndTimeRejected
              			                	
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}}

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					}	// End of alt statement		
               	
               	f_closeDownMtc(); 
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_06

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_07() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_07: Verify that the TSP correctly responds to an APDU containing ReportAbnormalOBEADU not containing the abnormalOBEReason field 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                	// Send one  DSRC.REPORTABNORMALOBE with abnormalOBEReason field missing
                // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := {
					m_apduNoSecInit({modifies mw_aduReportAbnormalOBE:= {					  	
					  	userId := EXISTING_USER_ID,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := omit
					  	}
					})	
           		};                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	
              	// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)                	
              			                	
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_}};

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					}	// End of alt statement			
               	
               	f_closeDownMtc();
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_07

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_08() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_08: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no value or invalid values in the field abnormalOBEReason 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                	// Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with abnormalOBEReason missing and second one with abnormalOBEReason set to an invalid value

                // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := {
					m_apduNoSecInit(modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := omit
						}),
					m_apduNoSecInit(modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := 700
						})	
           			};                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
                
              	// Step 2:
              		// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeReasonCodeRejected              			                	
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
				var NAckParams v_nAckParams2 :={{1, abnormalObeReasonCodeRejected},{2,abnormalObeReasonCodeRejected}};

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
					}	// End of alt statement	               	
               	f_closeDownMtc();             
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_08
               
			testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_09() runs on MainTestComponent system TestAdapter {
                 /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_09: Verify that the TSP responds correctly to a ReportAbnormalOBEADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Send one valid DSRC.REPORTABNORMALOBE
                 // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_reasonNotToBeDisclosed_
					  	}
					}); 
 
 				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Do not wait for positive Ack
                // Send one one  APDU containg one valid ReportAbnormalOBEADU before TIMEA_MIN
                 // PT140 TODO : mw_aduReportAbnormalOBE template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduReportAbnormalOBE:= {
					  	userId := EXISTING_USER_ID,
					  	dateAndTime := now,
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_obeIsNotWorkingProperly_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
              	// Wait for negative Ack with ADUReasonCode field = requestSentTooOften (if positive Ack or not received set test failure)                	
				// Set timer
                t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				alt {
					[] mtcPort.receive(m_apduNAck_requestSentTooOften(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						setverdict(pass);
						}
                	} // End of alt statement               
                f_closeDownMtc(); 					
				} // End of  TP_TSP_DSRC.REPORTABNORMALOBE_BI_09             		
			
		} // End of group Invalid_Behaviour 
	} // End of group DSRC.REPORTABNORMALOBE
    
    group GNSS_TOLLDECLARATION {
         group Valid_Behaviour {
           testcase TP_TSP_GNSS_TOLLDECLARATION_BV_01() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_TOLLDECLARATION_BV_01: Verify that the TSP correctly performs a GNSS.TOLLDECLARATION transaction with actionCodes = send, revoke and adjust 
                  * @remark  [16986:2016], Clause 8.1 and Table A.1/2 AND Table A.2/2 AND Table A.52/3
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send three valid TollDeclarationADUs with actionCode = send, revoke, and adjust, respectively
				// PT140 TODO: mw_aduGnssTollDeclaration template to be defined
				// PT140 TODO: way to set or change amount in the Charge report to be defined
				var InfoExchange v_apduToBeReceived := m_apduNoSecInit(
					{modifies mw_aduGnssTollDeclaration:= {
					  	amount := *,
					  	actionCode := ActionCode_send_,
					  	}
					},
					{modifies mw_aduGnssTollDeclaration:= {
					  	actionCode := ActionCode_adjust_,
					  	amount := *,
						}
					},
					{modifies mw_adGnssTollDeclaration := {
						actionCode := ActionCode_revoke_  
						}					  
					});
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_A);												
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
					// PT140 TODO: verify that the extraction of the tollDeclarationId from the received apdu is correct
					var TollDeclarationId v_idReceived1 = v_apduReceived.infoExchangeContent.adus.TollDeclarationADU[1].tollDeclarationId
					var TollDeclarationId v_idReceived2 = v_apduReceived.infoExchangeContent.adus.TollDeclarationADU[2].tollDeclarationId
					var TollDeclarationId v_idReceived3 = v_apduReceived.infoExchangeContent.adus.TollDeclarationADU[3].tollDeclarationId					

						if ((v_idReceived1 = v_idReceived2) and (v_idReceived1 = v_idReceived3){
							setverdict(pass);
							// Step3: Send DefaultAck with correct identifier and set verdict
							f_wait(GNSSTOLLDECLARATION_TIME1_TC);
							f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));							  
							}
						else {
							setverdict(fail)
						};
 					} // End of alt statement 
               	f_closeDownMtc();               
                } // End of TP_TSP_GNSS_TOLLDECLARATION_BV_01
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
           
           // No Test Cases are defined for invalid behaviour.		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.TOLLDECLARATION
    group GNSS_BILLINGDETAILS_TSP {
         group Valid_Behaviour {

           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_01: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with BillingDetailsADUs
				  * @desc 	 containing all permutations of present and not present optional fields that vary in the IUT implementation, all with actionCode=send 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_3_implementedGNSSTOLLDECLARATION and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_B);												
				//  Wait for GNSS.TOLLDECLARATION
				// PT140 TODO: mw_aduGnssTollDeclaration template to be defined
				var InfoExchange v_apduToBeReceived := m_apduNoSecInit(mw_aduGnssTollDeclaration);
				
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
							
					// Send Ack within time constraints
					f_wait(GNSSTOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					setverdict(pass);						
 					} // End of alt statement 
				
				// Step 1: Trigger IUT with GNSS.BILLINGDETAILS_TSP_1_A to send  valid BillingDetailsADUs with:
					// actionCode = send
					// all permutations of present and not present optional fields that vary in the IUT implementation
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_A);				
				
				//  Wait for GNSS.BILLINGDETAILS
				// PT140 TODO: mw_apduGnssBillingDetails_TSP to be defined
				alt {
					[] mtcPort.receive(mw_apduGnssBillingDetails_TSP) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
							
						// Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TSP_TIME1_TC);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
							
						// Set test success
						setverdict(pass);						
						}
 					} // End of alt statement
				f_closeDownMtc();   						           				                                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_01           
          
           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_06: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with single BillingDetailsADU with actionCode = adjust and no optional fields 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_3_implementedGNSSTOLLDECLARATION and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_B);												
				//  Wait for GNSS.TOLLDECLARATION
				// PT140 TODO: mw_aduGnssTollDeclaration template to be defined
				var InfoExchange v_apduToBeReceived := m_apduNoSecInit(mw_aduGnssTollDeclaration);
				
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
							
					// Send Ack within time constraints
					f_wait(GNSSTOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
 					} // End of alt statement 
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_B1);				
				
				//  Wait for GNSS.BILLINGDETAILS
				// PT140 TODO: mw_apduGnssBillingDetails_TSP to be defined
				alt {
					[] mtcPort.receive(mw_apduGnssBillingDetails_TSP) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
							
						// Send NAck within time constraints
						f_wait(GNSS_BILLINGDETAILS_TSP_TIME1_TC);
						f_sendAndLogApdu(m_apduNAck(v_apduReceived, billingDetailsAmountRejected));
						}
 					} // End of alt statement

				// Step 1: Trigger IUT with GNSS.BILLINGDETAILS.TR_TSP_1_B2 to send one APDU containing one valid BillingDetailsADU with:
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_B2);				
				
				//  Wait for GNSS.BILLINGDETAILS
				// PT140 TODO: mw_apduGnssBillingDetails_TSP to be defined
				alt {
					[] mtcPort.receive(mw_apduGnssBillingDetails_TSP) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
							
						// Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TSP_TIME1_TC);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
							
						// Set test success
						setverdict(pass);						
						}
 					} // End of alt statement
				f_closeDownMtc();   						           				                                
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_02           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_03: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with revoking a single BillingDetailsADU containing only mandatory fields 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 
                 	// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one APDU containing one valid TollDeclarationADU
                 	// Send a positive Ack to conclude the TOLLDECLARATION transaction
                 	// Trigger IUT with GNSS.BILLINGDETAILS.TR_TSP_1 to send a valid BillingDetails ADU with billingDetailsNum field value = 1
                 	// Send a positive Ack to conclude the BILLINGDETAILS ADU
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_3_implementedGNSSTOLLDECLARATION and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_B);												
				//  Wait for GNSS.TOLLDECLARATION
				// PT140 TODO: mw_aduGnssTollDeclaration template to be defined
				var InfoExchange v_apduToBeReceived := m_apduNoSecInit(mw_aduGnssTollDeclaration);
				
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
							
					// Send Ack within time constraints
					f_wait(GNSSTOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
 					} // End of alt statement 
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_B1);				
				
				//  Wait for GNSS.BILLINGDETAILS
				// PT140 TODO: mw_apduGnssBillingDetails_TSP to be defined
				alt {
					[] mtcPort.receive(mw_apduGnssBillingDetails_TSP) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
							
						// Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TSP_TIME1_TC);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						}
 					} // End of alt statement

				// Step 1: Trigger IUT with GNSS.BILLINGDETAILS.TR_TSP_1_C to send one APDU containing one valid BillingDetailsADU with:
					// actionCode = ActionCode_revoke_
					// only mandatory fields present with valid values
					// billingDetailsNum field value = same as previous sent Billing Details
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_C);				
				
				//  Wait for GNSS.BILLINGDETAILS
				// PT140 TODO: mw_apduGnssBillingDetails_TSP to be defined
				alt {
					[] mtcPort.receive(mw_apduGnssBillingDetails_TSP) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
							
						// Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TSP_TIME1_TC);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
							
						// Set test success
						setverdict(pass);						
						}
 					} // End of alt statement
				f_closeDownMtc();   						           				                                
				
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_03           


 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
           // No Test Cases are defined for invalid behaviour.		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS_TSP
    
    group GNSS_BILLINGDETAILS_TC {
         // Base TCs shall be carried out in addition and prior to the TCs listed below.
         group Valid_Behaviour {

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_01: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU with no optional fields except includedDiscounts field and actionCode=send 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

				
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// includedDiscounts in usageList with textDetail field being set according to values specified in Table A.54 of CEN/TS 16986:2016
                 	// PT140 TODO: Correct template to be defined. Using basic BillingDetails template in what follows (to be changed)
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_, includedDiscounts.discounts := 10, includedDiscounts.discountQualifier := DiscountQualifier_userDiscount_ }}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                  
           } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_01           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_02: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with no optional fields, actionCode = send and having selected forSectionedRoads 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

				
                // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// CHOICE forSectionedRoads
                  	// PT140 TODO: Correct template to be defined. Using basic BillingDetails template in what follows (to be changed)
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_ }
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                
           } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_02           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_03: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with no optional fields, actionCode = send and having selected forTravellingInArea 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

				
                // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// CHOICE forTravellingInArea
                  	// PT140 TODO: Correct template to be defined. Using basic BillingDetails template in what follows (to be changed)
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_ }
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                
                
            } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_03           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_04() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_04: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with no optional fields, actionCode = send and having selected forStayingInArea 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

				
                // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// CHOICE forStayingInArea
                  	// PT140 TODO: Correct template to be defined. Using basic BillingDetails template in what follows (to be changed)
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_ }
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                
                
            } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_04           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_05() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_05: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with no optional fields, actionCode = send and having selected forCordonCrossings 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

				
                // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// CHOICE forCordonCrossings
                  	// PT140 TODO: Correct template to be defined. Using basic BillingDetails template in what follows (to be changed)
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_ }
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                
                
            } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_05            

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_06() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_06: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction
				  * @desc    with multiple BillingDetailsADUs with no optional fields 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement
				
                 // Step 1: Send one valid APDU containing a number of valid BillingDetailsADU equal to GNSS.BILLINGDETAILS.TSP.PARAM1_MAX, with
                 	// action code = send 
                 	// no optional fields
                // Set first element of apdu
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_ }
					});                 
				// PT140 TODO: Is that a correct setting of an APDU with multiple ADUs?				
				// Set all remaining elements of apdu
				for (var integer v_ind := 2, v_ind < (GNSS.BILLINGDETAILS_TSP_PARAM1_MAX - 1), v_ind := v_ind + 1)
						v_apduRespondedTo[v_ind] := m_apduNoSecInit({modifies mw_aduBillingDetails:= {
					  	billingDetailsId := v_ind, actionCode := ActionCode_send_ }});
						continue;
				
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();                 
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_06
                
           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_07() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_07: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with actionCode = adjust and no optional fields
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

				
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// billingDetailsAmount set to a value (to be modified later)
                 	// PT140 TODO: Correct template to be defined. Using basic BillingDetails template in what follows (to be changed)
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_, billingDetailsAmount := 10000}}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for negative Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_billingDetailsAmountRejected_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_billingDetailsAmountRejected_}};

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						}
					} 
					
                 // Step 1: Send one valid APDU containing BillingDetailsADU as the only ADU, where:
                 	// the values of all fields in BillingDetailsADU being valid and within the range specified by the IUT
                 	// no optional fields are specified
                 	// billingDetailsNum referencing the previously sent BillingDetailsADU
                 	// action code = adjust
                 	// value of the fee being in an acceptable range
                 // PT140 TODO :  template and related fields to be defined. Provisionally used mw_aduBillingDetails

				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_adjust_, billingDetailsAmount := 45}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);
				                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();  			
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_07                 

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_08() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_08: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with actionCode = revoke and no optional fields
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

				
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// includedDiscounts in usageList with textDetail field being set according to values specified in Table A.54 of CEN/TS 16986:2016
                 	// PT140 TODO: Correct template to be defined. Using basic BillingDetails template in what follows (to be changed)
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_, billingDetailsAmount := 45 }}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
					}
				} 
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_revoke_ }}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduRespondedTo)) -> value v_apduReceived {
					  
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						setverdict(pass);
					}
				} 					
				f_closeDownMtc();					           
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_08                                     
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_01: Verify that the TSP correctly responds to a series of BillingDetailsADUs bearing only mandatory fields,
				  * @desc    each BillingDetailsADU having one mandatory field bearing an incorrect value 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                  
                 // Initialisation 
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

				
                 // Step 1: Send one valid APDU containing 13 valid BillingDetailsADUs, each one with the following parameters respectively set to one incorrect value:
                 	// billingDetailsId.issuerId, tollContext, userId, Period, billingDetailsAmount, usageDetails.contextName, usageDetails.appliedUserClass, usageDetails.perDeclaredVehicleClasses, usageDetails.appliedTimeClass, usageDetails.entranceTime, usageList.ListofSections.chargeObjectId, exitChargeObject, exitTime
                 // PT140 TODO: template to be defined. Using mw_aduBillingDetails provisionally.
				var InfoExchange v_apduRespondedTo :=
					{m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 4, actionCode := ActionCode_send_, billingDetailsId.issuerId := 0}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 5, actionCode := ActionCode_send_, tollContext := 0}}),	
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 6, actionCode := ActionCode_send_, userId := omit}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 7, actionCode := ActionCode_send_, billingDetailsAmount.paymentFeeAmount := -5}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 8, actionCode := ActionCode_send_, usageDetails.contextName := 42}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 9, actionCode := ActionCode_send_, usageDetails.appliedUserClass := 0}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 10, actionCode := ActionCode_send_, usageDetails.perDeclaredVehicleClasses := omit}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 11, actionCode := ActionCode_send_, usageDetails.appliedTimeClass := 0}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 12, actionCode := ActionCode_send_, usageDetails.entranceTime := 0}}),
					m_apduNoSecInit(
						{modifies mw_aduBillingDetails:= {billingDetailsId := 13, actionCode := ActionCode_send_, usageList.ListofSections.chargeObjectId := 0}})
					};                 
				f_sendAndLogApdu(v_apduRespondedTo);
                 	
				// Set timer
                t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
                 	
                 // Step 2: Wait for negative Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC with issue list present and the following issue codes:
                 	// billingDetailsIssuerIdRejected, billingDetailsContextIdRejected, billingDetailsUserIdRejected, billingDetailsPeriodRejected, billingDetailsAmountRejected, billingDetailsContextNameRejected, billingDetailsAppliedUserClassRejected, billingDetailsDeclaredVehicleClassRejected, billingDetailsAppliedTimeClassRejected, billingDetailsEntranceTimeRejected, billingDetailsIntermediateSectionRejected, billingDetailsExitChargeObjectRejected, billingDetailsExitTimeRejected
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						// Check the issue list presence and contents
						If ispresent (m_apduNack, NackParams) and
							if (NackParams == {
							{1,AduReasonCode_billingDetailsIssuerIdRejected_},
							{2,AduReasonCode_billingDetailsContextIdRejected_},
							{3,AduReasonCode_billingDetailsUserIdRejected_}, 
							{4,AduReasonCode_billingDetailsAmountRejected_}, 
							{5,AduReasonCode_billingDetailsContextNameRejected_}, 
							{6,AduReasonCode_billingDetailsAppliedUserClassRejected_}, 
							{7,AduReasonCode_billingDetailsDeclaredVehicleClassRejected_}, 
							{8,AduReasonCode_billingDetailsAppliedTimeClassRejected_}, 
							{9,AduReasonCode_billingDetailsEntranceTimeRejected_}, 
							{10,AduReasonCode_billingDetailsIntermediateSectionRejected_} 					  
							})
						//Set verdict
						setverdict(pass);
						}
					}
				f_closeDownMtc();  			
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_01                     

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_02: Verify that the TSP correctly responds to a BillingDetailsADU adjusting the fee for a BillingDetailsADU that does not exist 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                  
                 // Initialisation 

				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 14, actionCode := ActionCode_adjust_, paymentFeeAmount := 45
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 identifying the APDU containing the BillingDetailsADU numbered 14 and with issueCode= semanticError 
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}};
				// Set timer
                t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 

				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				}				
				f_closeDownMtc();  			
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_02           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_03: Verify that the TSP correctly responds to a BillingDetailsADU
				  * @desc    revoking a BillingDetailsADU that does not exist at the TSP 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 14, actionCode := ActionCode_revoke_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

                 // Step 2: Wait for negative Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC identifying the APDU containing the BillingDetailsADU numbered 14 and with issueCode= semanticError 
				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}};
				// Set timer
                t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);                 
				alt {
					// Either Params1 or Params2 Nacks are valid
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(BILLINGETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(BILLINGDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				}				
				f_closeDownMtc();  
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_03           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_04() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_04: Verify that the TSP correctly responds to a BillingDetailsADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                  
                 // Initialisation 
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send positive Ack within time constraints
					// Send one valid APDU containing one valid BillingDetailsADU with action code = send and no optional parameters
					// Wait for positive Ack
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				//  PT140 TODO: Template for Toll Declaration to be defined
				alt {
					[] mtcPort.receive(mw_apduTollDeclaration) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(TOLLDECLARATION_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement

                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 1, actionCode := ActionCode_send_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

				// Do not wait for positive Ack

                // Step 1:
                // Send one valid DSRC.BILLINGDETAILS numbered 4  before TIME1
                 //  Send one valid APDU containing one BillingDetailsADU numbered 4 with actionCode = SEND and only mandatory fields
                 // PT140 TODO : mw_aduBillingDetails template to be defined
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies mw_aduBillingDetails:= {
					  	billingDetailsId := 4, actionCode := ActionCode_send_
					  	}
					});                 
				f_sendAndLogApdu(v_apduRespondedTo);                 

              		// Wait for negative Ack with ADUReasonCode field = requestSentTooOften (if positive Ack or not received set test failure)                	
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TC);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				alt {
					[] mtcPort.receive(m_apduNAck_requestSentTooOften(v_apduRespondedTo)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
                } // End of alt statement
                
                f_closeDownMtc();  			
                                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_04           
		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS.TC
    
    group GNSS_PAYMENTANNOUNCEMENT {
         group Valid_Behaviour {

           testcase TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_01: Verify that the TSP correctly performs the GNSS.PAYMENTANNOUNCEMENT transaction with actionCode=send 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.2/2 AND Table A.52/4 
                  */                 
                 // Initialisation 

				// The IUT is supposedly being prepared with valid test toll declaration data
					
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Step 1: Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_A to send one valid PaymentAnnouncementADU with actionCode = send
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_A);												
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				// PT140 TODO: mw_aduGnssPaymentAnnouncement template to be defined
				var InfoExchange v_apduToBeReceived := m_apduNoSecInit(
					{modifies mw_aduGnssPaymentAnnouncement:= {
					  	actionCode := ActionCode_send_
					  	}
					});
					
					// Wait for PaymentAnnouncementADU within allowed time constraints
				t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TSP);	
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
							
					// Send Ack within time constraints
					f_wait(PAYMENTANNOUNCEMENT_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					// Set test success
					setverdict(pass);						
 					} // End of alt statement 
               	f_closeDownMtc();
               
                } // End of TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_01                    

           testcase TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_02() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_02: Verify that the TSP correctly performs the GNSS.PAYMENTANNOUCEMENT transaction with actionCode=adjust 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.2/2 AND Table A.52/4 
                  */
                  
                 // Initialisation 

				// The IUT is supposedly being prepared with valid test toll declaration data
					
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_A to send one valid PaymentAnnouncementADU with actionCode = send
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_A);												
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				// PT140 TODO: mw_aduGnssPaymentAnnouncement template to be defined
				var InfoExchange v_apduToBeReceived := m_apduNoSecInit(
					{modifies mw_aduGnssPaymentAnnouncement:= {
					  	actionCode := ActionCode_send_
					  	}
					});
					
					// Wait for PaymentAnnouncementADU within allowed time constraints
				t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TSP);	
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
							
					// Send Ack within time constraints
					f_wait(PAYMENTANNOUNCEMENT_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					// Remember Payment Announcement ID and amount for future usage
					var integer idReceived := v_apduReceived.infoExchangeContent.adus.PaymentAnnouncementADU.paymentAnnouncementID;
					var ExtendedPaymentAmount amountReceived := v_apduReceived.infoExchangeContent.adus.PaymentAnnouncementADU.totalamount
 					} // End of alt statement

				// Step 1: Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_B to send one valid PaymentAnnouncementADU with actionCode = adjust
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_B);												
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				// PT140 TODO: mw_aduGnssPaymentAnnouncement template to be defined
				var InfoExchange v_apduToBeReceived := m_apduNoSecInit(
					{modifies mw_aduGnssPaymentAnnouncement:= {
					  	paymentAnnouncementID := idReceived,
					  	actionCode := ActionCode_adjust_,
					  	totalamount !=	amountReceived				  	
					  	}
					});
				// Wait for PaymentAnnouncementADU within allowed time constraints
				t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TSP);	
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
							
					// Send Ack within time constraints
					f_wait(PAYMENTANNOUNCEMENT_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					// Set test success
					setverdict(pass);						
 					} // End of alt statement
               	
               	f_closeDownMtc();
                               
                } // End of TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_02                    

           testcase TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_03() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_03: Verify that the TSP correctly performs the GNSS.PAYMENTANNOUCEMENT transaction with actionCode=revoke 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.2/2 AND Table A.52/4 
                  */
                  
                 // Initialisation 
				// The IUT is supposedly being prepared with valid test toll declaration data
					
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_A to send one valid PaymentAnnouncementADU with actionCode = send
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_A);												
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				// PT140 TODO: mw_aduGnssPaymentAnnouncement template to be defined
				var InfoExchange v_apduToBeReceived := m_apduNoSecInit(
					{modifies mw_aduGnssPaymentAnnouncement:= {
					  	actionCode := ActionCode_send_
					  	}
					});					
					// Wait for PaymentAnnouncementADU within allowed time constraints
				t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TSP);	
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
							
					// Send Ack within time constraints
					f_wait(PAYMENTANNOUNCEMENT_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					// Remember Payment Announcement ID and amount for future usage
					var integer idReceived := v_apduReceived.infoExchangeContent.adus.PaymentAnnouncementADU.paymentAnnouncementID;
 					} // End of alt statement

				// Step 1: Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_C to send one valid PaymentAnnouncementADU with actionCode = revoke
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_C);												
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				// PT140 TODO: mw_aduGnssPaymentAnnouncement template to be defined
				var InfoExchange v_apduToBeReceived := m_apduNoSecInit(
					{modifies mw_aduGnssPaymentAnnouncement:= {
					  	paymentAnnouncementID := idReceived,
					  	actionCode := ActionCode_revoke_
					  	}
					});
				// Wait for PaymentAnnouncementADU within allowed time constraints
				t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TSP);	
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
							
					// Send Ack within time constraints
					f_wait(PAYMENTANNOUNCEMENT_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					// Set test success
					setverdict(pass);						
 					} // End of alt statement
               	
               	f_closeDownMtc();					
                
                } // End of TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_03                    

 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
           // No Test Cases are defined for invalid behaviour.		           		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.PAYMENTANNOUNCEMENT
} // End of module Toll_Service_Provider

