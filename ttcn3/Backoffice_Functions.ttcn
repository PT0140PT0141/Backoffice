/**
 * @author  PT0140 
 * @desc    This module provides the functions signature for:
 * - external functions
 * - communication support
 * - common Context Data support
 * @remark  These functions are used by preamble/postambule function to initialization/deinitialization communication stack
 * @see     Electronic fee collection (EFC) — Application interface definition for autonomous systems — Part 2: Communication and connections to the lower layers
 * @version $id$
 */
module Backoffice_Functions language "TTCN-3:2010 Advanced Parameterization" { 

    group External {
        /**
         * @desc    These function initializes the communication stack
         * @return  ERNoError on success, error code otherwise
         * @see     Clauses 7. EFC communication services (functions)
         * @see     Clauses 8. The use of a communication stack)
         */
        //external function fx_templateWeMightNeedSomethingLikeThis() return CommunicationErrorCodes ;
        
        group Security {        
            /**
             * @desc Initialise external security module
             * @return true on success, false  otherwise
             */
            external function fx_aGroupWithinAGroup_PerhapsWeNeedThis() return boolean;
        }  
    } 

	group Internal {
	  
	  var set of ADUs InfoExchange_ADUS;
	  var InfoExchange v_info_Exchange;
	  timer waitTimer; 
	  
	function f_LogNotExecuted(in charstring theTestcase){
		log("*** " & theTestcase & ": tescase not to be executed according to TP validity conditions and parameters in PICS ***");
		}
	  
	function f_checkMinimumTime(in timer t_compare, in float v_timeMin) {	                      
        if (t_compare.read <= v_timeMin) {setverdict(fail)};
    	}  
    	
    // Function which inserts a waiting time - parameter t_wait - and gives back TRUE in case waiting time is over
	function f_waitTime(in timer t_wait, out boolean v_timeElapsed) {
		v_timeElapsed := false;
		t_waitTimer.start(t_wait);
		while (t_waitTimer.running) {
			// empty loop = do nothing, but just wait
			}
		v_timeElapsed := true // waiting time elapsed
		}
	
	// Function f_prepareInfoExchange to be used in case of multiple ADUs InfoExchange
	// It  concatenates multiple ADUs into a single stream and prepare APCI accordingly
	function f_prepareInfoExchange(in InfoExchange_ADUS v_InfoExchange_ADUS, in boolean v_authenticate, out InfoExchange v_Infoexchange) {
	  
		}
	
	// Function f_receiveAPDUs receives the complete APDU into a buffer, and passes it back, together with the number
	// of ADUS that are contained in the ADUs field
	function f_receiveAPDUs(in port t_port, out infoExchangeContent v_infoExchangeContent, out integer v_numStruct) {
	  
		}

	// Function f_SendAPDU sends the APDU by using the given APDU in the given port and calculating the Authenticator, if requested
	function f_SendAPDU (in port t_port, in  template (value) InfoExchange t_APDU) {
		 if (not (PICS_SECURED_MODE)) {
                pco.send(m_InfoExchange_unsecured(t_APDU));
            } else {
                var template (value) AuthenticatedInfoExchange v_secured_packet;
                f_secured_packet(p_InfoExchange_Adu, v_secured_packet);
                pco.send(m_InfoExchange_secured(v_secured_packet));
            }	  
	}
	
	// Function f_MatchInADUs gives back an ADU of the given type, if found in the passed set of ADUs
	function f_matchInADUs (in ADUs ADUToBeMatched, in ADUs bufferToSearch) {
	 
		}
	}
	}
} 