/**
 * @author  PT0140 
 * @desc    This module provides the functions signature for:
 * - external functions
 * - communication support
 * - common Context Data support
 * @remark  These functions are used by preamble/postambule function to initialization/deinitialization communication stack
 * @see     Electronic fee collection (EFC) — Application interface definition for autonomous systems — Part 2: Communication and connections to the lower layers
 * @version $id$
 */
module Backoffice_Functions language "TTCN-3:2010 Advanced Parameterization" { 

    group External {
        /**
         * @desc    These function initializes the communication stack
         * @return  ERNoError on success, error code otherwise
         * @see     Clauses 7. EFC communication services (functions)
         * @see     Clauses 8. The use of a communication stack)
         */
       external function fx_computeAuthenticator(in InfoExchangeContent v_InfoExchange) return infoExchangeAuthenticator;
        
    } 

	group Internal {
	  
	  var set of ADUs InfoExchange_ADUS;
	  var InfoExchange v_info_Exchange;
	  timer waitTimer;

	function f_LogNotExecuted(in charstring theTestcase){
		log("*** " & theTestcase & ": testcase not to be executed according to TP validity conditions and parameters in PICS ***");
		}

	function f_addLogEntry(in charstring theTestcase, text){
		log("*** " & theTestcase & : text);
		}
	  
	function f_checkMinimumTime(in timer t_compare, in float v_timeMin) {	                      
        if (t_compare.read <= v_timeMin) {setverdict(fail)};
    	}  
    	
    // Function which inserts a waiting time - parameter t_wait - und waits in a "do-nothing-loop"
	function f_waitTime(in timer t_wait) {
		t_waitTimer.start(t_wait);
		while (t_waitTimer.running) {
			// empty loop = do nothing, but just wait
			}
		}
	
	// Function f_prepare_toReceive_InfoExchange to put ADUs together with APCIS and prepare InfoExchange to be received
	// It  concatenates multiple ADUs into a single stream and prepare APCI accordingly
	
	function f_prepare_toReceive_InfoExchange(in ADUS v_InfoExchange_ADUS) return InfoExchange {
		var InfoExchangeContent v_InfoexchangeContent;
		var InfoExchange v_InfoExchange;
		v_InfoexchangeContent.apci := m_apciFields  { apduOriginator := ORIGINATOR, informationSenderID := SENDER, 
			informationrecipientID := TESTER_ID,
			};
		v_InfoexchangeContent.adus := v_InfoExchange_ADUS;
		v_InfoExchange.infoExchangeContent := v_InfoexchangeContent;
		v_InfoExchange.infoExchangeAuthenticator := AnyOrOmit;
		
		return v_Infoexchange;
		}

	function f_prepare_toSend_InfoExchange(in ADUS v_InfoExchange_ADUS, in integer v_APDU_To_Answer) return InfoExchange {
		var InfoExchangeContent v_InfoexchangeContent;
		var InfoExchange v_InfoExchange;
		if (v_APDU_To_Answer != null) {
			v_InfoexchangeContent.apci := m_apciFields  { apduOriginator := TESTER_ID, informationSenderID := TESTER_ID, 
				informationrecipientID := ORIGINATOR
				};
			}
		else {
			v_InfoexchangeContent.apci := m_apciFields  { apduOriginator := TESTER_ID, informationSenderID := TESTER_ID, 
				informationrecipientID := ORIGINATOR, RelatedApduId.apduOriginator := ORIGINATOR,
//PT140: Need to look at all uses of random to put in a multiplier that gives the right range
				RelatedApduId.apduIdentifier := float2int(rnd())
				};
			}
		v_InfoexchangeContent.adus := v_InfoExchange_ADUS;
		v_InfoExchange.infoExchangeContent := v_InfoexchangeContent;
		
		return v_Infoexchange;
		}
	

	// Function f_SendAPDU sends the APDU by using the given APDU in the given port and calculating the Authenticator, if requested
	function f_SendAPDU (in InfoExchange t_APDU) {
		 if (not (PICS_SECURED_MODE)) {
                v_InfoExchange.infoExchangeAuthenticator := omit;
            } else {
                v_InfoExchange.infoExchangeAuthenticator := fx_computeAuthenticator(v_InfoexchangeContent);
            }
            
          IutComp.send(v_InfoExchange);
             	  
	}
	
	}
}
 