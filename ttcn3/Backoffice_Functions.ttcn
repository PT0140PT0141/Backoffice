/**
 * @author  PT0140 
 * @desc    This module provides the functions signature for:
 * - external functions
 * - communication support
 * - common Context Data support
 * @remark  These functions are used by preamble/postambule function to initialization/deinitialization communication stack
 * @see     Electronic fee collection (EFC) — Application interface definition for autonomous systems — Part 2: Communication and connections to the lower layers
 * @version $id$
 */
module Backoffice_Functions language "TTCN-3:2010 Advanced Parameterization" { 

	//importing other modules
	import from Backoffice_Interfaces all;
	
	//importing ASN.1 data automatically translated into TTCN-3	
	import from EfcInfoExchange language "ASN.1:1997" all;

	//importing ASN.1 data manually translated into TTCN-3
	import from Backoffice_Parameterised_Asn1_Data all;
	import from Common_Parametrised_Asn1_Data all;


    group External {
        /**
         * @desc    These function initializes the communication stack
         * @return  ERNoError on success, error code otherwise
         * @see     Clauses 7. EFC communication services (functions)
         * @see     Clauses 8. The use of a communication stack)
         */
       external function fx_computeAuthenticator(in InfoExchangeContent v_InfoExchange) return ApduAuthenticator;
         
    } 

	group Internal {
	  
        /**
         * @desc        ADU filtering for received messages on IuTComp
         * @verdict     Unchanged on success, fail otherwise and the component is stopped if PX_ProcessUnexpectedADUAsError is set to true
         */
    	altstep a_defaults() runs on MainTestComponent {
        	var InfoExchange v_infoExchange;
    		[] iutPort.receive -> value v_infoExchange {
                f_addLogEntry("Unexpected APDU received");
                f_addLogEntry(any2unistr(v_infoExchange));
                repeat; // Ignore unexpected ADUs, but log them
            }
    
            [] any timer.timeout {
                f_addLogEntry("Unexpected timeout occured");
                setverdict(inconc);
                stop;
            } // End of any timer.timeout
        } 
 
	//PT140: need to check ports to be initialised
    //PT140: port names left as those from 17575 tests  
 	function f_intialiseMtc(boolean runTestcase) runs on MainTestComponent {
 
 		//PT140 TODO check if this works...
 		if (not runTestcase) {
 			f_addLogEntry("Testcase shall not be run according to ISO 16986 Implementation Conformance Statement (ICS).");
 			setverdict(inconc);
 			break;
 		}
 		
 		// Initialize communication stack
        f_InitializeCommunication();
        
        // Map TTCN-3 ports to TestAdapter ports
        map(self:mtcPort, system:taPort);
        map(self:mtcAccessPort, system:taAccessPort);
          
        // Activate message filtering and timeouts altstep
        activate(a_defaults());
        // Activate UpperTester altstep
        activate(a_upperTester());
        
        f_addLogEntry("Initialisations performed. Test case starting.");

	} // End of function f_Backoffice_Preamble()
    
	function f_closeDownMtc() runs on MainTestComponent {
    	// Deactivate communication stack
        f_DeactivateCommunication();
            
        // Unmap TTCN-3 ports from TestAdapter ports
        unmap(self:iutPort, system:ta_pco);
        unmap(self:eaPort, system:ta_eaPort);
            
        // Activate message filtering and timeouts
        // See  
        deactivate(a_defaults());
        // Activate UpperTester
        deactivate(a_upperTester());
        f_addLogEntry("Everything deactivated. Test case ended");

    } // End of function f_Backoffice_Postamble()
        
	function f_addLogEntry(in charstring text){
		log("*** " & testcasename() & ":" & text);
	}

	function f_checkMinimumTime(in timer t_compare, in float v_timeMin) {	                      
        if (t_compare.read <= v_timeMin) {
        	setverdict(fail);
        	f_addLogEntry("minimum time not correct");
        	stop
    	};
	}  
    	
    // Function which inserts a waiting time - parameter t_wait - und waits in a "do-nothing-loop"
	function f_waitTime(in timer t_wait) {
		t_waitTimer.start(t_wait);
		while (t_waitTimer.running) {
			// empty loop = do nothing, but just wait
		}
	}
	
	// Function f_prepare_toReceive_InfoExchange to put ADUs together with APCIS and prepare InfoExchange to be received
	// It  concatenates multiple ADUs into a single stream and prepare APCI accordingly
	
	function f_createInfoExchangeForComparison(in Adus v_infoExchangeAdus) return InfoExchange {
		var InfoExchangeContent v_InfoexchangeContent;
		var InfoExchange v_InfoExchange;
		v_InfoexchangeContent.apci := m_apciFields{apduOriginator := ORIGINATOR, informationSenderID := SENDER, informationrecipientID := TESTER_ID};
		v_InfoexchangeContent.adus := v_infoExchangeAdus;
		v_InfoExchange.infoExchangeContent := v_infoExchangeContent;
		v_InfoExchange.infoExchangeAuthenticator := AnyOrOmit;
		f_addLogEntry("Expecting the following infoExchange");
 		f_addLogEntry(any2unistr(v_infoExchange)); 
		return v_Infoexchange;
	}

	function f_createInfoExchange(in ADUS v_InfoExchange_ADUS, in integer v_APDU_To_Answer) return InfoExchange {
		var InfoExchangeContent v_InfoexchangeContent;
		var InfoExchange v_InfoExchange;
		if (v_APDU_To_Answer != null) {
			v_InfoexchangeContent.apci := m_apciFields  { apduOriginator := TESTER_ID, informationSenderID := TESTER_ID, 
				informationrecipientID := ORIGINATOR
				};
			}
		else {
			v_InfoexchangeContent.apci := m_apciFields  { apduOriginator := TESTER_ID, informationSenderID := TESTER_ID, 
				informationrecipientID := ORIGINATOR, RelatedApduId.apduOriginator := ORIGINATOR,
				RelatedApduId.apduIdentifier := v_APDU_To_Answer
				};
			}
		v_InfoexchangeContent.apci.apduIdentifier := float2int(rnd()) * 65535;
		v_InfoexchangeContent.adus := v_InfoExchange_ADUS;
		v_InfoExchange.infoExchangeContent := v_InfoexchangeContent;
		return v_infoExchange;
		}
	

	// Function f_SendAPDU sends the APDU by using the given APDU in the given port and calculating the Authenticator, if requested
	function f_sendAPDU (in InfoExchangeContent v_infoExchangeContent) {
		var InfoExchange v_infoExchange;
		if (not (PICS_SECURED_MODE)) {
			v_infoExchange.infoExchangeAuthenticator := omit;  //PT140: check if omit or null or something else 
 			f_addLogEntry("Sending The following unauthenticated APDU to the IUT");
            	
			} else {
				v_infoExchange.infoExchangeAuthenticator := fx_computeAuthenticator(v_infoExchangeContent);
				f_addLogEntry("Sending The following authenticated APDU to the IUT");
				}
        v_infoExchange.infoExchangeContent := v_infoExchangeContent;
		f_addLogEntry(any2unistr(v_infoExchangeContent));  
        IutComp.send(v_infoExchange);
             	  
	}
	
	}
}
