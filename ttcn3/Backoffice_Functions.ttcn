/**
 * @author  PT0140 
 * @desc    This module provides the functions signature for:
 * - external functions
 * - communication support
 * - common Context Data support
 * @remark  These functions are used by preamble/postambule function to initialization/deinitialization communication stack
 * @see     Electronic fee collection (EFC) — Application interface definition for autonomous systems — Part 2: Communication and connections to the lower layers
 * @version $id$
 */
module Backoffice_Functions language "TTCN-3:2010 Advanced Parameterization" { 

    group External {
        /**
         * @desc    These function initializes the communication stack
         * @return  ERNoError on success, error code otherwise
         * @see     Clauses 7. EFC communication services (functions)
         * @see     Clauses 8. The use of a communication stack)
         */
        //external function fx_templateWeMightNeedSomethingLikeThis() return CommunicationErrorCodes ;
        
        group Security {        
            /**
             * @desc Initialise external security module
             * @return true on success, false  otherwise
             */
            external function fx_aGroupWithinAGroup_PerhapsWeNeedThis() return boolean;
        }  
    } 

	group Internal {
	  
	  var set of ADUs InfoExchange_ADUS;
	  var InfoExchange v_info_Exchange;
	  timer waitTimer;
	   
	  
	function f_LogNotExecuted(in charstring theTestcase){
		log("*** " & theTestcase & ": tescase not to be executed according to TP validity conditions and parameters in PICS ***");
		}
	  
	function f_checkMinimumTime(in timer t_compare, in float v_timeMin) {	                      
        if (t_compare.read <= v_timeMin) {setverdict(fail)};
    	}  
    	
    // Function which inserts a waiting time - parameter t_wait - und waits in a "do-nothing-loop"
	function f_waitTime(in timer t_wait) {
		t_waitTimer.start(t_wait);
		while (t_waitTimer.running) {
			// empty loop = do nothing, but just wait
			}
		}
	
	// Function f_prepareInfoExchange to be used in case of multiple ADUs InfoExchange
	// It  concatenates multiple ADUs into a single stream and prepare APCI accordingly
	function f_prepareInfoExchange(in InfoExchange_ADUS v_InfoExchange_ADUS, in boolean v_authenticate, out InfoExchange v_Infoexchange) {
	  
		}
	
	// Function f_receiveAPDUs receives APDU containing ADUs of the specified type and passes back 
	// the APCI part and the ADU's part in two variables
	function f_receiveAPDUs(in Adus, out ApciFields v_apci, out Adus v_adus) {
	  
		}

	// Function f_SendAPDU sends the APDU by using the given APDU in the given port and calculating the Authenticator, if requested
	function f_SendAPDU (in port t_port, in  template (value) InfoExchange t_APDU) {
		 if (not (PICS_SECURED_MODE)) {
                pco.send(m_InfoExchange_unsecured(t_APDU));
            } else {
                var template (value) AuthenticatedInfoExchange v_secured_packet;
                f_secured_packet(p_InfoExchange_Adu, v_secured_packet);
                pco.send(m_InfoExchange_secured(v_secured_packet));
            }	  
	}
	
	}
	}
} 