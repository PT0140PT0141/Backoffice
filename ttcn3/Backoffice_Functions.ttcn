/**
 * @author  PT0140 
 * @desc    This module provides the functions signature for:
 * - external functions
 * - communication support
 * - common Context Data support
 * @remark  These functions are used by preamble/postambule function to initialization/deinitialization communication stack
 * @see     Electronic fee collection (EFC) — Application interface definition for autonomous systems — Part 2: Communication and connections to the lower layers
 * @version $id$
 */
module Backoffice_Functions language "TTCN-3:2010 Advanced Parameterization" { 

    group External {
        /**
         * @desc    These function initializes the communication stack
         * @return  ERNoError on success, error code otherwise
         * @see     Clauses 7. EFC communication services (functions)
         * @see     Clauses 8. The use of a communication stack)
         */
       external function fx_computeAuthenticator(in InfoExchangeContent v_InfoExchange) return infoExchangeAuthenticator;
         
    } 

	group Internal {
	  
	  var set of ADUs InfoExchange_ADUS;
	  var InfoExchange v_info_Exchange;
	  timer waitTimer;

        /**
         * @desc        ADU filtering for received messages on IuTComp
         * @verdict     Unchanged on success, fail otherwise and the component is stopped if PX_ProcessUnexpectedADUAsError is set to true
         */
        altstep a_defaults() runs on IutPort {
            [] pco.receive -> value v_infoExchange {
                f_addLogEntry(any2unistr(v_infoExchangeContent));
                repeat; // Ignore unexpected ADUs, but log them
            }

            [] any timer.timeout {
                f_addLogEntry("Unexpected timeout occured");
                setverdict(inconc);
                stop;
            } // End of any timer.timeout
        } // End of altstep a_ADU_filter
 
 //PT140: need to check ports to be initialised
 //PT140: port names left as those from 17575 tests  
 	function f_Backoffice_Preamble() runs on IutPort {
            // Initialize communication stack
            f_InitializeCommunication();
            
            // Map TTCN-3 ports to TestAdapter ports
            map(self:pco, system:ta_pco);
            map(self:eaPort, system:ta_eaPort);
            
            // Activate message filtering and timeouts
            // See  
            activate(a_defaults());
            // Activate UpperTester
            activate(a_upperTester());

        } // End of function f_Backoffice_Preamble()
    

	function f_addLogEntry(in charstring text){
		log("*** " & testcasename() & ":" & text);
		}
	  
	function f_checkMinimumTime(in timer t_compare, in float v_timeMin) {	                      
        if (t_compare.read <= v_timeMin) {
        	setverdict(fail);
        	f_addLogEntry("minimum time not correct");
        	stop
        	};
    	}  
    	
    // Function which inserts a waiting time - parameter t_wait - und waits in a "do-nothing-loop"
	function f_waitTime(in timer t_wait) {
		t_waitTimer.start(t_wait);
		while (t_waitTimer.running) {
			// empty loop = do nothing, but just wait
			}
		}
	
	// Function f_prepare_toReceive_InfoExchange to put ADUs together with APCIS and prepare InfoExchange to be received
	// It  concatenates multiple ADUs into a single stream and prepare APCI accordingly
	
	function f_createInfoExchangeForComparison(in ADUS v_infoExchangeAdus) return infoExchange {
		var InfoExchangeContent v_infoExchangeContent;
		var InfoExchange v_infoExchange;
		v_infoExchangeContent.apci := m_apciFields  { apduOriginator := ORIGINATOR, informationSenderId := SENDER, 
			informationRecipientId := TESTER_ID,
			};
		v_infoExchangeContent.adus := v_infoExchangeAdus;
		v_infoExchange.infoExchangeContent := v_infoExchangeContent;
		v_InfoExchange.infoExchangeAuthenticator := AnyOrOmit;
		
		return v_infoExchange;
		}

	function f_createInfoExchange(in ADUS v_infoExchangeAdus, in integer v_apduToAnswer) return InfoExchange {
		var InfoExchangeContent v_infoExchangeContent;
		var InfoExchange v_infoExchange;
		if (v_apduToAnswer != null) {
			v_infoExchangeContent.apci := m_apciFields  { apduOriginator := TESTER_ID, informationSenderId := TESTER_ID, 
				informationRecipientId := ORIGINATOR
				};
			}
		else {
			v_infoExchangeContent.apci := m_apciFields  { apduOriginator := TESTER_ID, informationSenderID := TESTER_ID, 
				informationRecipientId := ORIGINATOR, RelatedApduId.apduOriginator := ORIGINATOR,
				RelatedApduId.apduIdentifier := v_apduToAnswer
				};
			}
		v_infoExchangeContent.apci.apduIdentifier := float2int(rnd()) * 65535;
		v_infoExchangeContent.adus := v_infoExchangeAdus;
		v_infoExchange.infoExchangeContent := v_infoExchangeContent;
		
		return v_infoExchange;
		}
	

	// Function f_SendAPDU sends the APDU by using the given APDU in the given port and calculating the Authenticator, if requested
	function f_sendAPDU (in InfoExchangeContent v_infoExchangeContent) {
		 var InfoExchange v_infoExchange;
		 if (not (PICS_SECURED_MODE)) {
                v_infoExchange.infoExchangeAuthenticator := omit;  //PT140: check if omit or null or something else 
            } else {
                v_infoExchange.infoExchangeAuthenticator := fx_computeAuthenticator(v_infoExchangeContent);
            }
          v_infoExchange.infoExchangeContent := v_infoExchangeContent;  
          IutComp.send(v_infoExchange);
             	  
	}
	
	}
}
