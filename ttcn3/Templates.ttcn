/**
 * @author  PT0140  
 * @desc    This module provides common templates for both Toll Charger and Toll Service Provider TCs. Most of these templates shall be used to modify the new ones.
 * @see     [17154-1:2017]: Test suite structure and test purpose
 * @see     Electronic fee collection — Evaluation of implementation for conformity to CEN/TS 16986 — Part 1: Test suite structure and purposes
 * @remark  See Annex C - Data structures
 * @version $id$
 */
module EfcInfoExchange_Templates language "TTCN-3:2010 Advanced Parameterization" {

	//importing other modules
	import from EfcInfoExchange_Pixits all;
//	import from EfcInfoExchange_Ics all;
	import from EfcInfoExchange_Functions all;
	import from EfcInfoExchange_TesterData all;
	
	//importing ASN.1 data automatically translated into TTCN-3	
	import from EfcInfoExchange language "ASN.1:1997" all;
	/**
     * @desc    [17575-1:2016], Charging
     * @see     Annex A (normative) EFC data type specifications
     */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    /**
     * @desc    [17575-3:2016], Context data
     * @see     A.2 Data specifications
     */
    import from EfcAutonomousContextData language "ASN.1:1997" all;
    /**
     * @desc    Electronic fee collection (EFC) — Application interface definition for autonomous systems — Part 4: Roaming
     * @see     Annex A (normative) EFC data type specifications
     */
    import from EfcDsrcApplication language "ASN.1:1997" all;
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     *          Common_Parametrised_Asn1_Data TTCN-3 module is a workaround
     */

	//importing ASN.1 data manually translated into TTCN-3
	import from EfcInfoExchange_ParameterisedAsn1Data all;  
    import from LibEfc_Common_Parameterised_Asn1_Data all;
	import from EfcInfoExchangeProfile all;
    
    group ApduTemplates {
        
        /**
         * @desc    Generic template for InfoExchange structure, without authentication     
         */
    	template InfoExchange m_apduNoSec(in template ApciFields p_apci, in template Adus p_adus):={
    	  infoExchangeContent:={
    	  	apci:=p_apci,
    	  	adus:=p_adus
    	  },
    	  infoExchangeAuthenticator := omit
    	}
    	
        
        /**
         * @desc    Generic template for InfoExchange structure, with authentication     
         */
    	template InfoExchange mw_apduSec(in template ApciFields p_apci, in template Adus p_adus):={
    	  infoExchangeContent:={
    	  	apci:=p_apci,
    	  	adus:=p_adus
    	  },
    	  infoExchangeAuthenticator := *
    	}
    
    	/**
         * @desc Generic template for ApciFields 
         */
    	template ApciFields mw_apci := { 
    		aidIdentifier := 1, // 12855 Protocol Version number 
    		apduOriginator := ?, // Source of the content of the APDU 
    		informationSenderID := ?, // Sender of this content 
    		informationrecipientID := ?,  
    		apduIdentifier := ?,
    		previousApduId := *,
    		nextApduId := omit,
    		inResponseToApduId := *, 
    		apduDate :=  ?
    	}
    	
    	/**
         * @desc Template for ApciFields sent by the Tester     
         */
    	template ApciFields mw_apciSend modifies mw_apci:= {			
    		apduOriginator := APDU_ORIGINATOR_FOR_TESTER,  
    		informationSenderID := INFORMATION_SENDER_ID_FOR_TESTER, 
    		informationrecipientID := INFORMATION_SENDER_ID_FOR_IUT,
    		previousApduId:=omit,
    		//apduIdentifier shall be a unique identifier for each given apduOriginator that is assigned by the apduOriginator. 
    		//It is used to either acknowledge or request retransmission of a previously issued APDU.
    		apduIdentifier := float2int(rnd()) * 65535
    	}
    	  	

    	/**
    	 * 
		* @desc Template for ApciFields for APDUs sent by the Tester as a response     
		*/
	   template (value) ApciFields m_apciSendResponse(in InfoExchange p_apduBeingRespondedTo) modifies mw_apciSend:= {			
			inResponseToApduId := {
				apduOriginator:=p_apduBeingRespondedTo.infoExchangeContent.apci.apduOriginator,
				apduIdentifier:=p_apduBeingRespondedTo.infoExchangeContent.apci.apduIdentifier
			},
			// TODO PT140: Check whether the function is evaluated at run time. If not, time  has to be set within the test case
		   	apduDate:=fx_getUtc()
	   }
    	
    	/**
    	 * 
         * @desc Template for ApciFields for initiating APDUs sent by the Tester     
         */
    	template (value) ApciFields m_apciSendFirst modifies mw_apciSend:= {			
    		inResponseToApduId := omit,
    		apduDate:=fx_getUtc()
    	}
    	
    	/**
    	 * 
    	 * @desc Corresponds to the event Initiating_Apdu desribed in test purposes.
    	 * @desc Definition: "An APDU with the APCI-fields set to informationRecipientId = Tester identifier and apduDate = valid date, 
    	 * @desc optional fields on all levels not present" 
    	 */ 
    	template (value) InfoExchange m_apduNoSecInit(in Adus p_adus) := m_apduNoSec(
     		m_apciSendFirst, 
     		p_adus
     	);

    	template (value) InfoExchange m_apduSecInit(in Adus p_adus):={
    	  infoExchangeContent:={
    	  	apci:=m_apciSendFirst,
    	  	adus:=p_adus
    	  },
    	  infoExchangeAuthenticator := fx_computeAuthenticator({apci:=m_apciSendFirst,adus:=p_adus})
    	}


    	/**
    	 * 
    	 * @desc Corresponds to the event Default_Apdu described in test purposes.
		 * @desc Definition: "An APDU with the APCI-fields set to informationRecipientId = Tester identifier, 
		 * @desc inResponseToApduId = the apduId of the APDU carrying the ADU that is being responded to and 
		 * @desc apduDate = valid date, other optional fields on all levels not present" 
    	 */ 
		template (value) InfoExchange m_apduDefault(in InfoExchange p_apduToRespondTo, in Adus p_adus) := m_apduNoSec(
			m_apciSendResponse(p_apduToRespondTo), 
			p_adus
	    );

		template InfoExchange mw_apduRequest := m_apduNoSec(mw_apci, Adus:{requestAdus:=?});
			
		template InfoExchange mw_apduAuthRequest := mw_apduSec(mw_apci, Adus:{requestAdus:=?});


		template (value) Adus m_oneAckInAdusStruct(in AckADU p_ackADU):={ackAdus:={p_ackADU}};
		
		/**
		 * 
		 * @desc Corresponds to the event Default_Ack_Apdu described in test purposes.
		 * @desc Definition: "Default_Apdu containing one AckADU containing {apduAckCode =: apduOK(2)}, with issues being not present" 
		 */ 
		template (value) InfoExchange m_apduDefaultAck(in InfoExchange p_apduToAck) := m_apduDefault(
			p_apduToAck, 
			m_oneAckInAdusStruct(m_aduDefaultAck(p_apduToAck))
		);

		/**
		 * 
		 * @desc Corresponds to the event NAck_Apdu described in test purposes.
    	 * @desc Definition: "NAck_Apdu(zero or more sets of Param defined as {aduPosition, aduReasonCode}) 
    	 * @desc "Default_Apdu containing one AckADU containing {apduAckCode= apduOK(2), issues containing one 
    	 * @desc element for each Param set containing {issueADUStruct=aduPosition, issueCode = aduReasonCode }}"
    	 * @desc NOTE	the NAck_Apdu definition assumes that there are some valid ADUs in the APDU it is 
    	 * @desc responding to (otherwise an apduAckCode  = apduNotOK(3) might have been a feasible answer)
		 */ 
		template (value) InfoExchange m_apduNAck(in InfoExchange p_apduToAck, in NAckParams p_nAckParams) := m_apduDefault(
			p_apduToAck, 
			m_oneAckInAdusStruct(m_aduNAck(p_apduToAck, p_nAckParams))
	    );

		type record of record {
			NumberOfADUStruct issueADUStruct,
			ASNAUX.UTF8String issueLocation length (0 .. 512) optional,
			ASNAUX.UTF8String issueContent length (0 .. 1024) optional,
			AduReasonCode issueCode,
			ASNAUX.UTF8String issueText length (0 .. 1024) optional
	  	}  NAckParams;
	  	
		/**
		 * 
		 * @desc Construct with one issueCode value, to be used when creating customised m_apduNAck)
		 */ 		
	 	template (value) NAckParams m_nAckParamsSingle(
			in NumberOfADUStruct p_issueADUStruct, 
			in AduReasonCode p_issueCode
		):={
			{
				issueADUStruct:=p_issueADUStruct,
				issueLocation := omit,
				issueContent := omit,
				issueCode := p_issueCode,
				issueText:= omit
			}
		};
	  	

		template AckADU m_aduNAck(in InfoExchange p_apduToAck, in NAckParams p_nAckParams) := {
			apduIdentifier := p_apduToAck.infoExchangeContent.apci.apduIdentifier,
			explicitlyAckedAdus := omit,
			apduAckCode := ApduReasonCode_apduNotOK_ ,
			apduAckText := omit,
			issues := p_nAckParams
		}
    	
			
		/**
		 * 
		 * @desc Corresponds to the event NAck_requestSentTooOften described in test purposes.
		 * @desc Definition: "Default_Apdu containing one AckADU containing {apduAckCode= requestSentTooOften(10)}" 
		 */ 
		template (value) InfoExchange m_apduNAckRequestSentTooOften(in InfoExchange p_apduToAck) := m_apduDefault(
			p_apduToAck,
			m_oneAckInAdusStruct(m_aduAckRequestSentTooOften(p_apduToAck))			
		);

		template AckADU m_aduAckRequestSentTooOften(in InfoExchange p_apduToAck) := {
			apduIdentifier := p_apduToAck.infoExchangeContent.apci.apduIdentifier,
			explicitlyAckedAdus := omit,
			apduAckCode := ApduReasonCode_requestSentTooOften_ ,
			apduAckText := omit,
			issues := omit
		}
      
		template AckADU mw_aduDefaultAck := {
			apduIdentifier := ?,
			explicitlyAckedAdus := omit,
			apduAckCode := ?,
			apduAckText := omit,
			issues := *
		}

		template AckADU m_aduDefaultAck(in InfoExchange p_apduToAck) := {
			apduIdentifier := p_apduToAck.infoExchangeContent.apci.apduIdentifier,
			explicitlyAckedAdus := omit,
			apduAckCode := ApduReasonCode_apduOK_ ,
			apduAckText := omit,
			issues := omit
		}

    }
    
	group AduTemplates{
		
		group USERDETAILS {
	
			type record of UserParameterRequest UserParameterRequests;

    		template RequestADU mw_aduRequestProvideUserDetails := {
        		userDetailsRequest :={	
            	  	requestedADUType                := AduType_provideUserDetailsADU_,
            	  	userId                          := ?,
            		listOfParametersRequested       := ?,
            		userDetailsRequestReason        := *,
            		userInfoValidityPeriod          := *
        		}
        	}
        	
        	template (value) RequestADU m_aduRequestProvideUserDetails(
        		in UserParameterRequests p_userParameterRequests
        	) modifies mw_aduRequestProvideUserDetails := {
        		userDetailsRequest:={
        			requestedADUType := AduType_provideUserDetailsADU_,	
            	  	userId := EXISTING_USER_ID,
					listOfParametersRequested := p_userParameterRequests,
            		userDetailsRequestReason := omit,
            		userInfoValidityPeriod := omit
        		}
        	}
        	       			
//        	template ProvideUserDetailsADU mw_userDetailsPrivacy_apduIdentifier := {
//                originaluserIdRequest := DEFINED_USERID,
//                userId := *,
//                statusFlag := * ,
//                listOfUserParameters.UserParameterResponse := omit,
//                listOfUserParameters.userParameterResponse := *,
//                listOfUserParameters.userParameterStatus := 2,
//                listOfUserParameters.userInfoValidityPeriod := omit
//        	}
        	
        	template ProvideUserDetailsADU mw_aduProvideUserDetails := {
            	originaluserIdRequest := EXISTING_USER_ID,
            	userId := ?, 
            	statusFlag := * ,
            	listOfUserParameters := *
        	}
        	
   			template InfoExchange mw_apduProvideUserDetails(InfoExchange p_apduRespondedTo) := m_apduNoSec(m_apciSendResponse(p_apduRespondedTo), Adus:{provideUserDetailsADUs:=?});
			
			template InfoExchange mw_apduAuthProvideUserDetails := mw_apduSec(mw_apci, Adus:{provideUserDetailsADUs:=?});
		}

		group LISTOFUSERS {
		  	
		  	template RequestADU mw_aduRequestListOfUsers := {
		  		userListRequest :={
		  			requestedADUType	:= AduType_provideUserIdListADU_,
      				userIdRequestType	:= ?,
      				userId				:= ?,
					userIdRequestTime	:= ?
				}
			}
		  	
		  	template (value) RequestADU m_aduRequestListOfUsers := {
	  			userListRequest :={
	  				requestedADUType	:= AduType_provideUserIdListADU_,
  					userIdRequestType	:= 0,
  					userId				:= EXISTING_USER_ID,
					userIdRequestTime	:= fx_getUtc() 
				}
			}

			template ProvideUserIdListADU mw_aduProvideUserIdList := {
				originalUserIdRequestType := UserIdRequestType_allUserIdsToGivenCustomer_,
				originalUserId := EXISTING_USER_ID,
            	userIdList := *
        	}

   			template InfoExchange mw_apduProvideUserIdList := m_apduNoSec(mw_apci, Adus:{provideUserIdListADUs:=?});
			
			template InfoExchange mw_apduAuthProvideUserIdList := mw_apduSec(mw_apci, Adus:{provideUserIdListADUs:=?});
			
		}

		group EXCEPTIONLIST {
		  	template ExceptionListADU mw_aduExceptionList := {
		  	  	exceptionListVersion := ?,
				exceptionListType := (ExceptionListType_blackList_, ExceptionListType_whiteList_, ExceptionListType_discountedList_),
		  	  	exceptionValidityStart := ?,
		  	  	exceptionValidityEnd := omit,
		  	  	exceptionListEntries := ?
		  	}

			template ExceptionListADU mw_aduExceptionListBlack modifies mw_aduExceptionList := {
				exceptionListType := ExceptionListType_blackList_
			}		  	

			template ExceptionListADU mw_aduExceptionListWhite modifies mw_aduExceptionList := {
				exceptionListType := ExceptionListType_whiteList_
			}		  	

			template ExceptionListADU mw_aduExceptionListDiscounted modifies mw_aduExceptionList := {
				exceptionListType := ExceptionListType_discountedList_
			}		  	
			
// Not needed currently
//		  	template ExceptionListEntry mw_exceptionListEntry := {
//		  	  	userId := ?,
//		  	  	statusType := ?,
//		  	  	reasonCode := ?,
//		  	  	entryValidityStart := ?,
//		  	  	entryValidityEnd := omit,
//		  	  	vehicleParameters := *,
//		  	  	actionRequested := ?,
//		  	  	efcContextMark := omit,
//		  	  	vatId := *
//		  	}

			template Adus mw_recordOfOneAduExceptionListBlack := {
				exceptionListADUs:={mw_aduExceptionListBlack}
			}
			
			template Adus mw_recordOfOneAduExceptionListWhite := {
				exceptionListADUs:={mw_aduExceptionListWhite} 
			}
			
			template Adus mw_recordOfOneAduExceptionListDiscounted := {
				exceptionListADUs:={mw_aduExceptionListDiscounted} 
			}
			
			
   			template InfoExchange mw_apduExceptionList := m_apduNoSec(mw_apci, Adus:{exceptionListADUs:=?});
			
			template InfoExchange mw_apduAuthExceptionList := mw_apduSec(mw_apci, Adus:{exceptionListADUs:=?});

			template InfoExchange mw_apduExceptionListOneBlackList := m_apduNoSec(mw_apci, mw_recordOfOneAduExceptionListBlack);

			template InfoExchange mw_apduExceptionListOneWhiteList := m_apduNoSec(mw_apci, mw_recordOfOneAduExceptionListWhite);

			template InfoExchange mw_apduExceptionListOneDiscountedList := m_apduNoSec(mw_apci, mw_recordOfOneAduExceptionListDiscounted);


//			template InfoExchange mw_apduExceptionListOneBlackList modifies mw_apduExceptionList := {
//				infoExchangeContent.adus.exceptionListADUs := {
//					modifies mw_aduExceptionList:= {
//						exceptionListType := ExceptionListType_blackList_ 
//					}
//				}
//			}
//			
//			template InfoExchange mw_apduExceptionListOneWhiteList modifies mw_apduExceptionList := {
//				infoExchangeContent.adus.exceptionListADUs := {modifies mw_aduExceptionList:= {exceptionListType := ExceptionListType_whiteList_ }}
//			}
//			
//
		}
		

		group PAYMENTCLAIM {

   			template InfoExchange mw_apduPaymentClaim := m_apduNoSec(mw_apci, Adus:{paymentClaimADUs:=?});
			
			template InfoExchange mw_apduAuthPaymentClaim := mw_apduSec(mw_apci, Adus:{paymentClaimADUs:=?});
			
		
		}

		group DSRC_CONTRACTISSUERLIST {		
			template ContractIssuerListADU mw_aduContractIssuerList := {
				efcContextMark := ?,
				equipmentClass := ?,
				manufacturerID := ?,
				uniquePartOfPAN := ?,
				typeOfEFCApplication := ?,
				securityLevel := ?,
				acCrKeyReference := ?,
				authKeyRererence := ?,
				validFrom := ?
			} 		
		
			template Adus mw_recordOfAduContractIssuerList := {
				contractIssuerListADUs := ?
			}

   			template InfoExchange mw_apduContractIssuerList := m_apduNoSec(mw_apci, Adus:{contractIssuerListADUs:=?});
			
			template InfoExchange mw_apduAuthContractIssuerList := mw_apduSec(mw_apci, Adus:{contractIssuerListADUs:=?});


		}

		group DSRC_EFCCONTEXTDATA {						
			template EfcContextDataADU mw_aduDsrcEfcContextData := {
				entityOverview := *,
				domainType:={
					dsrcContext:= {
						regimeContextData := {
								iso175753ADU := ?,
								feeModifiers := omit
						}
					}					
				}
			}
	
			type record DsrcClosedContext {
				ClosedContextDefinition closedContext,
				FeeModifiers feeModifiers optional
			}
			
			template DsrcClosedContext mw_dsrcClosedContext :={
				closedContext := ?,
				feeModifiers := omit
			}

			template EfcContextDataADU mw_aduDsrcClosedContextEfcContextData := {
				entityOverview := omit,
				domainType:={
					dsrcClosedContext := mw_dsrcClosedContext
				}
			}
			
			type record of LocalVehicleClassId RecOfLocalVehicleClassId; 
			type record of TimeClassId RecOfTimeClassId; 
			type record of UserClassId RecOfUserClassId; 
			
			template (value) EfcContextDataADU m_aduEfcContextDataDsrcClosedContext(
				RecOfLocalVehicleClassId p_ROfLocVehClassId,
				template LocalVehicleClassDefinition p_localVehicleClassDefinition, 
				template RecOfTimeClassId p_ROfTimeClassId, 
				template TimeClassDefinition p_timeClassDefinition, 
				template RecOfUserClassId p_ROfUserClassId,
				template UserClassDefinition p_userClassDefinition, 
				template FeeDefinition p_feeDefinition
			) := {
				entityOverview := omit,
				domainType:={
					dsrcClosedContext := {
						closedContext:={
							closedContextType:=ClosedContextType_standAloneClosedSysytem_, 
							closedSystem:={
								tollContextOverview:=omit,
								tariffClassDefinition:={
									tariffClasses:={
										{
											tariffClassId:=0,
											localVehicleClasses:=p_ROfLocVehClassId,
											timeClasses:=p_ROfTimeClassId,
											locationClasses:=omit,
											userClasses:=p_ROfUserClassId
										}
									},
									tariffClassDefinitionVersion:=m_basicVersionValidFromNow
								},
								localVehicleClassDefinition:= p_localVehicleClassDefinition,
								timeClassDefinition:=omit,
								userClassDefinition:=omit,
								feeDefinition:=p_feeDefinition
							}
						}
					}
				}
			};	
			
			template (value) VersionAndValidity m_basicVersionValidFromNow :={
				version:={
					basicVersionId:=basicVersionIdTESTER_VALUE
				},
				validFrom:=fx_getUtc()
			}			
			
			template (value) EfcContextDataADU m_aduEfcContextDataDsrcClosedContextTariffClassDefinition := 
				m_aduEfcContextDataDsrcClosedContext({},omit,omit,omit,omit,omit,omit);
			template (value) EfcContextDataADU m_aduEfcContextDataDsrcClosedContextLocVehClass := 
				m_aduEfcContextDataDsrcClosedContext({1,2,3},m_localVehicleClassDefinition,omit,omit,omit,omit,omit);
			template (value) EfcContextDataADU m_aduEfcContextDataDsrcClosedContextTimeClass := 
				m_aduEfcContextDataDsrcClosedContext({},omit,{1,2,3},m_timeClassDefinition,omit,omit,omit);
			template (value) EfcContextDataADU m_aduEfcContextDataDsrcClosedContextUserClass := 
				m_aduEfcContextDataDsrcClosedContext({},omit,omit,omit,{1,2,3},m_userClassDefinition,omit);
			template (value) EfcContextDataADU m_aduEfcContextDataDsrcClosedContextFeeDefinition := 
				m_aduEfcContextDataDsrcClosedContext({},omit, omit,omit,omit,omit, m_feeDefinition);
			
			template (value) FeeDefinition m_feeDefinition:={
				actualPath:={
					tariffTable:=m_tariffTable,
					closedContextLayout:=m_closedContextLayout
				}
			}

			template (value) TariffTable m_tariffTable:={
				applicablePartitions := {1,2,3}, // Three partitions
				tariffs:={m_tariff(1,1),m_tariff(2,2)},
				standardCurrency := '2978'O, // Units in cents, currency Euro,
				typeOfFee := omit,
				tariffTableVersion := m_basicVersionValidFromNow
			}
			
			template (value) Tariff m_tariff(
				in TariffClassId p_tariffClass,
				in EfcAutonomousContextData.Int1 p_chargeUnitEvent
			):={
				tariffClass := p_tariffClass,
				chargeUnit:={
					event := p_chargeUnitEvent
				},
				roundingRuleForChargeUnitsUsed := RoundingRule_up_,
				basicFeePerChargeUnit := 5, // Units in cents, currency Euro
				roundingRuleForFee := RoundingRule_up_,
				vat:=omit,
				roundingRuleForVat := omit,
				intervalScaleParameters := omit,
				offsetFee := omit,
				minFee := omit,
				thresholdFee := omit,
				maxFee := omit,
				alternativeCurrency := omit
			}		
			
			template (value) ClosedContextLayout m_closedContextLayout:={
				tollOperators:=omit,
				dsrcChargeObjects:={
					m_dsrcChargeObject(1,"Charge object test description 1"),
					m_dsrcChargeObject(2,"Charge object test description 2")
				},
				internalPoints:=omit, 
				interconnectionPoints:=omit,
				closedSections:=omit,
				tollContextLayoutVersion:=m_basicVersionValidFromNow,
				tollContextAuthenticator:=omit
			}

			template (value) DSRCChargeObject m_dsrcChargeObject(
				in EfcInfoExchange.Int4 p_chargeObjectDesignation,
				in UTF8String p_chargeObjectDescription
			):={
				chargeObjectId := {
					chargeReportFinalRecipient:=omit,
					chargeObjectDesignation:=p_chargeObjectDesignation
				},
				chargeObjectDescription :=p_chargeObjectDescription,
				chargeObjectType:=ChargeObjectType_entryAndExit_,
				tollContext:=TESTER_IDENTIFIER,
				chargeObjectValidityStart:=omit,
				chargeObjectValidityEnd:=omit					 						 	
			} 
			

   			template InfoExchange mw_apduEfcContextData := m_apduNoSec(mw_apci, Adus:{efcContextDataADUs:=?});
			
			template InfoExchange mw_apduAuthEfcContextData := mw_apduSec(mw_apci, Adus:{efcContextDataADUs:=?});

			template (value) LocalVehicleClassDefinition m_localVehicleClassDefinition:={
				localVehicleClasses := {
					{
						localVehicleClassId := 1,
	    				nominalElements := {
	    					vehicleClasses := {1,2,3},
	    					vehicleTrainAxlesNumbers := omit,
	    					euroValues:=omit,
	    					copValues:=omit
	    				},
	    				ordinalElements := omit,
	    				priorityValue := omit
					}
				},
    			localVehicleClassVersion := omit			  
			}
		
			template (value) TimeClassDefinition m_timeClassDefinition:= 	{
				    timeClasses := {
				    	{
							timeClassId := 1,
							nominalElements := omit,
							ordinalElements := omit,
							priorityValue := omit
				    	}
				    },
					timeClassDefinitionVersion := omit
			}
			
			template (value) UserClassDefinition m_userClassDefinition:= 	{
				userClasses := {
					{
						userClassId := 1,
						contractTypes := omit,
						actualNumberOfPassengers := omit,
						priorityValue:=omit
					},
				    {
				    	userClassId := 2,
						contractTypes := omit,
						actualNumberOfPassengers := omit,
						priorityValue:= omit
					}				    	
				},
				userClassDefinitionVersion:=omit
			}
		}	
		group TRUSTOBJECTS {
			
			type record of TrustObjectPurposes RecOfTrustObjectPurposes; 	

			//note that an APDU containing TrustObjects is only allowed to carry ONE TrustObjectADU
			template (value) InfoExchange m_apduTrustObjectResponse(
				in InfoExchange p_apduBeingRespondedTo, 
				in RecOfTrustObjectPurposes p_recOfTrustObjectPurposes,
				in TrustObjectCode p_trustObjectCode			
			) := m_apduNoSec(
				m_apciSendResponse(p_apduBeingRespondedTo),
				Adus: {
					trustObjectAdus:={
						m_aduTrustObject(
							p_recOfTrustObjectPurposes,
							p_trustObjectCode
						)
					}
				}
			);
			
			template TrustObjectADU mw_aduTrustObject(
				template RecOfTrustObjectPurposes p_recOfTrustObjectPurposes,
				template TrustObjectCode p_trustObjectCode
			):={
				trustObjectID := float2int(rnd()),
				purposesOfTrustObject := p_recOfTrustObjectPurposes,
				startValidity := fx_getUtc(),
				endValidity := omit,
				trustObjectStatus := TrustObjectStatus_valid_,
				trustObject := p_trustObjectCode
			}

			template (value) TrustObjectADU m_aduTrustObject(RecOfTrustObjectPurposes p_recOfTrustObjectPurposes,
				TrustObjectCode p_trustObjectCode
			):=mw_aduTrustObject(p_recOfTrustObjectPurposes,p_trustObjectCode);
			
			template TrustObjectADU m_aduTrustObjectInvalidStatus:= {
				trustObjectID := float2int(rnd()),
				purposesOfTrustObject := {TrustObjectPurposes_dSRCCharging_,TrustObjectPurposes_dSRCAC_,TrustObjectPurposes_oBEInterrogation_,TrustObjectPurposes_oBEInterrogationAC_},
				startValidity := fx_getUtc(),
				endValidity := omit,
				trustObjectStatus := 5,
				trustObject := {dsrcKeyRef:=dsrcKeyRefObjectTESTER_VALUE}
			}
			
			
   			// General template to receive Trust Objects
   			template InfoExchange mw_apduTrustObject := m_apduNoSec(mw_apci, Adus:{trustObjectAdus:=?});
   			
			// General template to receive Trust Objects on a secure connection
			template InfoExchange mw_apduAuthTrustObject := mw_apduSec(mw_apci, Adus:{trustObjectAdus:=?});

			//template for building templates
			template InfoExchange mw_apduTrustObjectProtoTemp(template TrustObjectCode p_trustObjectCode) := m_apduNoSec(
   				mw_apci, 
   				Adus:{trustObjectAdus:={mw_aduTrustObject(?,p_trustObjectCode)}
   				}
   			);
			
			// Template for a generic object. According to the profile, only certificate revocation lists can be sent as generic trust objects
   			template InfoExchange mw_apduTrustObjectGeneric := mw_apduTrustObjectProtoTemp(mw_genericTrustObject);

			template TrustObjectCode mw_genericTrustObject:={
				otherTrustObject:={
					typeOfTrustObject := TrustObjectTypes_crl_,
					genericTrustObject := ?
				}
			}


			// Template for a certificate object
   			template InfoExchange mw_apduTrustObjectCertificate:=mw_apduTrustObjectProtoTemp(TrustObjectCode:{certificate:=?});
			
			// Template for a public key object
   			template InfoExchange mw_apduTrustObjectPublicKey := mw_apduTrustObjectProtoTemp(TrustObjectCode:{publicKey:=?});
			
			// Template for a Dsrc key object
   			template InfoExchange mw_apduTrustObjectDsrcKey := mw_apduTrustObjectProtoTemp(TrustObjectCode:{dsrcMasterKeys:=?});

			// Template for a Mac Key object
   			template InfoExchange mw_apduTrustObjectMacKey := mw_apduTrustObjectProtoTemp(TrustObjectCode:{macMasterKey:=?});

			// Template for a Dsrc keyRef object
   			template InfoExchange mw_apduTrustObjectDsrcKeyRef:=mw_apduTrustObjectProtoTemp(TrustObjectCode:{dsrcKeyRef:=?});

			// PT140 TODO to be defined Generic Request for Trust Object with one parameter as apduToBeRespondedTo, and another as TrustObjectCode - Ulrik: still needed? not used anywhere... 
			template InfoExchange m_apduRequestTrustObject := ();
						
			// Generic received Request for Trust Object, to receive a requestADU for any Trust Object 			
			template InfoExchange mw_apduRequestTrustObject := m_apduNoSec(
				mw_apci, 
				Adus:{requestAdus:={
					requestedADUType := 3,
					requestedTrustObject := ?
				}}
			);
			
			
			// Received Request for a Certificate Trust Object
			template InfoExchange mw_apduRequestTrustObjectCertificate := m_apduNoSec(
				mw_apci, 
				Adus:{
					requestAdus:={
						requestedADUType := 3,
						requestedTrustObject:={
							trustObjectSpec :={
								typeOfTrustObject := TrustObjectTypes_certificate_,
								purposesOfTrustObject := *
							}
						}
					}
				}
			);
			
			// Received Request for a Public Key Trust Object			
			template InfoExchange mw_apduRequestTrustObjectPublicKey := m_apduNoSec(
				mw_apci, 
				Adus:{
					requestAdus:={{mw_aduRequestTrustObjectPublicKey}}
				}
			);

			template RequestADU mw_aduRequestTrustObjectPublicKey:={
				trustObjectRequest:={
					requestedADUType := 3,
					requestedTrustObject:={
						trustObjectId:=?,
						trustObjectSpec:={
							typeOfTrustObject:= TrustObjectTypes_publicKey_,
							purposesOfTrustObject := *
						}
					}
				}
			}

			// Received Generic Trust Object is requested though a requestADU carrying only the type of ADU requested			
			template InfoExchange mw_apduRequestTrustObjectGeneric := m_apduNoSec(mw_apci, Adus:{requestAdus:= {
			  requestedADUType := 3,
			  requestedTrustObject:={trustObjectSpec := omit}
			}});
			
			// Received Request for a Symmetric Key Trust Object
			template InfoExchange m_apduTrustObjectSymmetricKey := m_apduNoSec(
				mw_apci, 
				Adus:{
					requestAdus:={
						{
							requestedADUType := 3,
							requestedTrustObject:={
								trustObjectSpec:={
									typeOfTrustObject:=(TrustObjectTypes_symmetricKey_, TrustObjectTypes_encryptedSymmetricKey_),
								    purposesOfTrustObject := *
								}
							}
						}
					}
				}
			);
			
		}

		group DSRC_REPORTABNORMALOBE {
			template ReportAbnormalOBEADU mw_adusDsrcReportAbnormalObe := {
				userId := ? , //TODO Jan check that at least one element of userId is present (use sizeof>0), this needs to be done in the test cases
				dateAndTime := ?,
				efcContextMark := ?,
				abnormalOBEReasonCode := ? length (1..255) //= at least one reason code shall be present in this record of integer
			}

   			template InfoExchange mw_apduReportAbnormalOBE := m_apduNoSec(mw_apci, Adus:{reportAbnormalOBEADUs:=?});
			
			template InfoExchange mw_apduAuthReportAbnormalOBE := mw_apduSec(mw_apci, Adus:{reportAbnormalOBEADUs:=?});

		}
		
		
		group BILLINGDETAILS{

			template InfoExchange mw_apduBillingDetails := m_apduNoSec(mw_apci, Adus:{billingDetailsADUs:=?});
			
			template InfoExchange mw_apduAuthBillingDetails := mw_apduSec(mw_apci, Adus:{billingDetailsADUs:=?});
		}
		
		group DSRC_BILLINGDETAILS{
		}
		
		group GNSS_TOLLDECLARATIONS {
   			template InfoExchange mw_apduTollDeclaration := m_apduNoSec(mw_apci, Adus:{tollDeclarationADUs:=?});
			
			template InfoExchange mw_apduAuthTollDeclaration := mw_apduSec(mw_apci, Adus:{tollDeclarationADUs:=?});

			template (value) TollDeclarationADU m_aduTollDeclaration(in integer p_declarationId, in EfcAutonomousContextData.Int4 p_chargeReportCounter):={
				tollDeclarationId:={
					issuerId:=TESTER_IDENTIFIER,
					declarationId:=p_declarationId
				},
				gnssTollDeclaration:={
					{
						chargeReport:={
							protocolVersion:=AidIdentifier_iso17575_1_2016_,
							obeId:={
								manufacturerId:=1,		//TODO Jan Check correct values of this number, does it need to be in a modulepar?
								equipmentObuId:='01'O	//TODO Jan Check correct values of this number, does it need to be in a modulepar?
							},
							vehicleLPNr:={
								countryCode:='0000000001'B,//TODO Jan Check correct values of this number, does it need to be in a modulepar?
								alphabetIndicator:=latinAlphabetNo1,//TODO Jan Check correct values of this number, does it need to be in a modulepar?
								licencePlateNumber:='001122001122'O //TODO Jan Check correct values of this number, does it need to be in a modulepar?
							},
							paymentMeans:={
								personalAccountNumber:='00000000000000000001'O,//TODO Jan Check correct values of this number, does it need to be in a modulepar?
								paymentMeansExpiryDate:={
									year:=2100,
									month:=1,
									day:=1
								},  
								pamentMeansUsageControl:='0001'O //TODO Jan Check correct values of this number, does it need to be in a modulepar?
							},
							tollContext:=TESTER_IDENTIFIER,//TODO Jan Check correct values of this number,
							serviceProviderContract:={
								contractProvider:=TESTER_IDENTIFIER,//TODO Jan Check correct values of this number
								typeOfContract:='0001'O, //TODO Jan Check what is a valid value for typeOfContract
								contextVersion:=1
							},
							usageStatementList:={
								{
									usageStatement:={
										usageStatementId:=1,
										tollContext:= TESTER_IDENTIFIER//TODO Jan Check correct values of this number, shall be identical to attribute tollContext of Chargereport
										//TODO Jan need to figure which way to use charge objects to use here below. I think one needs to be chosen
										//TODO Jan WARNING there are several PARAMS that needs to be taken into account here GNSS.TOLLDECLARATION.PARAM1-2-3-4-5_MAX
										//	        AggregatedSingleTariffClassSession  aggregatedSingleTariffClassSession optional,
										//	        set of DetectedChargeObject         listOfChargeObjects optional,
										//	        ListOfRawUsageData                  listOfRawUsageData optional,
									}
								}
							},
							chargeReportCounter:=p_chargeReportCounter
						}
					}
				},
				actionCode:=omit
			}

// different approach which may hopefully supprt re-useability and flexibility
// @Ulrik: please have a look into this one
// Below this shall be a generic template which can be used as base for sending and receiving TollDeclaration ADUs

			template TollDeclarationADU mw_aduTollDeclaration := {
				tollDeclarationId := ?, // shall be present 
				gnssTollDeclaration := {
					{
						chargeReport := {
							protocolVersion:= AidIdentifier_iso17575_1_2016_,
							obeId := ?, // mandatory in ISO 16986
							vehicleLPNr := ?, // mandatory in ISO 16986
							paymentMeans := ?, // mandatory in IS 16896
							serviceProviderContract := ?, // mandatory in ISO 12855
							tollContext:= ?, // can be Tester or IUT Id
							chargeReportFinalRecipient := omit, // shall not be used in ISO 16986 
							timeOfReport := omit, // shall not be used
							reportPeriod := *, // may or may not be present
							versionId := *, // may or may not be present
							usageStatementList := ?, // shall be present in ISO 16986 
							sumVatForThisSession := omit, // shall not be used in ISO 16986 
							accountStatus := omit, // shall not be used in ISO 16986
							chargeReportCounter := ?, // mandatory in ISO 16986
							mileage := omit, // shall not be used in ISO 16986
							listOfCccAttributes := omit // shall not be used in IS 16986
						}
					}
				},
				actionCode:= (ActionCode_send_, ActionCode_revoke_ ,ActionCode_adjust_ )
			}

			// this is a template which can be used be the tester
			// omitted fields accdoring to ISO16986 rules are not present
			// parameters allow the tester to modify data per invividual TollDeclaration ADU
			// can be used for valid and invalid Toll Declarations 

			template (value) TollDeclarationADU m_aduTollDeclarationToSend (
				in TollDeclarationId p_tollDeclarationId,
				in ObeId p_obeId,
				in VehicleLicencePlateNumber p_vehicleLPNr,
				in PaymentMeans p_paymentMeans,
				in EFC_ContextMark p_serviceProviderContract,
				in Provider p_tollContext,
				in UsageStatement p_usageStatement,
				in EfcAutonomousContextData.Int4 p_chargeReportCounter,
				in ActionCode p_actionCode) 
			modifies mw_aduTollDeclaration:={
				tollDeclarationId := p_tollDeclarationId, // shall be present 
				gnssTollDeclaration := {
					{
						chargeReport := {
							protocolVersion := AidIdentifier_iso17575_1_2016_,
							obeId := p_obeId, // mandatory in ISO 16986
							vehicleLPNr := p_vehicleLPNr, // mandatory in ISO 16986
							paymentMeans := p_paymentMeans, // mandatory in IS 16896
							serviceProviderContract := p_serviceProviderContract, // mandatory in ISO 12855
							tollContext:= p_tollContext, // shall be Tester
							reportPeriod := omit, // Tester decides this shall not be present
							versionId := omit, // Tester decides this shall not be present
							usageStatement := p_usageStatement, // shall be present in ISO 16986
							chargeReportCounter := p_chargeReportCounter // mandatory in ISO 16986
						}
					}
				},
				actionCode:= p_actionCode // may be send, revoke or adjust
			}

			// Below you find a modified template for Toll Declaration ADUs to be sent by the Tester
			// all for the same vehicle, same LPN, same PaymentMeans, same TSP contract, same context
			// but different Id and usage Statement 
			// of course all Tester data are to be defined in module TesterData
			// TODO Jan review. I changed the definition to avoid duplication and potential inconsistencies
			// TODO Jan check possibility for inserting a list of Charge Reports in one ADU ...  
			template (value) TollDeclarationADU m_aduTollDeclarationToSendOneObe (
				in TollDeclarationId p_tollDeclarationId,
				in UsageStatement p_usageStatement,
				in EfcAutonomousContextData.Int4 p_chargeReportCounter,
				in ActionCode p_actionCode
			):=m_aduTollDeclarationToSend(
				p_tollDeclarationId,
				TESTER_OBE_VALID_1,
				TESTER_LPN_VALID_1,
				TESTER_PAYMENT_MEANS_1,
				TESTER_SERVICE_PROVIDER_CONTRACT,
				TESTER_TOLL_CONTEXT,
				p_usageStatement,
				p_chargeReportCounter,
				p_actionCode
			) 

			// below this is a generic template for a ChargeReprt
			template ChargeReport mw_chargeReport := {
				protocolVersion:= AidIdentifier_iso17575_1_2016_,
				obeId := ?, // mandatory in ISO 16986
				vehicleLPNr := ?, // mandatory in ISO 16986
				paymentMeans := ?, // mandatory in IS 16896
				serviceProviderContract := ?, // mandatory in ISO 12855
				tollContext:= ?, // can be Tester or IUT Id
				chargeReportFinalRecipient := omit, // shall not be used in ISO 16986 
				timeOfReport := omit, // shall not be used
				reportPeriod := *, // may or may not be present
				versionId := *, // may or may not be present
				usageStatementList := {  // shall be present in ISO 16986
					{
						usageStatement := ?
					}
				}, 
				sumVatForThisSession := omit, // shall not be used in ISO 16986 
				accountStatus := omit, // shall not be used in ISO 16986
				chargeReportCounter := ?, // mandatory in ISO 16986
				mileage := omit, // shall not be used in ISO 16986
				listOfCccAttributes := omit // shall not be used in IS 16986
			}
			
			// Below this is a generic template for a UsageStatement
			template UsageStatement mw_usageStatement := {
				usageStatementId := ?, // mandatory in ISO 16986
				tollContext := ?, // mandatory in ISO 16986
				chargeReportFinalRecipient := omit, // shall not be used in ISO 16986
				aggregatedFee := omit, // shall not be used in ISO 16986
				sumVat := omit, // shall not be used in ISO 16986
				aggregatedSingleTariffClassSession := *, // TC may use it, but mandatory for TSP
				listOfChargeObjects := *, // TC may use it, but mandatory for TSP
				listOfDsrcUsageData := omit, // shall not be used in ISO 16986
				listOfRawUsageData := *,// TC may use it, but mandatory for TSP
				noUsage := omit, // shall not be used in ISO 16986
				additionalUsageInformation := *
			}

		// Relevant data types below, for easy reference		
		//
		//		type record TollDeclarationId {
		//		  EfcDsrcApplication.Provider issuerId,
		//		  integer declarationId
		//		}
		//				
		//		type record TollDeclarationADU {
		//		  TollDeclarationId tollDeclarationId,
		//		  record of union {
		//			ChargeReport chargeReport,
		//			EfcAutonomousCharging.AuthenticatedChargeReport authenticatedChargeReport
		//		  } gnssTollDeclaration,
		//		  ActionCode actionCode optional
		//		}
		//		
		//		type record ChargeReport {
		//	        EfcAutonomousCharging.AidIdentifier protocolVersion,
		//	        ObeId                               obeId optional,
		//	        VehicleLicencePlateNumber           vehicleLPNr optional,
		//	        PaymentMeans                        paymentMeans optional, 
		//	        EFC_ContextMark                     serviceProviderContract,
		//	        Provider                            tollContext optional,
		//	        Provider                            chargeReportFinalRecipient optional,
		//			ASNAUX.GeneralizedTime              timeOfReport optional,
		//	        Period                              reportPeriod optional,
		//	        VersionId                           versionInfo optional,
		//			record of union {
		//				UsageStatement usageStatement,
		//				AuthenticatedUsageStatement authenticatedUsageStatement
		//			} usageStatementList,
		//			PaymentFee                          sumVatForThisSession optional,
		//	        AccountStatus                       accountStatus optional,
		//	        EfcAutonomousContextData.Int4       chargeReportCounter optional,
		//	        Distance                            mileage optional,
		//	        set of CccAttributes                listOfCccAttributes optional
		//		}
		//		
		//		type record EFC_ContextMark {
		//			Provider contractProvider,
		//			octetstring typeOfContract length (2),
		//			integer contextVersion (
		//			0 .. 127, 
		//			?
		//			)
		//		}
		//		
		//		type record UsageStatement {
		//			EfcDsrcApplication.Int2				usageStatementId optional,
		//	        Provider                            tollContext optional,
		//	        Provider                            chargeReportFinalRecipient optional,
		//	        AggregatedFee                       aggregatedFee optional,
		//	        PaymentFee                          sumVat optional,
		//	        AggregatedSingleTariffClassSession  aggregatedSingleTariffClassSession optional,
		//	        set of DetectedChargeObject         listOfChargeObjects optional,
		//	        ListOfDsrcUsageData                 listOfDsrcUsageData optional,
		//	        ListOfRawUsageData                  listOfRawUsageData optional,
		//	        boolean                             noUsage optional,
		//	        octetstring                         additionalUsageInformation optional
		//	    }
		//
		//		ObeId ::= SEQUENCE {
		//			manufacturerId			Int2, 			-- see ObeConfiguration in 14906
		//			equipmentObuId			EquipmentOBUId
		//		}
				
		//		LPN::= SEQUENCE {
		//			countryCode CountryCode,
		//			alphabetIndicator ENUMERATED {
		//				latinAlphabetNo1 (1), -- encoded as 00 00 00'B
		//				latinAlphabetNo2 (2), -- encoded as 00 00 01'B etc
		//				latinAlphabetNo3 (3),
		//				latinAlphabetNo4 (4),
		//				latinCyrillicAlphabet (5),
		//				latinArabicAlphabet (6),
		//				latinGreekAlphabet (7),
		//				latinHebrewAlphabet (8),
		//				latinAlphabetNo5 (9),
		//				latinAlphabetNo6 (10),
		//				twoOctetBMP (11),
		//				fourOctetCanonical (12),
		//				reservedForUse1 (13),
		//				reservedForUse2 (14),
		//				reservedForUse3 (15),
		//				reservedForUse4 (16),
		//				reservedForUse5 (17),
		//				reservedForUse6 (18),
		//				reservedForUse7 (19),
		//				reservedForUse8 (20),
		//				reservedForUse9 (21),
		//				reservedForUse10 (22),
		//				reservedForUse11 (23),
		//				reservedForUse12 (24),
		//				reservedForUse13 (25),
		//				reservedForUse14 (26),
		//				reservedForUse15 (27),
		//				reservedForUse16 (28),
		//				reservedForUse17 (29),
		//				reservedForUse18 (30),
		//				reservedForUse19 (31),
		//				reservedForUse20 (32),
		//				reservedForUse21 (33)
		//			} -- 6 bits, latinAlphabetNo1 recommended -- ,
		//			-- refer to Annex E for conversion from LatinAlphabetNo 2
		//			-- and 5 to Latin AlphabetNo1
		//			licencePlateNumber OCTET STRING
		//		}
		//
		//  type record PaymentMeans {
		//    PersonalAccountNumber personalAccountNumber,
		//    DateCompact paymentMeansExpiryDate,
		//    octetstring pamentMeansUsageControl length (2)
		//  }
		//
		//	DateCompact::= SEQUENCE {
		//		year INTEGER (1990..2117),
		//		month INTEGER (0..12), -- Value zero shall not be used
		//		-- except with 1990 - see below.
		//		day INTEGER (0..31) -- Value zero shall not be used
		//		-- except with 1990 � see below.
		//	}	
    
		}

		group GNSS_BILLINGDETAILS_TSP{
		}

		group GNSS_BILLINGDETAILS_TC {
		}

		group GNSS_PAYMENTANNOUNCEMENT {
   			template InfoExchange mw_apduPaymentAnnouncement := m_apduNoSec(mw_apci, Adus:{paymentAnnouncementADUs:=?});
			
			template InfoExchange mw_apduAuthPaymentAnnouncement := mw_apduSec(mw_apci, Adus:{paymentAnnouncementADUs:=?});
		}


	}
}
