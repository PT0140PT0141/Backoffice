    
/**
 * @author  PT0140 
 * @desc    This module provides test cases for TPs specified in Annex A of CEN/TC 17154-1 (i.e. Toll Charger system is IUT)
 * @see     [17154-1:2017]: Test suite structure and test purpose
 * @see     [17154-1:2017], Clause 5.3.2 for TP namimg conventions
 * @version $id$
 */
module EfcInfoExchange_TestCasesTc {
 import from EfcInfoExchange_ParameterisedAsn1Data all;

    /**
     * @desc    [12855:2015]: 
     * @see     Annex A (normative)  data type specifications
     * @remark	TODO PT140 to be updated / completed
     */ 
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     * @reramk	Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
     */
    import from Common_ParametrisedAsn1Data all;
    import from EfcInfoExchange_Interfaces all;
    import from EfcInfoExchange_Functions all;
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Ics all;
    import from EfcInfoExchange_Templates all;
    
     /**
      * @desc    These test cases apply to Toll Charger claiming conformance to [16986:2016]
      * and applying Test Purposes as from CEN/TS17154-1:xxxx Annex A
      * @remark  nn TCs
      */
 
	group Base {
	/**
	 * @desctest cases for validating correct general behaviour which is required for any transaction types
	 * @remark TODO PT140: These TCs shall be completed after the transaction TCs are finalized
	 */
	} //End grou Base TPs

	group USERDETAILS {
         group Valid_Behaviour {
              
         	testcase TP_TC_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TC_USERDETAILS_BV_01: Verify that the TC correctly sends an APDU containing valid RequestADUs
				 * and provides valid ProvideUserDetailsADUs 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noParamsToUse ;
				var RecordOfUserParameterRequest listOfParameterReq;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived {
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noParamsToUse := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noParamsToUse;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParameterReq := v_apduReceived.infoExchangeContent.adus.requestAdus[v_ct].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParameterReq);v_loop2:=v_loop2+1) {
									if (not (match(listOfParameterReq[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement
				
				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noParamsToUse];
				
				for (var integer v_loop1 :=0; v_loop1<v_noParamsToUse;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu :=v_adus.provideUserDetailsADUs[v_loop1];
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.statusFlag := UserStatus_standardCommercialUserContract_;
					for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParameterReq);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:=omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= USER_PARAMETER_RESPONSE_DUMMY_VALUES[listOfParameterReq[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:=omit;
					}
				}								                   
				
				var InfoExchange v_apduProvideUserDetailsSend:=m_apduNoSec( m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduProvideUserDetailsSend);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduProvideUserDetailsSend)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BV_01
		} //end group valid behaviour         
         
		group Invalid_Behaviour { 	
			testcase TP_TC_USERDETAILS_BI_01() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_01: Verify that the TC correctly responds to an incorrect ProvideUserDetailsADUs 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noParamsToUse ;
				var RecordOfUserParameterRequest listOfParameterReq;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noParamsToUse := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noParamsToUse;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParameterReq := v_apduReceived.infoExchangeContent.adus.requestAdus[v_ct].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParameterReq);v_loop2:=v_loop2+1) {
									if (not (match(listOfParameterReq[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noParamsToUse];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU not correctsponing to requested parameters								                   
				
				var InfoExchange v_apduProvideUserDetailsSend:=m_apduNoSec(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduProvideUserDetailsSend);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and semantic error (3000)
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_semanticError_}}
				// TODO PT140 prepare second alternative for providing semantic error
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_01				
				
			testcase TP_TC_USERDETAILS_BI_02() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_02: Verify that the TC correctly responds to a provideUserDetailsADU
				 * 			with no statusFlag being present 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noParamsToUse ;
				var RecordOfUserParameterRequest listOfParameterReq;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noParamsToUse := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noParamsToUse;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParameterReq := v_apduReceived.infoExchangeContent.adus.requestAdus[v_ct].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParameterReq);v_loop2:=v_loop2+1) {
									if (not (match(listOfParameterReq[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noParamsToUse];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU with no Status Flag being present								                   
				
				var InfoExchange v_apduProvideUserDetailsSend:=m_apduNoSec(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduProvideUserDetailsSend);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and invaldAdu error (0)
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
						
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_02				
				
			testcase TP_TC_USERDETAILS_BI_03() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_03: Verify that the TC correctly responds to a ProvideUserDetailsADU
				 *			with statusFlag ranging from 1 to 5 and no listOfUserParameters being present
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noParamsToUse;
				var RecordOfUserParameterRequest listOfParameterReq;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noParamsToUse := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noParamsToUse;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParameterReq := v_apduReceived.infoExchangeContent.adus.requestAdus[v_ct].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParameterReq);v_loop2:=v_loop2+1) {
									if (not (match(listOfParameterReq[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noParamsToUse];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU with Status Flag = 1..5 and no listOfUserParameters begin present								                   
				
				var InfoExchange v_apduProvideUserDetailsSend:=m_apduNoSec(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduProvideUserDetailsSend);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and invaldAdu error (0)
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
						
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_03				

			testcase TP_TC_USERDETAILS_BI_04() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_04: Verify that the TC correctly responds to a provideUserDetailsADU with statusFlag value
				 *			not included in the interval from 1 to 5 and listOfUserParameters being present
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noParamsToUse;
				var RecordOfUserParameterRequest listOfParameterReq;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noParamsToUse := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noParamsToUse;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParameterReq := v_apduReceived.infoExchangeContent.adus.requestAdus[v_ct].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParameterReq);v_loop2:=v_loop2+1) {
									if (not (match(listOfParameterReq[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noParamsToUse];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU with Status Flag /= 1..5 and listOfUserParameters begin present								                   
				
				var InfoExchange v_apduProvideUserDetailsSend:=m_apduNoSec(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduProvideUserDetailsSend);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and invaldAdu error (0)
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
						
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_04				

			testcase TP_TC_USERDETAILS_BI_05() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_05: Verify that the TC correctly responds to a provideUserDetailsADU
				 *			with invalid parameters in the UserParameterResponse field
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noParamsToUse;
				var RecordOfUserParameterRequest listOfParameterReq;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noParamsToUse := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noParamsToUse;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParameterReq := v_apduReceived.infoExchangeContent.adus.requestAdus[v_ct].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParameterReq);v_loop2:=v_loop2+1) {
									if (not (match(listOfParameterReq[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noParamsToUse];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU with invalid parameters in UserParameterResponse field								                   
				
				var InfoExchange v_apduProvideUserDetailsSend:=m_apduNoSec(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduProvideUserDetailsSend);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and invaldAdu error (0)
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
						
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_05				

         } // End group Invalid_Behaviour

    } // End goup USERDETAILS

	group LISTOFUSERS {
	
		group Valid_Behaviour {
		
			testcase TP_TC_LISTOFUSERS_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_01: Verify that the TC correctly performs a LISTOFUSERS transaction 
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                  
                // Initialisation
                  
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1 to send valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data

				// Waint for requestADU(s), validate and check time constraints							

                // Step 2: Send valid ProvideUserIdListADU following request from IUT within time constraint LISTOFUSERS.TIME1
                
                // Step 3: Wait for Default_Ack_Apdu within LISTOFUSERS.TIME2			
			
			} // End of TP_TC_LISTOFUSERS_BV_01
			
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase TP_TC_LISTOFUSERS_BI_01() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_01: Verify that the TC correctly responds to a ProvideUserIdListADU with originalUserId not present
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                  
                // Initialisation
                  
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1 to send one valid RequestADU of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data

				// Waint for requestADU, validate and check time constraints							

                // Step 2: Send ProvideUserIdListADU not containing an originalUserId field
                
                // Step 3: Wait for NAck_Apdu within LISTOFUSERS.TIME2 with aduReasonCode = semanticError (3000D)			
			
			} // End of TP_TC_LISTOFUSERS_BI_01

			testcase TP_TC_LISTOFUSERS_BI_02() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_02: Verify that the TC correctly responds to a ProvideUserIdListADU with userIds
                 *			which have not be requested in the requestADU
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                  
                // Initialisation
                  
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1 to send valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data

				// Waint for requestADU(s), validate and check time constraints							

                // Step 2: Send ProvideUserIdListADU(s) with userIds which have not been requested
                
                // Step 3: Wait for NAck_Apdu with ({0, semanticError (3000)})
                // or NAck_Apdu with ({1, semanticError (3000)}, …, {n, semanticError (3000)})
                // where n is the number of ProvideUserIdListADUs
                // within LISTOFUSERS.TIME2 
			
			} // End of TP_TC_LISTOFUSERS_BI_02
			
			testcase TP_TC_LISTOFUSERS_BI_03() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_03: Verify that the TC correctly responds to a ProvideUserIdListADU
                 *			with invalid userId data
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                  
                // Initialisation
                  
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1 to send valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data

				// Waint for requestADU(s), validate and check time constraints							

                // Step 2: Send ProvideUserIdListADU(s) within LISTOFUSERS.TIME1
                // containing UserIds in the userIdList with all fields empty
                
                // Step 3: Wait for NAck_Apdu with ({0, invalidADU(0)})
                // or NAck_Apdu with ({1, InvalidADU(0)}, …, {n, invalidADU(0)})
                // where n is the number of ProvideUserIdListADUs
                // within LISTOFUSERS.TIME2 
			
			} // End of TP_TC_LISTOFUSERS_BI_03

		} // End of Invalid_Behaviour
		
	} // End of group LISTOFUSERS
	
	group EXCEPTIONLIST {
		
		group Valid_Behaviour {
		
			testcase TP_TC_EXCEPTIONLIST_BV_01() runs on MainTestComponent system TestAdapter {
										
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BV_01: Verify that the TC correctly responds to an ExceptionListADU for blacklist and whitelist
                 *			with invalid userId data
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
				
				// Loop (first intertation [LIST_TYPE] = white; second iteration [LIST_TYPE] = black)
				
                	// Step 1: Send one Initiating_Apdu containing exactly one ExceptionListADU for [LIST_TYPE]
                	
                	// Step 2: Wait for Default_Ack within EXCEPTIONLIST.TIME1 of type LIST_TYPE  
                
                } // End of TP_TC_EXCEPTIONLIST_BV_01

			testcase TP_TC_EXCEPTIONLIST_BV_02() runs on MainTestComponent system TestAdapter {
										
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BV_02: Verify that the TC correctly responds to an ExceptionListADU
                 *			for discounted user list
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send one Initiating_Apdu containing exactly one ExceptionListADU of LIST_TYPE=discounted
                	
                // Step 2: Wait for
                //		- Default_Ack, or
                //		- NAck_Apdu with aduReasonCode = semanticError(3000)
                // within EXCEPTIONLIST.TIME1 of type LIST_TYPE  
                
                } // End of TP_TC_EXCEPTIONLIST_BV_02
                
			} // End of group Valid_Behaviour
			
			group Invalid_Behaviour {
			
				testcase TP_TC_EXCEPTIONLIST_BI_01() runs on MainTestComponent system TestAdapter {
														
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BI_01: Verify that the TC correctly responds to an ExceptionListADU for blacklist containing
                 *			exceptionValidityEnd field
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send one Initiating_Apdu containing
                //		- exactly one valid ExceptionListADU indicating list type BLACK; AND
				//		- exactly one ExceptionListADU indicating list type BLACK and containing exceptionValidityEnd of any value
                	
                // Step 2: Wait for NAck_Apdu with ({2, exceptionListsDateAndTimeRejected(405)})
                // within the time EXCEPTIONLIST.BLACK_TIME1   				

				} // End of TP_TC_EXCEPTIONLIST_BI_01

				testcase TP_TC_EXCEPTIONLIST_BI_02() runs on MainTestComponent system TestAdapter {
														
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BI_02: Verify that the TC correctly responds to an ExceptionListADU for blacklist
                 *			containing the efcContextMark field
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send Initiating_Apdu containing exactly one ExceptionListADU indicating list type BLACK containing
                //		- efcContextMark of any value
                	
                // Step 2: Wait for NAck_Apdu with issueCode=otherReason(5)
                // within the time EXCEPTIONLIST.BLACK_TIME1   				

				} // End of TP_TC_EXCEPTIONLIST_BI_02

				testcase TP_TC_EXCEPTIONLIST_BI_03() runs on MainTestComponent system TestAdapter {
														
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BI_03: Verify that the TC correctly responds to one APDU
                 *			containing more than one ExceptionListADU
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send Initiating_Apdu containing mre than one ExceptionListADU indicating list type BLACK
                
                // Step 2: Wait for NAck_Apdu with issueCode=otherReason(5)
                // within the time EXCEPTIONLIST.BLACK_TIME1   				

				} // End of TP_TC_EXCEPTIONLIST_BI_03

				testcase TP_TC_EXCEPTIONLIST_BI_04() runs on MainTestComponent system TestAdapter {
														
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BI_04: Verify that the TC correctly responds to an ExceptionListADU
                 *			bearing an incorrect value for exceptionListVersion field
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send Initiating_Apdu containing one ExceptionListADU indicating list type BLACK
                //		- with exceptionListVersion </= 0
      
                // Step 2: Wait for NAck_Apdu with issueCode=exceptionListsVersionRejected(400)
                // within the time EXCEPTIONLIST.BLACK_TIME1   				

				} // End of TP_TC_EXCEPTIONLIST_BI_04

				testcase TP_TC_EXCEPTIONLIST_BI_05() runs on MainTestComponent system TestAdapter {
														
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BI_05: Verify that the TC correctly responds to an ExceptionListADU
				 *			bearing an incorrect value for exceptionListType field
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send Initiating_Apdu containing one ExceptionListADU indicating exceptionListType = 4
      
                // Step 2: Wait for NAck_Apdu with issueCode=exceptionListsTypeRejected(401)
                // within the time EXCEPTIONLIST.BLACK_TIME1   				

				} // End of TP_TC_EXCEPTIONLIST_BI_05

				testcase TP_TC_EXCEPTIONLIST_BI_06() runs on MainTestComponent system TestAdapter {
														
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BI_06: Verify that the TC correctly responds to an ExceptionListADU
                 *			bearing an incorrect value for userId field
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send Initiating_Apdu containing one ExceptionListADU of list type BLACK
                // and userId = contractSerialNumber present
      
                // Step 2: Wait for NAck_Apdu with issueCode=exceptionListsUserIdRejected(402)
                // within the time EXCEPTIONLIST.BLACK_TIME1   				

				} // End of TP_TC_EXCEPTIONLIST_BI_06

				testcase TP_TC_EXCEPTIONLIST_BI_07() runs on MainTestComponent system TestAdapter {
														
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BI_07: Verify that the TC correctly responds
                 *			to an ExceptionListADU with exceptionValidityEnd
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send Initiating_Apdu containing one ExceptionListADU of list type BLACK
                // and and with exceptionValidityEnd present
      
                // Step 2: Wait for NAck_Apdu with issueCode=exceptionListsDateAndTimeRejected(405)
                // within the time EXCEPTIONLIST.BLACK_TIME1   				

				} // End of TP_TC_EXCEPTIONLIST_BI_07

				testcase TP_TC_EXCEPTIONLIST_BI_08() runs on MainTestComponent system TestAdapter {
														
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BI_08: Verify that the TC responds correctly
                 *			to a RequestADU sent earlier than allowed
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send Initiating_Apdu containing one valid ExceptionListADU of list type BLACK
                
                // Send second Initiating_Apdu containing one valid ExceptionListADU of list type BLACK
                // before EXCEPTIONLIST.TIMEA_MIN has passed

                // Step 2: Wait for NAck_Apdu with issueCode=NAck_requestSentTooOften(10)
                // within the time EXCEPTIONLIST.BLACK_TIME1   				

			} // End of TP_TC_EXCEPTIONLIST_BI_08

		} // End of group Invalid_Behaviour 
			
	} // End of group EXCEPTIONLIST		
			
	group TRUSTOBJECTS {
         
		group Valid_Behaviour {
           
			testcase TP_TC_TRUSTOBJECTS_BV_01() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BV_01: Verify that the TC correctly provides a TrustObjectADU without TSP request
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_01
                 */
                 
				// Initialisation
				
				// Loop: repeate with different TrustObjectSpec supported by the IUT
                  
                	// Step 1: No action in step 1 in the test case  
                  
                	// Step 2: Tigger IUT with TRUSTOBJECTS_TR_2 to send Initiating_Apdu containing exactly one TrustObjectADU

					// Wait for requestADU(s), validate and check time constraints												
             
			} // End of TP_TC_TRUSTOBJECTS_BV_01

			testcase TP_TC_TRUSTOBJECTS_BV_02() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BV_02: Verify that the TC correctly responds to a Trust Object received
                 *			from a TSP without having issued a request
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_02
                 */
                 
				// Initialisation
				// Prepare Trust Object(s) to be sent
				
				// Loop: repeate with different TrustObjectSpec supported by the IUT
                  
                	// Step 1: No action in step 1 in the test case  
                  
                	// Step 2: Send Initiating_Apdu containing exactly one TrustObjectADU

					// Step 3: Waint for Default_Ack_Apdu within TRUSTOBJECTS.TIME2												
             
			} // End of TP_TC_TRUSTOBJECTS_BV_02

			testcase TP_TC_TRUSTOBJECTS_BV_03() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BV_03: Verify that the TC correctly provides a TrustObjectADU
                 *			following a TSP request
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_03
                 */
                 
				// Initialisation
				
				// Loop: repeate with different TrustObjectSpec supported by the IUT
                  
                	// Step 1: Send Initiating_Apdu containing a RequestADU as the only ADU, with
                	//		- requestedADUType = trustObjectADU, and
                	//		- requestedTrustObject containing valid values accoring to IUT supported TrustObjectSpec
                  
					// Step 2: Wait for Default_Ack_Apdu within TRUSTOBJECTS.TIME1												
             
			} // End of TP_TC_TRUSTOBJECTS_BV_03

			testcase TP_TC_TRUSTOBJECTS_BV_04() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BV_04: Verify that the TC correctly requests and responds to a TrustObjectADU
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_04
                 */
                 
				// Initialisation
				
				// Loop: repeate with different TrustObjectSpec supported by the IUT
                  
                	// Step 1: Tigger IUT with TRUSTOBJECTS_TR_1 to send Initiating_Apdu Initiating_Apdu containing
                	//			a valid RequestADU as the only ADU, with
                	// 			{requestedADUType = trustObjectADU, requestedTrustObject}
                  
					// Step 2: Wait for Default_Apdu containing a valid TrustObjectADU as the only ADU within TRUSTOBJECTS.TIME1
					
					// Step 3: Send Default_Ack_Apdu within TRUSTOBJECTS.TIME2												
             
			} // End of TP_TC_TRUSTOBJECTS_BV_04

		} // End group Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase TestCase_TP_TC_TRUSTOBJECTS_BI_01() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_01: Verify that the TC correctly responds to a TrustObjectADU received
                 *			without having issued a request and containing incorrect ADU parameters
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_01
                 */
                 
				// Initialisation
				                  
                // Step 1: No action in step 1 in this test case
                  
				// Step 2: Send Initiating_Apdu containing a valid TrustObjectADU as the only ADU,
				// with at least one of the following data fields bearing invalid values:
				//		- trustObjectId;
				//		- purposesOfTrustObject;
				//		- startValidity;
				//		- endValidity;
				//		- trustObjectStatus;
				//		- trustObject
									
				// Step 3: Wait for NAck_Apdu within TRUSTOBJECTS.TIME2												
             
			} // End of TP_TC_TRUSTOBJECTS_BI_01 
 
 			testcase TestCase_TP_TC_TRUSTOBJECTS_BI_02() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_02: Verify that the TC correctly responds to more than one correct TrustObjectADU
                 *			in the same APDU without having issued a request
                 *			without having issued a request and containing incorrect ADU parameters
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_02
                 */
                 
				// Initialisation
				                  
                // Step 1: No action in step 1 in this test case
                  
				// Step 2: Send Initiating_Apdu containing two TrustObjectADUs with valid values
									
				// Step 3: Wait for NAck_Apdu within TRUSTOBJECTS.TIME2												
             
			} // End of TP_TC_TRUSTOBJECTS_BI_02 
 
			testcase TestCase_TP_TC_TRUSTOBJECTS_BI_02() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_02: Verify that the TC correctly responds to more than one correct TrustObjectADU
                 *			in the same APDU without having issued a request
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_02
                 */
                 
				// Initialisation
				                  
                // Step 1: No action in step 1 in this test case
                  
				// Step 2: Send Initiating_Apdu containing two TrustObjectADUs with both valid values
									
				// Step 3: Wait for NAck_Apdu within TRUSTOBJECTS.TIME2												
             
           } // End of TP_TC_TRUSTOBJECTS_BI_02 
  
			testcase TestCase_TP_TC_TRUSTOBJECTS_BI_03() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_03: Verify that the TC correctly responds to a request
                 *			for a not supported Trust Object
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_03
                 */
                 
				// Initialisation
				
				// Loop: repeate with different invalid values of requestedTrustObject
				                  
                	// Step 1: Send Initiating_Apdu containing a RequestADU as the only ADU, with
                	//		- requestedADUType = trustObjectADU,
                	//		- and requestedTrustObject not included in the set of allowed combinations
                  
					// Step 2: Wait for NAck_Apdu with the ADUReasonCode = semanticError (3000) within TRUSTOBJECTS.TIME2												
             
           } // End of TP_TC_TRUSTOBJECTS_BI_03 
 
			testcase TestCase_TP_TC_TRUSTOBJECTS_BI_04() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_04: Verify that the TC correctly responds to a RequestADU sent earlier than allowed
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_04
                 */
                 
				// Initialisation
				                  
                // Step 1: Send Initiating_APDU containing one RequestADU of type trustObjectRequest
				// Send second Initiating_APDU containing one RequestADU of type trustObjectRequest before TIMEA_MIN
                       
				// Step 2: Wait for NAck_requestSentTooOften within TRUSTOBJECTS.TIME2												
             
           } // End of TP_TC_TRUSTOBJECTS_BI_04 
 
			testcase TestCase_TP_TC_TRUSTOBJECTS_BI_05() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_05: Verify that the TC correctly responds to a TrustObjectADU sent earlier than allowed
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_05
                 */
                 
				// Initialisation
				                  
                // Step 1: Send Initiating_APDU containing one TrustObjectADU
				// Send second Initiating_APDU containing one TrustObjectADU before TRUSTOBJECTS.TIMEB_MIN
                       
				// Step 2: Wait for NAck_requestSentTooOften within TRUSTOBJECTS.TIME2												
             
           } // End of TP_TC_TRUSTOBJECTS_BI_05   
 
 		} // End group Invalid_Behaviour

	} // End of group TRUSTOBJECTS		

	group PAYMENTCLAIM {
	
		group Valid_Behaviour {
		
			testcase TP_TC_PAYMENTCLAIM_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_01: Verify that the TC correctly performs the PAYMENTCLAIM transaction with
                 *			actionCode=send 
                 * @remark  [16986:2016], Clause 6.8 and Table A.1/1 AND Table A.7/5
                 */
                  
                // Initialisation
                  
                // Let IUT perform one BILLINGDETAILS complete and sucessful transaction
                  
                // Step 1: Tigger IUT with PAYMENTCLAIM_TR_TC_1 to send valid Initiating_Apdu containing
                //		- exactly one PaymentClaimADU with actionCode=send

				// Waint for requestADU(s), validate and check time constraints
				
				// Step 2: Send AckADU to conclude the transaction							
		
			} // End of TP_TC_LISTOFUSERS_BV_01
					
			testcase TP_TC_PAYMENTCLAIM_BV_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_02: Verify that the TC correctly performs the PAYMENTCLAIM transaction with
                 *			actionCode=revoke or adjust  
                 * @remark  [16986:2016], Clause 6.8 and Table A.1/1 AND Table A.7/5
                 */
                  
                // Initialisation
                
                // Loop: Repeate with
                //		- first iteration: ACTION_CODE=adjust;
                //		- second iteration: ACTION_CODE=revoke
                  
                	// Let IUT perform one BILLINGDETAILS complete and sucessful transaction
                	// Trigger IUT with PAYMENTCLAIM_TR_TC_1 to send valid Initiating_Apdu containing
                	// exactly one PaymentClaimADU with actionCode=send;
                	// Send AckADU to colclude the transaction
                  
                	// Step 1: Tigger IUT with PAYMENTCLAIM_TR_TC_1 to send valid Initiating_Apdu containing
                	//		- exactly one PaymentClaimADU, with
                	//		- with actionCode=[ACTION_CODE], and
                	//		- paymentClaimId = same value as a previously sent PaymentClaimId
    
					// Waint for requestADU(s), validate and check time constraints
				
					// Step 2: Send AckADU to conclude the transaction							
		
			} // End of TP_TC_LISTOFUSERS_BV_02
			
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {
		
               /**
                 * @remark  No TPs have been defined
                 */
 		
 		} // End Invalid_Behaviour
 		
 	} // End PAYMENTCLAIM

	group DSRC_CONTRACTISSUERLIST {
	
		group Valid_Behaviour {
		
			testcase Testcase TP_TC_DSRC_CONTRACTISSUERLIST_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BV_01: Verify that the TC correctly performs
                 *			a DSRC.CONTRACTISSUERLIST transaction with three ContractIssuerListADUs  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.26/1
                 */
                   		
 				// Initialisation
                 
                // Step 1:
                // Send Initiating_Apdu containing three ContractIssuerListADUs with differing manufacturerID values
                
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time DSRC.CONTRACTISSUERLIST.TIME1
              	// if negative Ack or not received set test failure
              	
              } // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BV_01
              
		} // End group Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase Testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BI_01: Verify that the TC correctly responds to
                 *			a ContractIssuerListADUs with three different semantically faulty parameters  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.26/1
                 */
                   		
 				// Initialisation
                 
                // Step 1:
                // Send Initiating_Apdu containing three ContractIssuerListADUs each one with exactly
                // one incorrect parameter value from the set [uniquePartOfPan, acCrKeyReference, authKeyReference]
                
                // Step 2:	
              	// Wait for NAck_Apdu with issueCode = semanticError (3000)
              	// within the time interval DSRC.CONTRACTISSUERLIST.TIME1
              	// if negative Ack or not received set test failure
              	
              } // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_01			

			testcase Testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BI_02: Verify that the TC correctly responds to a RequestADU
                 *			sent earlier than allowed  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.26/1
                 */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Send Initiating_Apdu containing one valid RequestADU of type userListRequest
                
                // Send second Initiating_Apdu containing one valid RequestADU of type userListRequest
                // before DSRC.CONTRACTISSUERLIST.TIMEA_MIN has passed

                // Step 2: Wait for NAck_Apdu with issueCode=NAck_requestSentTooOften(10)
                // within the time DSRC.CONTRACTISSUERLIST.TIME1  
              	
			} // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_02
			
		} // End group Invalid_Behaviour

	} // End DSRC_CONTRACTISSUERLIST 

	group DSRC_EFCCONTEXTDATA {
	
		group Valid_Behaviour {
		
			testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_01: Verify that the TC correctly performs a DSRC.EFCCONTEXTDATA transaction
                 *			for a domain type = dsrcContext  
                 * @remark  [16986:2016], Clause 7.2 and Table A.1/1 AND Table A.2/2 AND Table A.30/2 = dsrcContext
                 */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Tigger IUT with DSRC.EFCCONTEXTDATA_TR_TC_1 to send valid Initiating_Apdu
                // containing a EFCContextDataADU as the only ADU, with
                //		- domainType = dsrcContext;
                //		- the values of all fields in EFCContextDataADU being within the range specified by the IUT
                

                // Wait for above specified APDU within time constraints
                // use template for APDU
                // if not received or received outside specification or time constraints set test fail
                
                // Step 2: Send AckADU to conclude the transaction 
                // within the time DSRC.CONTRACTISSUERLIST.TIME1  
              	
			} // End testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_01
			
			testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_02: Verify that the TC correctly performs a DSRC.EFCCONTEXTDATA transaction
                 *			for a domain type = dsrcClosedContext
                 * @remark  [16986:2016], Clause 7.2 and Table A.1/1 AND Table A.2/2 AND Table A.30/2 = dsrcClosedContext
                 */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Tigger IUT with DSRC.EFCCONTEXTDATA_TR_TC_1 to send valid Initiating_Apdu
                // containing a EFCContextDataADU as the only ADU, with
                //		- domainType = dsrcClosedContext;
                //		- the values of all fields in EFCContextDataADU being within the range specified by the IUT

                // Wait for above specified APDU within time constraints
                // use template for APDU
                // if not received or received outside specification or time constraints set test fail
                
                // Step 2: Send AckADU to conclude the transaction 
                // within the time DSRC.CONTRACTISSUERLIST.TIME1  
              	
			} // End testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_02
			
		} // End group Valid_Behaviour
		
		group Invalid_Behaviour
		
               /**
                 * @remark  No TPs have been defined
                 */
 		
		} // End Invalid_Behaviour

	} // End DSRC_EFCCONTEXTDATA
	
	group DSRC_BILLINGDETAILS {
	
		group Valid_Behaviour {
		
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_01: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=send
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1 to send valid Initiating_Apdu containing BillingDetailsADUs
                // containing all valid permutations of present and not present optional fields and choices that are used
                // in the IUT implementation, all with actionCode = send

                // Wait for above specified APDU within time constraints
                // use template for APDU
                // if not received or received outside specification or time constraints set test fail
                
                // Step 2: Send AckADU to conclude the transaction 
                // within the time DSRC.BILLINGDETAILS.TIME1

			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_01
			
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_02: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=adjust
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A.36/15 = adjust
                */
 
  				// Initialisation
                 
				// Start by setting test success
				
				// Trigger a first BILLINGDETAILS transaction with DSRC.BILLINGDETAILS_TR_TC_1
				// receive the BillingetailsADU
				// send a negative Ack (except of issueCode "acceptedWithWarning")
				
								
                // Step 1: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1 to send valid Initiating_Apdu containing
                // exactely one BillingDetailsADU;
                // billingDetailsId referencing the previously sent BillingDetailsADU;
                // with actionCode = adjust

                // Wait for above specified APDU within time constraints
                // use template for APDU
                // if not received or received outside specification or time constraints set test fail
                
                // Step 2: Send AckADU to conclude the transaction 
                // within the time DSRC.BILLINGDETAILS.TIME1

			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_02
						
			testcase TP_TC_DSRC_BILLINGDETAILS_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_03: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=revoke
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A.36/15 = revoke
                */
 
  				// Initialisation
                 
				// Start by setting test success
				
				// Trigger a first BILLINGDETAILS transaction with DSRC.BILLINGDETAILS_TR_TC_1
				// receive the BillingetailsADU
				// send an AckADU
				
								
                // Step 1: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1 to send valid Initiating_Apdu containing
                // exactely one BillingDetailsADU;
                // billingDetailsId referencing the previously sent BillingDetailsADU;
                // with actionCode = revoke

                // Wait for above specified APDU within time constraints
                // use template for APDU
                // if not received or received outside specification or time constraints set test fail
                
                // Step 2: Send AckADU to conclude the transaction 
                // within the time DSRC.BILLINGDETAILS.TIME1

			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_03
			
		} // End Valid_Behaviour
		
		group Invalid_Behaviour {

               /**
                 * @remark  No TPs have been defined
                 */			
			
		} // End Invalid_Behaviour
		
	} // End DSRC_BILLINGDETAILS

	group DSRC_REPORTABNORMALOBE {
	
		group Valid_Behaviour {
		
			testcase TP_TC_DSRC_REPORTABNORMALOBE_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_REPORTABNORMALOBE_BV_01: Verify that the TC correctly performs a DSRC.REPORTABNORMALOBE transaction
                * @remark  [16986:2016], Clause 7.4 and Table A.1/1 AND Table A.2/1 AND Table A.26/41
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1: Tigger IUT with DSRC.REPORTABNORMALOBE_TR_TC_1 to send valid Initiating_APDU containing
                // one or more ADUs of type ReportAbnormalOBEADU containing different combinations of valid
                // and IUT declared values in the following data elements
				//		- userID = at least one element shall be present;
				//		- dateAndTime = present and valid;
				//		- efcContextMark = present and valid;
				//		- abnormalOBEReason code = present and valid                

                // Wait for above specified APDU within time constraints
                // use template for APDU
                // if not received or received outside specification or time constraints set test fail
                
                // Step 2: Send AckADU to conclude the transaction 
                // within the time DSRC.REPORTABNORMALOBE.TIME1

			} // End testcase TP_TC_DSRC_REPORTABNORMALOBE_BV_01
			
		} // End Valid_Behaviour

		group Invalid_Bahaviour {

               /**
                 * @remark  No TPs have been defined
                 */			
			
		} // End Invalid_Behaviour		
		
	} // End DSRC_REPORTABNORMALOBE

	group GNSS_TOLLDECLARATION {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_TOLLDECLARATION_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_01: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = send
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send
                
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_01

			testcase TP_TC_GNSS_TOLLDECLARATION_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_02: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = revoke
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
				
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail 
								
                // Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations with tollDeclarationId = same value as already received toll declarations and
                // containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = revoke
                
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_02

			testcase TP_TC_GNSS_TOLLDECLARATION_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_03: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = adjust
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
				
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail 
								
                // Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations with tollDeclarationId = same value as already received toll declarations and
                // containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = adjust
                
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_03
			
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_01: Verify that the TC correctly responds to an APDU containing
                *			a number of TollDeclarationADUs which exceeds PARAM1_MAX
                *			that are not the same as the original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send Initiating_Apdu containing one TollDeclarationADU
                // with valid and IUT declared values but exceeding GNSS.TOLLDECLARATION.PARAM1_MAX
                
                // Step 2:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdus
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_01
		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_02: Verify that the TC correctly responds to an APDU containing
                * 			valid TollDeclarationADUs with actionCode = revoke but tollDeclarationIds
                *			that are not the same as the original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
				
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // gnssTollDeclarations containing valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail 
								
                // Step 1:
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // a gnssTollDeclaration with tollDeclarationId /= the value as already received toll declaration and
				// containing valid and IUT declared values for
				// 		- chargeReport,
				//		- chargeReportUsageStatementList and
				//		- usageStatement; and
				//		- actionCode = revoke
                
                // Step 2:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdus
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_02

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_03: Verify that the TC correctly responds to an APDU containing
                *			valid TollDeclarationADUs with actionCode = adjust but tollDeclarationIds
                *			that are not the same the as original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
				
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // gnssTollDeclarations containing valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail 
								
                // Step 1:
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // a gnssTollDeclaration with tollDeclarationId /= the value as already received toll declaration and
				// containing valid and IUT declared values for
				// 		- chargeReport,
				//		- chargeReportUsageStatementList and
				//		- usageStatement; and
				//		- actionCode = adjust
                
                // Step 2:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdus
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_03

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_04: Verify that the TC correctly responds to an APDU
                *			containing valid TollDeclarationADUs with tollDeclarationIds being not unique
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send Initiating_Apdu containing two TollDeclarationADU containing
				//		- tollDeclarationId = same values in the two toll declarations, and
				//		- gnssTollDeclarations with valid and IUT declared values, and
				//		- actionCode = send
                
                // Step 2:
                // Wait for NAck_Apdu with apduAckCode = apduNotOK (3)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_04
               		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_05: Verify that the TC correctly responds to an APDU containing
                *			valid TollDeclarationADUs with gnssTollDeclaration of Choice AuthenticatedChargeReport
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing
				//		- gnssTollDeclaration of Choice AuthenticatedChargeReport, and
				//		- actionCode = send
                
                // Step 2:
                // Wait for NAck_Apdu with apduAckCode = apduNotOK (3)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_05

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_06: Verify that the TC correctly responds to an APDU containing
                *			a number of chargeReports which exceeds GNSS.TOLLDECLARATION.PARAM2_MAX
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- more than GNSS.TOLLDECLARATION.PARAM2_MAX chargeReports containing valid and IUT declared values;
				//		- actionCode = send
                
                // Step 2:
                // Wait for NAck_Apdu with (with issues= Ø)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_06

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_07() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_07: Verify that the TC correctly responds to an APDU containing
                *			a TollDeclarationADU in which the actionCode is not present
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- with valid and IUT declared values, and
                //		- actionCode = Ø
                
                // Step 2:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdus
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_07
	                		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_08() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_08: Verify that the TC correctly responds to an APDU containing
                *			a TollDeclarationADU in which the actionCode is neither send, revoke nor adjust
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- with valid and IUT declared values, and
                //		- actionCode /= {send, revoke, adjust}
                
                // Step 2:
                // Wait for NAck_Apdu with
                //		- ({0,actionCodeNotSupported(3010)}) OR
                //		- ({1,actionCodeNotSupported(3010)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdus
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_08

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_09() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_09: Verify that the TC correctly responds to an APDU containing
                *			more than one TollDeclarationADUs with actionCode send of which
                *			one or more fields in the toll declarations and/or underlying data elements are invalid
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send Initiating_Apdu containing
                //		- one TollDeclarationADU with valid and IUT declared values; and
                //		- one TollDeclarationADU with values not declared as IUT implemented
                //		- actionCode = send
                
                // Step 2:
                // Wait for Ack_Apdu with
                //		- issueADUStruct =2, and
                //		- issueCode = semanticError(3000)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdus
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_09
			
		} // End Invalid_Behaviour
		
	} // End GNSS_TOLLDECLARATION

	group GNSS_BILLINGDETAILS_TSP {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when a TSP provides a single BillingDetailsADU
                *			with no optional fields except includedDiscounts and actionCode=send
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- includedDiscounts is present; and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides
                *			a single BillingDetailsADU with no optional fields, actionCode = send
                *			and having selected forSectionedRoads
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forTravellingInArea
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/2
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for TracellingInArea, and
				//		- the value of entranceChargeObjectName in forCordonCrossing being a correct UTF8String, and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forStayingInArea
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for StayingInArea, and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forCordonCrossings
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/4
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for CordonCrossing, and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06: Verify that the TC correctly performs
                *			a GNSS_BILLINGDETAILS_TSP transaction when the TSP provides multiple BillingDetailsADUs
                *			with no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a GNSS.BILLINGDETAILS.TSP.PARAM1_MAX valid BillingDetailsADUs with
                //		- actionCode = send and no optional fields
                  
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP sends a single BillingDetailsADU
                *			with actionCode = adjust and no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with negative Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = adjust, and
				//		- no optional fields, and
				//		- billingDetailsNum referencing the previously received BillingDetailsADU
                  
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08: VVerify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP sends a single BillingDetailsADU
                *			with actionCode =revoke and no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.BILLINGDETAILS transaction with positive Ack
				// wait respective time constraints until next transaction starts
				// Perform a corresponing GNSS.TOLLDECLARATION trasnaction
				// wait respective time constraints until next transaction starts
								
                // Step 1:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = revoke, and
				//		- no optional fields, and
				//		- billingDetailsNum referencing the previously received BillingDetailsADU
                  
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08
			
		} // End Valid_Behaviour

		group Invalid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01: Verify that the TC correctly responds
                *			when receiving multiple BillingDetailsADUs with no optional fields present
                *			with each BillingDetailsADU having one field with an incorrect value
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing 10 BillingDetailsADUs with
                //		- all mandatory fields, and
                //		- no optional fields,
                //		- where the following fields have an incorrect value
                //			(a) billingDetailsId.issuerId
                //			(b) tollContext
                //			(c)	userId
                //			(d) billingDetailsAmount
                //			(e) usageDetails.contextName
                //			(f) usageDetails.appliedUserClass
                //			(g) usageDetails.perDeclaredVehicleClasses
                //			(h)	usageDetails.appliedTimeClass
                //			(i) usageDetails.entranceTime
                //			(j) usageList.ListofSections.chargeObjectId
                 
                // Step 2:
                // Wait for NAck_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1
                // with issueCodes corresponding to the incorrect velues above:
                //			(a) billingDetailsIssuerIdRejected
                //			(b) billingDetailsContextIdRejected
                //			(c) billingDetailsUserIdRejected
                //			(d) billingDetailsAmountRejected
                //			(e) billingDetailsContextNameRejected
                //			(f) billingDetailsAppliedUserClassRejected
                //			(g) billingDetailsDeclaredVehicleClassRejected
                //			(h) billingDetailsAppliedTimeClassRejected
                //			(i) billingDetailsEntranceTimeRejected
                //			(j) billingDetailsIntermediateSectionRejected
                             
                // use template(s) for NAck_Apdu
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02: Verify that the TC correctly responds
                * 			when the TSP provides a single BillingDetailsADU with only mandatory fields,
                *			then issues a second BillingDetailsADU too early
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
                // Step 1:
                // Before TIMEA_MIN as passed, send valid Initiating_Apdu containing exactly one BillingDetailsADUs with
                //		- all mandatory fields, and
                //		- no optional fields,
                 
                // Step 2:
                // Wait for NAck_requestSentTooOften(10) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck_requestSentTooOften(10)
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03: Verify that the TC correctly responds
                *			when the TSP sends too many BillingDetailsADUs
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing
                // (GNSS.BILLINGDETAILS.TSP. PARAM1_MAX +1) BillingDetailsADUs, with no optional fields
                 
                // Step 2:
                // Wait for NAck containing issueCode = semanticError(3000) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04: Verify that the TC correctly reponds
                *			when the TSP adjusts billing details that do not exist at IUT side
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing containing exactly one a BillingDetailsADU with
                //		- all mandatory fields, and
                //		- actionCode = adjust, and
                //		- no optional fields, and
                //		- billingDetailsNum referencing a billing details that do not exist at the IUT side
                 
                // Step 2:
                // Wait for NAck containing issueCode = semanticError(3000) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05: Verify that the TC correctly reponds
                *			when the TSP tries to revoke billing details that do not exist at TC side
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing containing exactly one a BillingDetailsADU with
                //		- all mandatory fields, and
                //		- actionCode = revoke, and
                //		- no optional fields, and
                //		- billingDetailsNum referencing a billing details that do not exist at the IUT side
                 
                // Step 2:
                // Wait for NAck containing issueCode = semanticError(3000) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05

		} // End Invalid_Behaviour
		
	} // End GNSS_BILLINGDETAILS_TSP

	group GNSS_BILLINGDETAILS_TC {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_01: Verify that the TC correctly performs a GNSS.BILLINGDETAILS.TC transaction
                *			with BillingDetailsADUs containing all permutations of present and
                *			not present optional fields that vary in the IUT implementation, all with actionCode=send
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
                 
				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Trigger IUT to send send BillingDetailsADUs containing
                //		- all valid permutations of present and not present optional fields and choices that are used in the IUT implementation
                
                  
                // Wait for Initiating_Apdu containing BillingDetailsADUs containing
                //		- all permutations of present and not present optional fields that vary in the IUT implementation,
                //		- all with actionCode=send
                // within specified time constraints
                
                // if not received or received outside specification or time constraints set test fail
                
                // Step 2:
                // Send AckADU to conclude the transaction
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_02: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TC transaction when it sends a single BillingDetailsADU
                *			with actionCode = adjust and no optional fields
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
                 		
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction and GNSS.BILLINGDETAILS.TC trasnaction with positive Ack
				// wait respective time constraints until next transaction
								
                // Step 1:
                // Trigger IUT to send send BillingDetailsADUs containing exactly one BillingDetailsADU with
                //		- actionCode = adjust, and
                //		- billingDetailsNum referencing the previously negatively acknowledged BillingDetailsADU
                
                // Wait for Initiating_Apdu containing exactly one BillingDetailsADU with
                //		- actionCode = adjust, and
                //		- no optional fields present, and
                //		- billingDetailsNum referencing the previously negatively acknowledged BillingDetailsADU               
                // within specified time constraints
                
                // if not received or received outside specification or time constraints set test fail
                
                // Step 2:
                // Send AckADU to conclude the transaction
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_03: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TC transaction when it sends a single BillingDetailsADU
                *			with actionCode = revoke and no optional fields
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
                 		
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction
				// At least one GNSS.BILLINGDETAILS.TSP transaction have been initiated
				// with a negative acknowledgement due to wrong fee
				// wait respective time constraints until next transaction
								
                // Step 1:
                // Trigger IUT to send send BillingDetailsADUs containing exactly one BillingDetailsADU with
                //		- optional fields present and not present, and
                //		- actionCode = revoke, and
                //		- billingDetailsNum referencing the previously sent BillingDetailsADU
                
                // Wait for Initiating_Apdu containing exactly one BillingDetailsADU with
                //		- actionCode = revoke, and
                //		- no optional fields present, and
                //		- billingDetailsNum referencing the previously sent BillingDetailsADU               
                // within specified time constraints
                
                // if not received or received outside specification or time constraints set test fail
                
                // Step 2:
                // Send AckADU to conclude the transaction
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_03
			
		} // End Valid_Behaviour

		group Invalid_Bahaviour {

               /**
                 * @remark  No TPs have been defined
                 */			
			
		} // End group Invalid_Behaviour		
		
	} // End group GNSS_BILLINGDETAILS_TC
	
	group GNSS_PAYMENTANNOUNCEMENT {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01: Verify that the TC correctly performs
                *			a GNSS.PAYMENTANNOUNCEMENT transaction
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform at least one GNSS_BILLINGDETAILS trasnaction with positive Acknowledgement	
				// Wait until respective time constraints for starting next transaction are passed
                 				
                // Step 1:
                // Send Initiating_Apdu containing only three or more valid PaymentAnnouncementADU with
                //		- actionCode = send
                  
                // Step 2:  
                // Wait for Default_Ack_Apdu within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01
			
		} // End Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU with an incorrect actionCode
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform one GNSS_BILLINGDETAILS transaction with positive Ack	
				// Wait until respective time constraints for starting next transaction are passed
				// Perform one GNSS_PAYMENTANNOUNCEMENT transaction with actionCode=send with positive Ack 
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing 
				//		- exactly one PaymentAnnouncementADU with actionCode=credit, and
				//		- exactly one PaymentAnnouncementADU with actionCode=resend
				//		- both referencing to paymentAnnouncementIds previousely sent
                  
                // Step 2:  
                // Wait for NAck_Apdu containing one AckADU containing
				//		- {an "issues" SEQUENCE of length two with the issueCode=indicating invalidADU for all and
				//			issueADUStruct indicating 1 and 2 respectively}, or
				//		- {an "issues" SEQUENCE of length one with issueCode=invalidADU and issueADUStruct=0}
                // within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdus
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU with incorrect paymentAnnouncementID 
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform one GNSS_BILLINGDETAILS transaction with positive Ack	
				// Wait until respective time constraints for starting next transaction are passed
				// Perform one GNSS_PAYMENTANNOUNCEMENT transaction with actionCode=send with positive Ack 
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing 
				// 		- exactly one PaymentAnnouncementADU with actionCode=send containing
				//			paymentAnnouncementId = value that has previously been used, and
				//		- exactly one PaymentAnnouncementADU with actionCode=revoke containing
				//			paymentAnnouncementId = value that has not previously been used
                  
                // Step 2:  
                // Wait for NAck_Apdu containing one AckADU containing
				//		- {an "issues" SEQUENCE of length two with the issueCode=indicating invalidADU for all and
				//			issueADUStruct indicating 1 and 2 respectively}, or
				//		- {an "issues" SEQUENCE of length one with issueCode=invalidADU and issueADUStruct=0}
                // within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdus
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03: Verify that the TC correctly responds
                *			to PaymentAnnouncementADUs where details from referenceDetailsList are not present
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform one GNSS_BILLINGDETAILS transaction with positive Ack	
				// Wait until respective time constraints for starting next transaction are passed
				// Make sure no GNSS_PAYMENTANNOUNCEMENT transaction is performed
								
                // Step 1:
                // Send Initiating_Apdu containing
                //		- exactly one valid PaymentAnnouncementADU, and
                //		- exactly one PaymentAnnouncementADU with actionCode=send containing
				//			- referenceDetailsList of the choice billingDetailsList containing
				//				- exactly one BillingDetailsId that does not make reference
				//					to the BillingDetailsADU of the previously performed BILLINGDETAILS transaction
                  
                // Step 2:  
                // Wait for NAck_Apdu({2,invalidADU(0)} within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdu
                
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU where the length of the referenceDetailsList is too long
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform GNSS_BILLINGDETAILS transaction with positive Ack in which the number of billingDetails
				// shall be (1+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX)	
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing
                //		- one valid PaymentAnnouncementADU, and
                //		- one PaymentAnnouncementADU with actionCode=send containing
                //			- referenceDetailsList of the choice billingDetailsList containing
                //				- exactly (1+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX) BillingDetailsId that makes reference to
                //					the BillingDetailsADUs of the previously performed BILLINGDETAILS transaction
                  
                // Step 2:  
                // Wait for NAck_Apdu({2,invalidADU(0)} within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdu
                
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU where the attachement is too big
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform one GNSS_BILLINGDETAILS transaction with positive Ack	
				// Wait until respective time constraints for starting next transaction are passed
				// Perform one GNSS_PAYMENTANNOUNCEMENT transaction with actionCode=send with positive Ack 
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing
                //		- one valid PaymentAnnouncementADU, and
                //		- one PaymentAnnouncementADU with actionCode=send containing an attachment larger than (2^31)–1 bytes
                  
                // Step 2:  
                // Wait for NAck_Apdu({2,invalidADU(0)} within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdu
                
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06: Verify that the TC correctly responds to
                *			an APDU containing too many PaymentAnnouncementADUs
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform GNSS_BILLINGDETAILS transaction with positive Ack in which the number of billingDetails
				// shall be (1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX)	
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing exactly (GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX+1) valid PaymentAnnouncementADUs 
                  
                // Step 2:  
                // Wait for NAck_Apdu with apduReasonCode=apduNotOK(3) within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdu
                
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06
			
		} // End group Invalid_Behaviour
		
	} // End group GNSS_PAYMENTANNOUNCEMENT	
	                		
} // End of module EfcInfoExchange_TestCasesTc
