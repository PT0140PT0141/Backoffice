/**
 * @author  PT0140 
 * @desc    This module provides test cases based on TS 16986 TPs
 * @see     [xxxx-1:2017]: Test suite structure and test purpose
 * @see     [xxxx-1:2016], Clause 5.2.1  Namimg conventions
 * @version $id$
 */
module EfcInfoExchange_TestCasesTspOld {
    /**
     * @desc    [12855:2015]: 
     * @see     Annex A (normative)  data type specifications
     */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     *          Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
     */
    import from Common_ParametrisedAsn1Data all;
    import from EfcInfoExchange_Interfaces all;
    import from EfcInfoExchange_Functions all;
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Ics all;
    import from EfcInfoExchange_Templates all;
	
    /**
     /**
      * @desc    These Test Cases apply to Toll Service Provider claiming conformance to [16986:2016] and applying Test Purposes as from TS xxxxx:2018 Annex B
      * @remark  nn TCs
      */
    group Base {
         /**
          * @desc    Test subgroup objective:
          * - to test IUT with respect to the correctness of base and general functionalities that are required in many or all transaction types;
          */
     	group Valid_Behaviour {
             /**
              * @desc    TP_TSP_Base_BV_01: Verify that a TC validates correct infoExchanceAuthenticators in received APDUs and generates correct infoExchangeAuthenticators 
              * @remark  [16986:2016], Clause 6.2.2 and Table A.1/2 
              */
             testcase TP_TSP_Base_BV_01() runs on IutComp system TestAdapter {
                 
             } // TP_TSP_Base_BV_01
        } // End of group Valid_Behaviour
         
        group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour
        
    } // End of group Base
    
	group USERDETAILS {
		group Valid_Behaviour {
			testcase TP_TSP_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
            	 	          
				/**
				 * @desc    TP_TSP_USERDETAILS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserDetailsADUs 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// we want to ask for a random number of parameters randomly chosen among those supported
				// the v_userParameterRequest array will be made of a random number of elements containing randomly picked up
				// parameter identifiers from the list of supported parameters (PIXIT value)
				const integer totNoParams := sizeof(USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS);
				const integer noParamsToUse := float2int(rnd() * int2float(totNoParams));
				var UserParameterRequest v_userParameterRequests[noParamsToUse];   
				for (var integer v_ct :=0; v_ct<noParamsToUse;v_ct:=v_ct+1) {
					//Note: float2int removes the fractional part and returns just the integer, it is NOT a rounding function. That is why this works
					v_userParameterRequests[v_ct] := USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS[float2int(rnd()) * totNoParams];
				};
                
				// Step1: send RequestADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests)}
					)
				);
                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						// TODO PT140: Check the ADU record and find the one we are expecting. Either function or template
 
						//Set verdict
						setverdict(pass);
 					    			                              
						// Step3: Send DefaultAck with correct identifier and set verdict
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));

					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TSP_USERDETAILS_BV_01
            
			testcase TP_TSP_USERDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_USERDETAILS_BV_02: TP_TSP_USERDETAILS_BV_02: Verify that the TSP correctly receives a RequestADU of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of data privacy issues  
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequests v_userParameterRequests := PRIVACYBOUND_LIST_OF_PARAMETERS;   
				// Check if there are parameters that are privacy bound
				// If not, exit test
				if (sizeof (v_userParameterRequests) == 0) {
					setverdict(inconclusive);
					f_addLogEntry("Privacy bound parameters missing. Test cannot be executed");
					stop
					};
                
				// Step1: send RequestADU
				// f_SendAPDU does all necessary filling of fields (if not already done in the template), sends the APDU, logs it together with time
				
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(
					m_apduNoSecInit(v_apduRespondedTo)
				);   	  
                                
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU or the timeout expires
				// timeout expiration is handled in the altstep branch
				// The received Provide Use Details ADU shall have status flag = 2, and an empty list of user details
				// TODO PT140: Check whether the parameterisation of the mw_apduProvideUserDetails template is correct

				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails(v_apduRespondedTo)) -> value v_apduReceived{

						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;
						                        
						//Set verdict
						setverdict(pass);
						if sizeof(v_apduReceived.adus.provideUserDetailsADUs) > 1 {
						  setverdict (fail);
						  stop;
						}
						if (not match(
							v_apduReceived.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU: modifies mw_aduProvideUserDetails := {
								statusFlag:=2,
								listOfUserParameters := omit
							}
						)) setverdict(fail);
							
						// Step3: Send DefaultAck with correct identifier
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TSP_USERDETAILS_BV_02
		} // End of group Valid_Behaviour
        
		group Invalid_Behaviour {
		  testcase TP_TSP_USERDETAILS_BI_01() runs on MainTestComponent system TestAdapter {
             
			  /**
			  * @desc    TP_TSP_USERDETAILS_BI_01: Verify that the TSP correctly responds to an incorrect RequestADU of type userDetailsRequest 
			  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
			  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
             
				// Step 1: Send two incorrect ADUs with 2 incorrect ADUs
				// TODO PT140: The two incorrect ADUs are identical, because there is no way to send an empty structure as requested by the Test Purpose
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(v_apduRespondedTo);                               

				// Step 2: wait for a Semantic Error code Nack 

				t_step.start(USERDETAILS_TIME1_MAX_TSP)

				// Either we receive an APDU containing Nack with semantic error as error code or the timeout expires
				// timeout expiration handling is in the altstep branch				

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();  

			 } // End of testcase TP_TSP_USERDETAILS_BI_01
            
			testcase TP_TSP_USERDETAILS_BI_02() runs on MainTestComponent system TestAdapter {
            
			  /**
			  * @desc    TP_TSP_USERDETAILS_BI_02: Verify that the TSP correctly handles a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing non-supported user details
			  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
			  */          
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
             

				// Front End shall initially receive a Request named as Transaction sequence #1
				// Find a parameter whose value  is not supported by the IUT
				v_SupportedParameters := SUPPORTED_LIST_OF_PARAMETERS;
				// Prepare the list of requested parameters with one element which is unsupported
				found := false;
				for (var integer v_Support :=0;  v_Support:=v_Support+1, found := false)
					for (var integer v_ind := 0, v_ind < sizeof(SUPPORTED_LIST_OF_PARAMETERS), v_ind := v_ind + 1)
						if NOT( v_SupportedParameters[v_IND]  := v_Support) v_unsupported := v_Support; found := true; break;
						continue;
					continue;				
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(
					m_apduNoSecInit(v_apduRespondedTo)
				);                              
                                
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU or the timeout expires
				// timeout expiration is handled in the altstep branch
				// The received Provide Use Details ADU shall have status flag = 1, and no  list of user details

				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails(v_apduRespondedTo)) -> value v_apduReceived{

						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;
						
                        
						//Set verdict
						setverdict(pass);
						if (sizeof(v_apduReceived.adus.provideUserDetailsADUs) > 1 )
						  {
							setverdict (fail);
							stop;
						  }
						if (not match(
							v_apduReceived.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU: modifies mw_aduProvideUserDetails := {
								statusFlag:=1,
								listOfUserParameters := omit,
								userInfoValidityPeriod := omit
							}
						)) 
						{
						  setverdict(fail);
						  stop;
						  }
							
						// Step3: Send DefaultAck with correct identifier
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
						}
					} // End of alt statement
                
				f_closeDownMtc();  
                			
				} // End of testcase TP_TSP_USERDETAILS_BI_02 

            testcase TP_TSP_USERDETAILS_BI_03() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_03: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of missing agreement
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */       

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequests v_userParameterRequests := USERDETAILS_NOT_AGREED_LIST;   
				// Check if there are parameters that are privacy bound
				// If not, exit test
				if (sizeof (v_userParameterRequests) == 0) {
					setverdict(inconclusive);
					f_addLogEntry("Not agreed parameters missing. Test cannot be executed");
					stop
					};
                
				// Step1: send RequestADU
				// f_SendAPDU does all necessary filling of fields (if not already done in the template), sends the APDU, logs it together with time
				
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(
					m_apduNoSecInit(v_apduRespondedTo)
				);   	  
                                		
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);

}               // Step #2: Wait for empty User Details
// Either we receive an APDU containing empty User Details or the timeout expires
// timeout expiration handling is in the altstep branch	
                alt {
					[] mtcPort.receive(mw_apduProvideUserDetails(v_apduRespondedTo)) -> value v_apduReceived{

						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;
						                        
						//Set verdict
						setverdict(pass);
						if sizeof(v_apduReceived.adus.provideUserDetailsADUs) > 1 {
						  setverdict (fail);
						  stop;
						}
						if (not match(
							v_apduReceived.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU: modifies mw_aduProvideUserDetails := {
								userId := omit,
								statusFlag:=2,
								listOfUserParameters := omit
							}
						)) setverdict(fail);
                    }
                } // End of alt statement

				f_closeDownMtc();  
 
            } // End of TP_TSP_USERDETAILS_BI_03
            
            testcase TP_TSP_USERDETAILS_BI_04() runs on IutComp system TestAdapter {

             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_04: Verify that a TSP responds correctly to a RequestADU sent earlier than allowed 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// we want to ask for a random number of parameters randomly chosen among those supported
				// the v_userParameterRequest array will be made of a random number of elements containing randomly picked up
				// parameter identifiers from the list of supported parameters (PIXIT value)
				const integer totNoParams := sizeof(USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS);
				const integer noParamsToUse := float2int(rnd() * int2float(totNoParams));
				var UserParameterRequest v_userParameterRequests[noParamsToUse];   
				for (var integer v_ct :=0; v_ct<noParamsToUse;v_ct:=v_ct+1) {
					//Note: float2int removes the fractional part and returns just the integer, it is NOT a rounding function. That is why this works
					v_userParameterRequests[v_ct] := USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS[float2int(rnd()) * totNoParams];
				};
                
				// Step1: send RequestADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests)}
					)
				);
       			// Send again immediately same ADU with different  valid user
				var InfoExchange v_apduToSend := m_apduNoSecInit(
					{modifies m_aduProvideUserDetails:= {
					  	userId:= EMPTYLIST_USER_ID
					  	}
					});
				f_sendAndLogApdu(v_apduToSend);

                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					[] mtcPort.receive(m_apduNAck_requestSentTooOften(v_apduToSend)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
                } // End of alt statement
				f_closeDownMtc();  			
                
        	} // End of TP_TSP_USERDETAILS_BI_04

        } // End of group Invalid_Behaviour
 
    } // End of group USERDETAILS

    group LISTOFUSERS {
         group Valid_Behaviour {

             testcase TP_TSP_LISTOFUSERS_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserIdListADUs with available user Id data 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestListOfUsers});
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestListOfUsers}
					)
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for UserList ADU
				// Either we receive an APDU containing  User List ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch

                 alt {
                      [] mtcPort.receive(mw_apduListOfUsers(v_apduRespondedTo)) -> value v_apduReceived {
                      		
						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;

						//Set verdict
						setverdict(pass);
 						
 						//	Check whether the list of users contains elements
 						// If not, set verdict fail
 						                              
                        If (lengthof(v_apduReceived.adus.provideUserIdListADUs.userIdList) = 0) {
                          f_addLogEntry("Empty user list received");
                          setverdict(fail);
                          stop;
                        };
                        If (v_apduReceived.adus.provideUserIdListADUs.userId <> DEFINED_USER_ID) {
                          f_addLogEntry("Wrong User ID received");
                          setverdict(fail);
                          stop;
                        };
                        
                        // Step #3: Send DefaultACK with correct identifier
                        
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
                      }
                    } // End of alt statement
				
				f_closeDownMtc();  

             } // End of TP_TSP_LISTOFUSERS_BV_01           

             testcase TP_TSP_LISTOFUSERS_BV_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BV_02: Verify that the TSP correctly receives an APDU containing valid RequestADUs to user Id data not available and provides valid ProvideUserIdListADUs 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= EMPTYLIST_USER_ID
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= EMPTYLIST_USER_ID
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for UserList ADU
				// Either we receive an APDU containing  User List ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch

                 alt {
                      [] mtcPort.receive(mw_apduListOfUsers(v_apduRespondedTo)) -> value v_apduReceived {
                      		
						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;

						//Set verdict
						setverdict(pass);
 						
 						//	Check whether the list of users contains elements
 						// If yes, set verdict fail
 						                              
                        If (lengthof(v_apduReceived.adus.provideUserIdListADUs.userIdList) > 0) {
                          f_addLogEntry("Not empty user list received");
                          setverdict(fail);
                          stop;
                        };
                        If (v_apduReceived.adus.provideUserIdListADUs.userId <> EMPTYLIST_USER_ID) {
                          f_addLogEntry("Wrong User ID received");
                          setverdict(fail);
                          stop;
                        };
                        
                        // Step #3: Send DefaultACK with correct identifier
                        
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
                      }
                    } // End of alt statement
				
				f_closeDownMtc();  

             } // End of TP_TSP_LISTOFUSERS_BV_02  		
 		
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
			  testcase TP_TSP_LISTOFUSERS_BI_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_01: Verify that the TSP correctly receives an invalid requestADU with userIdRequestType ≠ 0 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestType := float2int(rnd() * 254) + 1
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestType:= float2int(rnd() * 254) + 1
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();  			
			} // End of TP_TSP_LISTOFUSERS_BI_01
             
			  testcase TP_TSP_LISTOFUSERS_BI_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_02: Verify that the TSP correctly receives an invalid request ADU with no PAN, LicensePlateNumber, OBEID or ContractSerialNumber present in the userId field 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId := {}
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= {}
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();		
             } // End of TP_TSP_LISTOFUSERS_BI_02
             
			  testcase TP_TSP_LISTOFUSERS_BI_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_03: Verify that the TSP correctly receives an invalid request ADU with userIdRequestTime not present 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation

				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime := omit
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime:= omit
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();				
			} // End of TP_TSP_LISTOFUSERS_BI_03
             
			  testcase TP_TSP_LISTOFUSERS_BI_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_04: Verify that the TSP correctly receives an invalid request ADU with invalid userIdRequestTime 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */

				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduToSend := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime := now + 1000.0
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime:= now + 1000.0
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
             } // End of TP_TSP_LISTOFUSERS_BI_04
             
			  testcase TP_TSP_LISTOFUSERS_BI_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_05: Verify that a TSP responds correctly to a RequestADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestListOfUsers}
					)
				);

				// Send again immediately same ADU with different  valid user
				var InfoExchange v_apduToSend := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= EMPTYLIST_USER_ID
					  	}
					});
				f_sendAndLogApdu(v_apduToSend);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					[] mtcPort.receive(m_apduNAck_requestSentTooOften(v_apduToSend)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
                } // End of alt statement
				f_closeDownMtc();  			

             } // End of TP_TSP_LISTOFUSERS_BI_05
                      
           } // End of group Invalid_Behaviour
        
    } // End of group LISTOFUSERS
    
    group EXCEPTIONLIST {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group EXCEPTIONLIST
    
    group TRUSTOBJECTS {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group TRUSTOBJECTS
    
    group PAYMENTCLAIM {
         group Valid_Behaviour {
            testcase TP_TSP_PaymentClaim_BV_01() runs on IutComp system TestAdapter {
                   /**    
				  * @desc	TP_TSP_PAYMENTCLAIM_BV_01: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when using the actionCode=send 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5 
                  */
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                
                } // End of TP_TSP_PAYMENTCLAIM_BV_01
                
            testcase TP_TSP_PaymentClaim_BV_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BV_02: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when using the actionCode=revoke or adjust 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5 
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                
                } // End of TP_TSP_PAYMENTCLAIM_BV_02
                


 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
            testcase TP_TSP_PaymentClaim_BI_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_01: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect paymentClaimId 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_01           		

            testcase TP_TSP_PaymentClaim_BI_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_02: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect paymentClaimStatus 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_02           		

            testcase TP_TSP_PaymentClaim_BI_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_03: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect referenceDetailsList 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_03           		

            testcase TP_TSP_PaymentClaim_BI_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_04: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect actionCode 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_04   

            testcase TP_TSP_PaymentClaim_BI_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_05: Getting provoked by various errors with defined specific responses  
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_05   

            testcase TP_TSP_PaymentClaim_BI_06() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_06: Verify that a TSP responds correctly to a PaymentClaimADU sent earlier than allowed  
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_06  
        } // End of group Invalid_Behaviour

    } // End of group PAYMENTCLAIM
    
    group DSRC_CONTRACTISSUERLIST {
         group Valid_Behaviour {
           testcase TP_TSP_CONTRACTISSUERLIST_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_CONTRACTISSUERLIST_BV_01: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when using the actionCode=revoke or adjust 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
                  
                 // Local variables
                var InfoExchangeContent v_infoExchangeContent;
                var InfoExchange v_infoExchange;
                var requestAdus v_Request;
                var ackAdus v_Ack; 
                
                } // End of TP_TSP_CONTRACTISSUERLIST_BV_01
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.CONTRACTISSUERLIST
    
    group DSRC_EFCCONTEXTDATA {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.EFCCONTEXTDATA
    
    group DSRC_BILLINGDETAILS {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.BILLINGDETAILS
    
    group DSRC_REPORTABNORMALOBE {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.REPORTABNORMALOBE
    
    group GNSS_TOLLDECLARATION {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.TOLLDECLARATION
    group GNSS_BILLINGDETAILS_TSP {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS_TSP
    
    group GNSS_BILLINGDETAILS_TC {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS.TC
    
    group GNSS_PAYMENTANNOUNCEMENT {
         group Valid_Behaviour {
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.PAYMENTANNOUNCEMENT
} // End of module Toll_Service_Provider
