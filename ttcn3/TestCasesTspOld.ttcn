/**
 * @author  PT0140 
 * @desc    This module provides test cases based on TS 16986 TPs
 * @see     [xxxx-1:2017]: Test suite structure and test purpose
 * @see     [xxxx-1:2016], Clause 5.2.1  Namimg conventions
 * @version $id$
 */
module EfcInfoExchange_TestCasesTspOld {
    /**
     * @desc    [12855:2015]: 
     * @see     Annex A (normative)  data type specifications
     */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     *          Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
     */
    import from Common_ParametrisedAsn1Data all;
    import from EfcInfoExchange_Interfaces all;
    import from EfcInfoExchange_Functions all;
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Ics all;
    import from EfcInfoExchange_Templates all;
	
    /**
     /**
      * @desc    These Test Cases apply to Toll Service Provider claiming conformance to [16986:2016] and applying Test Purposes as from TS xxxxx:2018 Annex B
      * @remark  nn TCs
      */
    group Base {
         /**
          * @desc    Test subgroup objective:
          * - to test IUT with respect to the correctness of base and general functionalities that are required in many or all transaction types;
          */
     	group Valid_Behaviour {
             /**
              * @desc    TP_TSP_Base_BV_01: Verify that a TC validates correct infoExchanceAuthenticators in received APDUs and generates correct infoExchangeAuthenticators 
              * @remark  [16986:2016], Clause 6.2.2 and Table A.1/2 
              */
             testcase TP_TSP_Base_BV_01() runs on IutComp system TestAdapter {
                 
             } // TP_TSP_Base_BV_01
        } // End of group Valid_Behaviour
         
        group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour
        
    } // End of group Base
    
	group USERDETAILS {
		group Valid_Behaviour {
			testcase TP_TSP_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
            	 	          
				/**
				 * @desc    TP_TSP_USERDETAILS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserDetailsADUs 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// we want to ask for a random number of parameters randomly chosen among those supported
				// the v_userParameterRequest array will be made of a random number of elements containing randomly picked up
				// parameter identifiers from the list of supported parameters (PIXIT value)
				const integer totNoParams := sizeof(USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS);
				const integer noParamsToUse := float2int(rnd() * int2float(totNoParams));
				var UserParameterRequest v_userParameterRequests[noParamsToUse];   
				for (var integer v_ct :=0; v_ct<noParamsToUse;v_ct:=v_ct+1) {
					//Note: float2int removes the fractional part and returns just the integer, it is NOT a rounding function. That is why this works
					v_userParameterRequests[v_ct] := USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS[float2int(rnd()) * totNoParams];
				};
                
				// Step1: send RequestADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests)}
					)
				);
                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						// TODO PT140: Check the ADU record and find the one we are expecting. Either function or template
 
						//Set verdict
						setverdict(pass);
 					    			                              
						// Step3: Send DefaultAck with correct identifier and set verdict
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));

					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TSP_USERDETAILS_BV_01
            
			testcase TP_TSP_USERDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_USERDETAILS_BV_02: TP_TSP_USERDETAILS_BV_02: Verify that the TSP correctly receives a RequestADU of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of data privacy issues  
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequests v_userParameterRequests := PRIVACYBOUND_LIST_OF_PARAMETERS;   
				// Check if there are parameters that are privacy bound
				// If not, exit test
				if (sizeof (v_userParameterRequests) == 0) {
					setverdict(inconclusive);
					f_addLogEntry("Privacy bound parameters missing. Test cannot be executed");
					stop
					};
                
				// Step1: send RequestADU
				// f_SendAPDU does all necessary filling of fields (if not already done in the template), sends the APDU, logs it together with time
				
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(
					m_apduNoSecInit(v_apduRespondedTo)
				);   	  
                                
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU or the timeout expires
				// timeout expiration is handled in the altstep branch
				// The received Provide Use Details ADU shall have status flag = 2, and an empty list of user details
				// TODO PT140: Check whether the parameterisation of the mw_apduProvideUserDetails template is correct

				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails(v_apduRespondedTo)) -> value v_apduReceived{

						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;
						                        
						//Set verdict
						setverdict(pass);
						if sizeof(v_apduReceived.adus.provideUserDetailsADUs) > 1 {
						  setverdict (fail);
						  stop;
						}
						if (not match(
							v_apduReceived.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU modifies mw_aduProvideUserDetails := {
								statusFlag:=2,
								listOfUserParameters := omit
							}
						)) setverdict(fail);
							
						// Step3: Send DefaultAck with correct identifier
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TSP_USERDETAILS_BV_02
		} // End of group Valid_Behaviour
        
		group Invalid_Behaviour {
		  testcase TP_TSP_USERDETAILS_BI_01() runs on MainTestComponent system TestAdapter {
             
			  /**
			  * @desc    TP_TSP_USERDETAILS_BI_01: Verify that the TSP correctly responds to an incorrect RequestADU of type userDetailsRequest 
			  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
			  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
             
				// Step 1: Send two incorrect ADUs with 2 incorrect ADUs
				// TODO PT140: The two incorrect ADUs are identical, because there is no way to send an empty structure as requested by the Test Purpose
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(v_apduRespondedTo);                               

				// Step 2: wait for a Semantic Error code Nack 

				t_step.start(USERDETAILS_TIME1_MAX_TSP)

				// Either we receive an APDU containing Nack with semantic error as error code or the timeout expires
				// timeout expiration handling is in the altstep branch				

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}};
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduRespondedTo, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();  

			 } // End of testcase TP_TSP_USERDETAILS_BI_01
            
			testcase TP_TSP_USERDETAILS_BI_02() runs on MainTestComponent system TestAdapter {
            
			  /**
			  * @desc    TP_TSP_USERDETAILS_BI_02: Verify that the TSP correctly handles a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing non-supported user details
			  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
			  */          
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
             

				// Front End shall initially receive a Request named as Transaction sequence #1
				// Find a parameter whose value  is not supported by the IUT
				v_SupportedParameters := SUPPORTED_LIST_OF_PARAMETERS;
				// Prepare the list of requested parameters with one element which is unsupported
				found := false;
				for (var integer v_Support :=0;  v_Support:=v_Support+1, found := false)
					for (var integer v_ind := 0, v_ind < sizeof(SUPPORTED_LIST_OF_PARAMETERS), v_ind := v_ind + 1)
						if NOT( v_SupportedParameters[v_IND]  := v_Support) v_unsupported := v_Support; found := true; break;
						continue;
					continue;				
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(
					m_apduNoSecInit(v_apduRespondedTo)
				);                              
                                
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU or the timeout expires
				// timeout expiration is handled in the altstep branch
				// The received Provide Use Details ADU shall have status flag = 1, and no  list of user details

				alt {
					[] mtcPort.receive(mw_apduProvideUserDetails(v_apduRespondedTo)) -> value v_apduReceived{

						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;
						
                        
						//Set verdict
						setverdict(pass);
						if (sizeof(v_apduReceived.adus.provideUserDetailsADUs) > 1 )
						  {
							setverdict (fail);
							stop;
						  }
						if (not match(
							v_apduReceived.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU: modifies mw_aduProvideUserDetails := {
								statusFlag:=1,
								listOfUserParameters := omit,
								userInfoValidityPeriod := omit
							}
						)) 
						{
						  setverdict(fail);
						  stop;
						  }
							
						// Step3: Send DefaultAck with correct identifier
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
						}
					} // End of alt statement
                
				f_closeDownMtc();  
                			
				} // End of testcase TP_TSP_USERDETAILS_BI_02 

            testcase TP_TSP_USERDETAILS_BI_03() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_03: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of missing agreement
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */       

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var UserParameterRequests v_userParameterRequests := USERDETAILS_NOT_AGREED_LIST;   
				// Check if there are parameters that are privacy bound
				// If not, exit test
				if (sizeof (v_userParameterRequests) == 0) {
					setverdict(inconclusive);
					f_addLogEntry("Not agreed parameters missing. Test cannot be executed");
					stop
					};
                
				// Step1: send RequestADU
				// f_SendAPDU does all necessary filling of fields (if not already done in the template), sends the APDU, logs it together with time
				
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})});
				f_sendAndLogApdu(
					m_apduNoSecInit(v_apduRespondedTo)
				);   	  
                                		
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);

               // Step #2: Wait for empty User Details
				// Either we receive an APDU containing empty User Details or the timeout expires
				// timeout expiration handling is in the altstep branch	
                alt {
					[] mtcPort.receive(mw_apduProvideUserDetails(v_apduRespondedTo)) -> value v_apduReceived{

						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;
						                        
						//Set verdict
						setverdict(pass);
						if sizeof(v_apduReceived.adus.provideUserDetailsADUs) > 1 {
						  setverdict (fail);
						  stop;
						}
						if (not match(
							v_apduReceived.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU: modifies mw_aduProvideUserDetails := {
								userId := omit,
								statusFlag:=2,
								listOfUserParameters := omit
							}
						)) setverdict(fail);
                    }
                } // End of alt statement

				f_closeDownMtc();  
 
            } // End of TP_TSP_USERDETAILS_BI_03
            
            testcase TP_TSP_USERDETAILS_BI_04() runs on IutComp system TestAdapter {

             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_04: Verify that a TSP responds correctly to a RequestADU sent earlier than allowed 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// we want to ask for a random number of parameters randomly chosen among those supported
				// the v_userParameterRequest array will be made of a random number of elements containing randomly picked up
				// parameter identifiers from the list of supported parameters (PIXIT value)
				const integer totNoParams := sizeof(USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS);
				const integer noParamsToUse := float2int(rnd() * int2float(totNoParams));
				var UserParameterRequest v_userParameterRequests[noParamsToUse];   
				for (var integer v_ct :=0; v_ct<noParamsToUse;v_ct:=v_ct+1) {
					//Note: float2int removes the fractional part and returns just the integer, it is NOT a rounding function. That is why this works
					v_userParameterRequests[v_ct] := USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS[float2int(rnd()) * totNoParams];
				};
                
				// Step1: send RequestADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests)}
					)
				);
       			// Send again immediately same ADU with different  valid user
				var InfoExchange v_apduToSend := m_apduNoSecInit(
					{modifies m_aduProvideUserDetails:= {
					  	userId:= EMPTYLIST_USER_ID
					  	}
					});
				f_sendAndLogApdu(v_apduToSend);

                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					[] mtcPort.receive(m_apduNAck_requestSentTooOften(v_apduToSend)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
                } // End of alt statement
				f_closeDownMtc();  			
                
        	} // End of TP_TSP_USERDETAILS_BI_04

        } // End of group Invalid_Behaviour
 
    } // End of group USERDETAILS

    group LISTOFUSERS {
         group Valid_Behaviour {

             testcase TP_TSP_LISTOFUSERS_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserIdListADUs with available user Id data 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit({m_aduRequestListOfUsers});
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestListOfUsers}
					)
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for UserList ADU
				// Either we receive an APDU containing  User List ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch

                 alt {
                      [] mtcPort.receive(mw_apduListOfUsers(v_apduRespondedTo)) -> value v_apduReceived {
                      		
						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;

						//Set verdict
						setverdict(pass);
 						
 						//	Check whether the list of users contains elements
 						// If not, set verdict fail
 						                              
                        If (lengthof(v_apduReceived.adus.provideUserIdListADUs.userIdList) = 0) {
                          f_addLogEntry("Empty user list received");
                          setverdict(fail);
                          stop;
                        };
                        If (v_apduReceived.adus.provideUserIdListADUs.userId <> DEFINED_USER_ID) {
                          f_addLogEntry("Wrong User ID received");
                          setverdict(fail);
                          stop;
                        };
                        
                        // Step #3: Send DefaultACK with correct identifier
                        
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
                      }
                    } // End of alt statement
				
				f_closeDownMtc();  

             } // End of TP_TSP_LISTOFUSERS_BV_01           

             testcase TP_TSP_LISTOFUSERS_BV_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BV_02: Verify that the TSP correctly receives an APDU containing valid RequestADUs to user Id data not available and provides valid ProvideUserIdListADUs 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= EMPTYLIST_USER_ID
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= EMPTYLIST_USER_ID
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for UserList ADU
				// Either we receive an APDU containing  User List ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch

                 alt {
                      [] mtcPort.receive(mw_apduListOfUsers(v_apduRespondedTo)) -> value v_apduReceived {
                      		
						// Log what we received 					
						f_logApduReceivedAndTStep();

						// Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
						t_step.stop;

						//Set verdict
						setverdict(pass);
 						
 						//	Check whether the list of users contains elements
 						// If yes, set verdict fail
 						                              
                        If (lengthof(v_apduReceived.adus.provideUserIdListADUs.userIdList) > 0) {
                          f_addLogEntry("Not empty user list received");
                          setverdict(fail);
                          stop;
                        };
                        If (v_apduReceived.adus.provideUserIdListADUs.userId <> EMPTYLIST_USER_ID) {
                          f_addLogEntry("Wrong User ID received");
                          setverdict(fail);
                          stop;
                        };
                        
                        // Step #3: Send DefaultACK with correct identifier
                        
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
                      }
                    } // End of alt statement
				
				f_closeDownMtc();  

             } // End of TP_TSP_LISTOFUSERS_BV_02  		
 		
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
			  testcase TP_TSP_LISTOFUSERS_BI_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_01: Verify that the TSP correctly receives an invalid requestADU with userIdRequestType ≠ 0 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestType := float2int(rnd() * 254) + 1
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestType:= float2int(rnd() * 254) + 1
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();  			
			} // End of TP_TSP_LISTOFUSERS_BI_01
             
			  testcase TP_TSP_LISTOFUSERS_BI_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_02: Verify that the TSP correctly receives an invalid request ADU with no PAN, LicensePlateNumber, OBEID or ContractSerialNumber present in the userId field 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId := {}
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= {}
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();		
             } // End of TP_TSP_LISTOFUSERS_BI_02
             
			  testcase TP_TSP_LISTOFUSERS_BI_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_03: Verify that the TSP correctly receives an invalid request ADU with userIdRequestTime not present 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation

				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime := omit
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime:= omit
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
				f_closeDownMtc();				
			} // End of TP_TSP_LISTOFUSERS_BI_03
             
			  testcase TP_TSP_LISTOFUSERS_BI_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_04: Verify that the TSP correctly receives an invalid request ADU with invalid userIdRequestTime 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */

				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var InfoExchange v_apduToSend := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime := now + 1000.0
						}
					});
				f_sendAndLogApdu(
					m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userIdRequestTime:= now + 1000.0
						}
					})
				);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					//PT140 TODO Can the repetion in the two alts be reduced?
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams2)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
				} 
             } // End of TP_TSP_LISTOFUSERS_BI_04
             
			  testcase TP_TSP_LISTOFUSERS_BI_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_05: Verify that a TSP responds correctly to a RequestADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestListOfUsers}
					)
				);

				// Send again immediately same ADU with different  valid user
				var InfoExchange v_apduToSend := m_apduNoSecInit(
					{modifies m_aduRequestListOfUsers:= {
					  	userId:= EMPTYLIST_USER_ID
					  	}
					});
				f_sendAndLogApdu(v_apduToSend);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch

				//Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}}
				var NAckParams v_nAckParams2 :={{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}}
				
				alt {
					[] mtcPort.receive(m_apduNAck_requestSentTooOften(v_apduToSend)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(LISTOFUSERS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set verdict
						setverdict(pass);
					}
                } // End of alt statement
				f_closeDownMtc();  			

             } // End of TP_TSP_LISTOFUSERS_BI_05
                      
           } // End of group Invalid_Behaviour
        
    } // End of group LISTOFUSERS
    
    group EXCEPTIONLIST {
         group Valid_Behaviour {
           testcase TP_TSP_EXCEPTIONLIST_BV_01() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_EXCEPTIONLIST_BV_01: Verify that the TSP correctly performs an EXCEPTIONLIST transaction for blacklist and whitelist 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 AND Table A.7/3 
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Start by setting test failure
				setverdict(fail);
				// Step 1a: Trigger IUT with EXCEPTIONLIST.TR_TSP_1 LIST_TYPE=BLACK
				// PT140 TODO: Need a way to specify a Black list
				f_sendAndLogTrigger(EXCEPTIONLIST_TR_TSP_1);
				//  Wait for EXCEPTIONLIST with LIST_TYPE=BLACK
				alt {
					[] mtcPort.receive(mw_apduExceptionList modifies mw_aduExceptionList := {exceptionListType := ExceptionListType_blackList_}) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               		
					// Send Ack within time constraints
					f_wait(EXCEPTIONLIST_TIME1_TC);
					f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
					} // End of first alt statement
					
					// Step 1b: Trigger IUT with EXCEPTIONLIST.TR_TSP_1 LIST_TYPE=WHITE within time constraints
					// PT140 TODO: Need a way to specify a White list
					f_sendAndLogTrigger(EXCEPTIONLIST_TR_TSP_1);
					//  Wait for EXCEPTIONLIST with LIST_TYPE=WHITE
					alt {
						[] mtcPort.receive(mw_apduExceptionList modifies mw_aduExceptionList := {exceptionListType := ExceptionListType_whiteList_}) -> value v_apduReceived {
							// Log what we received
							f_logApduReceivedAndTStep();					
							}
					
						// Send Ack within time constraints
						f_wait(EXCEPTIONLIST_TIME1_TC);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						
						// Set test success
						setverdict(pass);						
 						} // End of second alt statement
				f_closeDownMtc();   						           
           } // End of TP_TSP_EXCEPTIONLIST_BV_01
           
           testcase TP_TSP_EXCEPTIONLIST_BV_02() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_EXCEPTIONLIST_BV_02: Verify that the TSP correctly performs an EXCEPTIONLIST transaction for discounted users 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 AND Table A.7/3 
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Start by setting test failure
				setverdict(fail);
				// Step 1: Trigger IUT with EXCEPTIONLIST.TR_TSP_1 LIST_TYPE=DISCOUNT
				// PT140 TODO: Need a way to specify a Discount list
				f_sendAndLogTrigger(EXCEPTIONLIST_TR_TSP_1);
				//  Wait for EXCEPTIONLIST with LIST_TYPE=DISCOUNT
				alt {
					[] mtcPort.receive(mw_apduExceptionList modifies mw_aduExceptionList := {exceptionListType := ExceptionListType_discountList_}) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						}
               			if (not ispresent(v_apduReceived.adus.ExceptionListADU.exceptionListEntries.ExceptionListEntry.vatId)) {
               				// Send NAck within time constraints
							var NAckParams v_nAckParams1 :={{0, AduReasonCode_invalidADU_}};
							f_wait(EXCEPTIONLIST_TIME1_TC);
							f_sendAndLogApdu(m_apduNAck(v_apduReceived, v_nAckParams1));   
               				}
               			else {
							// Send Ack within time constraints
							f_wait(EXCEPTIONLIST_TIME1_TC);
							f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived)); 			
							// Set test success
							setverdict(pass);
               				};
					} // End of alt statement
				
				f_closeDownMtc(); 
				              
           } // End of TP_TSP_EXCEPTIONLIST_BV_02
 		
 		
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {	
           // No Invalid Behaviour Test Cases defined	
        } // End of group Invalid_Behaviour

    } // End of group EXCEPTIONLIST
    
    group TRUSTOBJECTS {
         group Valid_Behaviour {
           testcase TP_TSP_TRUSTOBJECTS_BV_01() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BV_01: Verify that the TSP correctly provides a TrustObjectADU without TC request 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              */
				// Initialisation
             
           } // End of TP_TSP_TRUSTOBJECTS_BV_01

           testcase TP_TSP_TRUSTOBJECTS_BV_02() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BV_02: Verify that the TSP correctly responds to a TrustObjectADU received from a TC without having issued a request 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              */
				// Initialisation
             
           } // End of TP_TSP_TRUSTOBJECTS_BV_02

           testcase TP_TSP_TRUSTOBJECTS_BV_03() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BV_03: Verify that the TSP correctly provides a TrustObjectADU following a TC request 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              */
				// Initialisation
             
           } // End of TP_TSP_TRUSTOBJECTS_BV_03

           testcase TP_TSP_TRUSTOBJECTS_BV_04() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BV_04: Verify that the TSP correctly requests and responds to a TrustObjectADU
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              */
				// Initialisation
             
           } // End of TP_TSP_TRUSTOBJECTS_BV_04
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_TRUSTOBJECTS_BI_01() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_01: Verify that the TSP correctly responds to a TrustObjectADU received without having issued a request and containing incorrect ADU parameters
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              */
				// Initialisation
             
           } // End of TP_TSP_TRUSTOBJECTS_BI_01

           testcase TP_TSP_TRUSTOBJECTS_BI_02() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_02: Verify that the TSP correctly responds to more than one correct Trust Object ADUs in the same APDU without having issued a request
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              */
				// Initialisation
             
           } // End of TP_TSP_TRUSTOBJECTS_BI_02

           testcase TP_TSP_TRUSTOBJECTS_BI_03() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_03: Verify that the TSP correctly responds to a not supported Trust Object
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              */
				// Initialisation
             
           } // End of TP_TSP_TRUSTOBJECTS_BI_03

           testcase TP_TSP_TRUSTOBJECTS_BI_04() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_04: Verify that the TSP correctly responds to a RequestADU sent earlier than allowed
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              */
				// Initialisation
             
           } // End of TP_TSP_TRUSTOBJECTS_BI_04

           testcase TP_TSP_TRUSTOBJECTS_BI_05() IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_TRUSTOBJECTS_BI_05: Verify that the TSP correctly responds to a TrustObjectADU sent earlier than allowed
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
              */
				// Initialisation
             
           } // End of TP_TSP_TRUSTOBJECTS_BI_05
           		
        } // End of group Invalid_Behaviour

    } // End of group TRUSTOBJECTS
    
    group PAYMENTCLAIM {
         group Valid_Behaviour {
            testcase TP_TSP_PaymentClaim_BV_01() runs on IutComp system TestAdapter {
                   /**    
				  * @desc	TP_TSP_PAYMENTCLAIM_BV_01: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when using the actionCode=send 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5 
                  */
 				// Initialisation
                 
                // PT 140: TODO Probably there is no need to have an initial PAYMENTCLAIM for this test case as stated in the TSS&TP
				// Start by setting test success
				
                // Step 1: Loop
                	// Send one preset Billing Details
                	// Wait for Ack
                	// Send PAYMENTCLAIM with ActionCode=SEND and changing:
                		// UserId within declared valid values
                		// vatRate present and not present
                		// valid values of TypeOfFee
                		// paymentReference valid and not present
              		// Wait for Ack (if negative Ack or not received set test failure)
              		
                
                } // End of TP_TSP_PAYMENTCLAIM_BV_01
                
            testcase TP_TSP_PaymentClaim_BV_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BV_02: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when using the actionCode=revoke or adjust 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5 
                  */
                  
                 // Initialisation 
                // PT 140: TODO It is not possible to send two PAYMENTCLAM Adus in the same APDU as stated in the TSS&TP
				// Start by setting test success
                // Send one preset Billing Details
                // Wait for positive Ack
				// Send one PAYMENTCLAIM related to the sent BILLINGDETAILS within allowed time constraints
				// Wait for positive Ack

                // Step 1:
                	// Send PAYMENTCLAIM with ActionCode=ADJUST referring to the previoulsy sent PAYMENTCLAIM and changing the charged value
              		// Wait for Ack (if negative Ack or not received set test failure)
                	// Send PAYMENTCLAIM with ActionCode=REVOKE referring to the previoulsy sent PAYMENTCLAIM
              		// Wait for Ack (if negative Ack or not received set test failure)
                
                } // End of TP_TSP_PAYMENTCLAIM_BV_02
                


 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
            testcase TP_TSP_PaymentClaim_BI_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_01: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect paymentClaimId 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
					// Start by setting test success
	                // Send one preset Billing Details
	                // Wait for positive Ack
					// Send one PAYMENTCLAIM related to the sent BILLINGDETAILS within allowed time constraints
					// Wait for positive Ack

                // Step 1:
                	// Send PAYMENTCLAIM with:
                		// ActionCode=REVOKE
                		// wrong PaymentClaimId value
              		// Wait for negative Ack (if positive Ack or not received set test failure)
                  
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_01           		

            testcase TP_TSP_PaymentClaim_BI_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_02: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect paymentClaimStatus 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				// Start by setting test success
                // Send one preset Billing Details
                // Wait for positive Ack
            
            	// Step 1: 
                	// Send PAYMENTCLAIM with:
                		// actionCode= adjust
						// paymentClaimStatus=firstversion(0)
              		// Wait for negative Ack (if positive Ack or not received set test failure)
            	      
			                
                } // End of TP_TSP_PAYMENTCLAIM_BI_02           		

            testcase TP_TSP_PaymentClaim_BI_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_03: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect referenceDetailsList 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
                // PT 140: TODO Probably there is no need to have an initial PAYMENTCLAIM for this test case as stated in the TSS&TP
				// Start by setting test success
                // Send one preset Billing Details
                // Wait for positive Ack
 
            	// Step 1: 
                	// Send PAYMENTCLAIM with:
                		// actionCode= adjust
						// referenceDetailsList=tollDeclarationList
              		// Wait for negative Ack (if positive Ack or not received set test failure)
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_03           		

            testcase TP_TSP_PaymentClaim_BI_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_04: Verify that a TSP performs the PAYMENTCLAIM transaction correctly when getting incorrect actionCode 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation 
                // PT 140: TODO Probably there is no need to have an initial PAYMENTCLAIM for this test case as stated in the TSS&TP
				// Start by setting test success
                // Send one preset Billing Details
                // Wait for positive Ack
 
            	// Step 1: 
                	// Send PAYMENTCLAIM with:
                		// actionCode= credit
              		// Wait for negative Ack (if positive Ack or not received set test failure)
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_04   

            testcase TP_TSP_PaymentClaim_BI_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_05: Getting provoked by various errors with defined specific responses  
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
                 // PT140: TODO TSS&TP to be reviewed/agreed 
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_05   

            testcase TP_TSP_PaymentClaim_BI_06() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_06: Verify that a TSP responds correctly to a PaymentClaimADU sent earlier than allowed  
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				// Start by setting test success
                // Send one preset Billing Details
                // Wait for positive Ack
				// Send one PAYMENTCLAIM related to the sent BILLINGDETAILS within allowed time constraints
				// Wait for positive Ack

                // Step 1:
                	// Send PAYMENTCLAIM with ActionCode=REVOKE before TIMEA_MIN
              		// Wait for negative Ack (if positive Ack or not received set test failure)                	
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_06  
        } // End of group Invalid_Behaviour

    } // End of group PAYMENTCLAIM
    
    group DSRC_CONTRACTISSUERLIST {
         group Valid_Behaviour {
           testcase TP_TSP_CONTRACTISSUERLIST_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_CONTRACTISSUERLIST_BV_01: Verify that the TSP correctly performs the DSRC.CONTRACTISSUERLIST transaction with three manufacturerIDs 
                  * @remark  [16986:2016], Clause 7.1 and Table A.1/2 AND Table A.2/1 AND Table A.26/1 
                  */
                  
                 // Initialisation
				// Start by setting test failure
				// Step 1: Trigger IUT with DSRC.CONTRACTISSUERLIST.TR_TSP_1 to send an APDU containing three ContractIssuerListADUs with differing manufacturerID values
				
				//  Wait for APDU containing three ContractIssuerListADUs
				
					// Send Ack within time constraints
					// Set test success
 
                
                } // End of TP_TSP_CONTRACTISSUERLIST_BV_01
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
           // No Invalid Behaviour Test cases defined		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.CONTRACTISSUERLIST
    
    group DSRC_EFCCONTEXTDATA {
         group Valid_Behaviour {
           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_01: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing only mandatory context data for a domain type = dsrcContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
                 
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// iso17573ADU containing only mandatory field with valid values
                 	// feeModifiers set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_01

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_02: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing only mandatory context data for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
                  
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with valid values and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_02

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_03: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus tariffClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
                  
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with tariffClassDefinition = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_03

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_04: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus localVehicleClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
                  
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with localVehicleClassDefinition  = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_04

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_05: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus timeClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with timeClassDefinition  = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_05

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_06() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_06: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus userClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with userClassDefinition  = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_06

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BV_07() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BV_07: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus feeDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with feeDefinition  = {valid contents} and all other fields set to null
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BV_07
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BI_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BI_01: Verify that the TSP correctly responds to an EFCContextDataADU containing only mandatory context data for a domain type = dsrcContext with a wrong data field 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// iso17573ADU containing only mandatory field with one invalid value
                 	// feeModifiers set to null
                 // Step 2: Wait for negative Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BI_01

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BI_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BI_02: Verify that the TSP correctly responds to an EFCContextDataADU containing only mandatory context data for a domain type = dsrcClosedContext with a wrong data field 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// dsrcClosedContext containing invalid values
                 	// feeModifiers set to null
                 	// all other mandatory fields set to valid values
                 // Step 2: Wait for negative Ack within DSRC.EFCCONTEXTDATA.TIME1
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BI_02

           testcase TP_TSP_DSRC.EFCCONTEXTDATA_BI_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.EFCCONTEXTDATA_BI_03: Verify that the TSP responds correctly to an EfcContextDataADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation 

				// Start by setting test success
				// Send one valid DSRC.EFCCONTEXTDATA
				// Wait for positive Ack

                // Step 1:
                	// Send one valid DSRC.EFCCONTEXTDATA before TIME1
              		// Wait for negative Ack (if positive Ack or not received set test failure)                	
                
                } // End of TP_TSP_DSRC.EFCCONTEXTDATA_BI_03
           		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.EFCCONTEXTDATA
    
    group DSRC_BILLINGDETAILS {
         group Valid_Behaviour {

           testcase TP_TSP_DSRC.BILLINGDETAILS_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BV_01: Verify that the TSP correctly performs a DSRC.BILLINGDETAILS transaction and responds to a single BillingDetailsADU with mandatory and optional fields 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BV_01

           testcase TP_TSP_DSRC.BILLINGDETAILS_BV_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BV_02: Verify that the TSP correctly perfoms a DSRC.BILLINGDETAILS transaction and responds to multiple BillingDetailsADUs containing only mandatory fields  
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 

                 // Step 1: Send one valid APDU containing 10 valid BillingDetailsADU with actionCode = SEND numbered from 3 to 12 
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BV_02

           testcase TP_TSP_DSRC.BILLINGDETAILS_BV_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BV_03: Verify that the TSP correctly perfoms a DSRC.BILLINGDETAILS transaction and responds to multiple BillingDetailsADUs with mandatory and optional fields 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 

                 // Step 1: Send one valid APDU containing 10 valid BillingDetailsADU with actionCode = SEND numbered from 13 to 22 with:
                 	// BillingDetailsADUs with numbers (13 .. 21) containing only mandatory fields
                 	// BillingDetailsADU numbered 22 containing one valid optional field
                 	
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BV_03

           testcase TP_TSP_DSRC.BILLINGDETAILS_BV_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BV_04: Verify that the TSP correctly perfoms a DSRC.BILLINGDETAILS transaction and responds to a single BillingDetailsADU containing only mandatory fields and adjusting the fee 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 
                 // Send one valid APDU containing one valid BillingDetailsADU numbered 1 with only mandatory field
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with only mandatory fields and with
                 	// actionCode = adjust
                 	// billingDetailsNum = 1
                 	// paymentFeeAmount = 45
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
                 
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BV_04

           testcase TP_TSP_DSRC.BILLINGDETAILS_BV_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BV_05: Verify that the TSP correctly perfoms a DSRC.BILLINGDETAILS transaction and responds to a single BillingDetailsADU revoking a previously sent BillingDetails 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 

                 // Send one valid APDU containing one valid BillingDetailsADU numbered 1 with only mandatory field
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with only mandatory fields and with
                 	// actionCode = revoke
                 	// billingDetailsNum = 1
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BV_05
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_DSRC.BILLINGDETAILS_BI_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BI_01: Verify that the TSP correctly responds to a single BillingDetailsADU with only mandatory fields, and then correctly responds to a a second BillingDetailsADU issued before TIMEA expires 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 

                 // Send one valid APDU containing one valid BillingDetailsADU numbered 13 with only mandatory field
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU numbered 14 with only mandatory fields before TIMEA_MIN expired
                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 identifying the APDU containing the BillingDetailsADU numbered 14
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BI_01

           testcase TP_TSP_DSRC.BILLINGDETAILS_BI_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BI_02: Verify that the TSP correctly responds to a series of BillingDetailsADUs bearing only mandatory field, each BillingDetailsADU having one mandatory field bearing an incorrect value 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation
                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1

                 // Step 1: Send one valid APDU containing 10  BillingDetailsADUs with actionCode = SEND numbered from 4 to 13, each one with the following parameters respectively set to one incorrect value:
                 	// billingDetailsId.issuerId, tollContext, userId, billingDetailsAmount, usageDetails.contextName, usageDetails.appliedUserClass, usageDetails.perDeclaredVehicleClasses, usageDetails.appliedTimeClass, usageDetails.entranceTime, usageList.ListofSections.chargeObjectId
                 	
                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 with issue list present and the following issue codes:
                 	// billingDetailsIssuerIdRejected, billingDetailsContextIdRejected, billingDetailsUserIdRejected, billingDetailsAmountRejected, billingDetailsContextNameRejected, billingDetailsAppliedUserClassRejected, billingDetailsDeclaredVehicleClassRejected, billingDetailsAppliedTimeClassRejected, billingDetailsEntranceTimeRejected, billingDetailsIntermediateSectionRejected
                 	
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BI_02

           testcase TP_TSP_DSRC.BILLINGDETAILS_BI_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BI_03: Verify that the TSP correctly responds to a BillingDetailsADU adjusting the fee of a not previously issued BillingDetailsADU 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 

                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU numbered 14 with only mandatory fields before TIMEA_MIN expired with the following values:
                 	// actionCode = adjust
                 	// paymentFeeAmount = 45
                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 identifying the APDU containing the BillingDetailsADU numbered 14 and with issueCode= semanticError 
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BI_03

           testcase TP_TSP_DSRC.BILLINGDETAILS_BI_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BI_04: Verify that the TSP correctly responds to a BillingDetailsADU revoking a not previously issued BillingDetailsADU 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 
                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU numbered 14 with only mandatory fields before TIMEA_MIN expired with the following values:
                 	// actionCode = revoke
                 	// paymentFeeAmount = 45
                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 identifying the APDU containing the BillingDetailsADU numbered 14 and with issueCode= semanticError 
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BI_04

           testcase TP_TSP_DSRC.BILLINGDETAILS_BI_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.BILLINGDETAILS_BI_05: Verify that the TSP responds correctly to a BillingDetailsADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                  
                 // Initialisation 

				// Start by setting test success
				// Send one valid DSRC.BILLINGDETAILS numbered 3
				// Wait for positive Ack

                // Step 1:
                	// Send one valid DSRC.BILLINGDETAILS numbered 4  before TIME1
              		// Wait for negative Ack with ADUReasonCode field = requestSentTooOften (if positive Ack or not received set test failure)                	
                
                } // End of TP_TSP_DSRC.BILLINGDETAILS_BI_05
		
        } // End of group Invalid_Behaviour

    } // End of group DSRC.BILLINGDETAILS
    
    group DSRC_REPORTABNORMALOBE {
         group Valid_Behaviour {

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BV_01: Verify that the TSP correctly performs a DSRC.REPORTABNORMALOBE transaction in response to an APDU containing valid ReportAbnormalOBEADUs 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 

                // Step 1:
                	// Send one valid DSRC.REPORTABNORMALOBE
              		// Wait for positive Ack (if negative Ack or not received set test failure)                	
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BV_01


 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_01: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no userId field present 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 

                // Step 1:
                	// Send one  DSRC.REPORTABNORMALOBE with userId field missing
              		// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)                	
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_01

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_02: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no value or invalid values in the field userId 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 

                // Step 1:
                	// Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with missing and second one with userID set to an invalid value
              		// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeUserIdRejected
              			                	
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_02

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_03: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no dateAndTime field 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 

                // Step 1:
                	// Send one  DSRC.REPORTABNORMALOBE with dateAndTime field missing
              		// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)                	
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_03

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_04: Verify that the TSP correctly responds to an APDU containing ReportAbnormalOBEADU with no value or invalid values in field dateAndTime 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 

                // Step 1:
                	// Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with dateAndTime missing and second one with dateAndTime set to a future value
              		// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeDateAndTimeRejected
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_04

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_05: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no efcContextMark field 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 

                // Step 1:
                	// Send one  DSRC.REPORTABNORMALOBE with efcContextMark field missing
              		// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)                	
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_05

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_06() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_06: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no value or invalid values in the field efcContextMark 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 

                // Step 1:
                	// Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with efcContextMark missing and second one with efcContextMark set to an invalid value
              		// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeDateAndTimeRejected
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_06

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_07() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_07: Verify that the TSP correctly responds to an APDU containing ReportAbnormalOBEADU not containing the abnormalOBEReason field 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 

                // Step 1:
                	// Send one  DSRC.REPORTABNORMALOBE with efcContextMark and abnormalOBEReason fields missing
              		// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)                	
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_07

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_08() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_08: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no value or invalid values in the field abnormalOBEReason 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation 

                // Step 1:
                	// Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with abnormalOBEReason missing and second one with abnormalOBEReason set to an invalid value
              		// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeReasonCodeRejected
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_08

           testcase TP_TSP_DSRC.REPORTABNORMALOBE_BI_09() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC.REPORTABNORMALOBE_BI_09: Verify that the TSP responds correctly to a ReportAbnormalOBEADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                  
                 // Initialisation
                 // Send one  APDU containg one valid ReportAbnormalOBEADU
              	 // Wait for positive Ack
                // Step 1:
                	// Send one one  APDU containg one valid ReportAbnormalOBEADU before TIMEA_MIN
              		// Wait for negative Ack with ADUReasonCode = requestSentTooOften (if positive Ack or not received set test failure)                	
                  
                
                } // End of TP_TSP_DSRC.REPORTABNORMALOBE_BI_09


        } // End of group Invalid_Behaviour

    } // End of group DSRC.REPORTABNORMALOBE
    
    group GNSS_TOLLDECLARATION {
         group Valid_Behaviour {

           testcase TP_TSP_GNSS_TOLLDECLARATION_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_TOLLDECLARATION_BV_01: Verify that the TSP correctly performs a GNSS.TOLLDECLARATION transaction with actionCodes = send, revoke and adjust 
                  * @remark  [16986:2016], Clause 8.1 and Table A.1/2 AND Table A.2/2 AND Table A.52/3
                  */
                  
                 // Initialisation 
				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send three valid TollDeclarationADUs with actionCode = send, revoke, and adjust, respectively
				
				//  Wait for GNSS.TOLLDECLARATION
				
					// Send Ack within time constraints
					// Set test success
                
                } // End of TP_TSP_GNSS_TOLLDECLARATION_BV_01
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
           // No Test Cases are defined for invalid behaviour.		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.TOLLDECLARATION
    group GNSS_BILLINGDETAILS_TSP {
         group Valid_Behaviour {

           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_01: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with a single BillingDetailsADU with all mandatory plus optional includedDiscounts field 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 

				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with:
					// actionCode = send
					// includedDiscounts in usageList with textDetail field being set according to values specified in Table A.54 of CEN/TS 16986:2016
				
				//  Wait for GNSS.TOLLDECLARATION
				
					// Send Ack within time constraints
					// Set test success
                                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_01           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_02: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with a single BillingDetailsADU with all mandatory fields and areaDisplayName field 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 

				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with:
					// actionCode = send
					// areaDisplayName forTravellingInArea with textDetail field being a correct character string
				
				//  Wait for GNSS.TOLLDECLARATION
				
					// Send Ack within time constraints
					// Set test success
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_02           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_03: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with a single BillingDetailsADU with all mandatory fields and qualifier field in forCordonCross selection 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 

				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with:
					// actionCode = send
					// valid usageList qualifier field set to forCordonCrossing
				
				//  Wait for GNSS.TOLLDECLARATION
				
					// Send Ack within time constraints
					// Set test success
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_03           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_04: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with a single BillingDetailsADU with all mandatory fields and entranceChargeObjectName field in forCordonCross selection 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 

				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with:
					// actionCode = send
					// valid usageList entranceChargeObjectName field set to forCordonCrossing
				
				//  Wait for GNSS.TOLLDECLARATION
				
					// Send Ack within time constraints
					// Set test success
                                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_04           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_05: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with multiple BillingDetailsADUs with only mandatory fields in the same APDU 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 

				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one APDU containing 10 valid TollDeclarationADUs with:
					// actionCode = send
					// only mandatory fields present with valid values
					// billingDetailsNum field values ranging from 3 to 12
				
				//  Wait for GNSS.TOLLDECLARATION
				
					// Send Ack within time constraints
					// Set test success
                                                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_05           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_06() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_06: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with adjusting the fee on a single BillingDetailsADU containing only mandatory fields 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 

				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one APDU containing one valid TollDeclarationADU with:
					// actionCode = adjust
					// only mandatory fields present with valid values
					// paymentFeeAmount field value = 45
					// billingDetailsNum field value = 1
				
				//  Wait for GNSS.TOLLDECLARATION
				
					// Send Ack within time constraints
					// Set test success
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_06           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_07() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_07: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with revoking a single BillingDetailsADU containing only mandatory fields 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 

				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one APDU containing one valid TollDeclarationADU with:
					// actionCode = revoke
					// only mandatory fields present with valid values
					// billingDetailsNum field value = 1
				
				//  Wait for GNSS.TOLLDECLARATION
				
					// Send Ack within time constraints
					// Set test success
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_07           


 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
           // No Test Cases are defined for invalid behaviour.		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS_TSP
    
    group GNSS_BILLINGDETAILS_TC {
         group Valid_Behaviour {

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_01: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a response to a single BillingDetailsADU with all mandatory plus optional includedDiscounts field 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// PT140: TODO TSS&TP says one BillingDetails transaction to be executed before the test. Why?
				
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// includedDiscounts in usageList with textDetail field being set according to values specified in Table A.54 of CEN/TS 16986:2016
                 // Step 2: Wait for positive Ack within TSP_GNSS_BILLINGDETAILS.TIME1
				
					// Set test success                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_01           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_02: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a response to a single BillingDetailsADU with all mandatory fields and areaDisplayName field 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// PT140: TODO TSS&TP says one BillingDetails transaction to be executed before the test. Why?
				
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// areaDisplayName in forTravellingInArea with textDetail field being a correct character string
                 // Step 2: Wait for positive Ack within TSP_GNSS_BILLINGDETAILS.TIME1
				
					// Set test success                
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_02           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_03: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a response to a single BillingDetailsADU with all mandatory fields and qualifier field in forCordonCross selection 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// PT140: TODO TSS&TP says one BillingDetails transaction to be executed before the test. Why?
				
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// value of qualifier in forCordonCrossing being correct according to EN ISO 12855 Clause 6.12
                 	// value of entranceChargeObjectName in forCordonCrossing being a correct UTF8String
                 // Step 2: Wait for positive Ack within TSP_GNSS_BILLINGDETAILS.TIME1
				
					// Set test success                
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_03           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_04: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a response to multiple BillingDetailsADUs with only mandatory fields in the same APDU 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// PT140: TODO TSS&TP says one BillingDetails transaction to be executed before the test. Why?
				
                 // Step 1: Send one valid APDU containing 10 valid BillingDetailsADUs with:
                 	// action code = send
                 	// value of billingDetailsNum ranging from 3 to 12
                 // Step 2: Wait for positive Ack within TSP_GNSS_BILLINGDETAILS.TIME1
				
					// Set test success                
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_04           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_05() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_05: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a response to a single BillingDetailsADU containing only mandatory fields and adjusting the fee 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// Send one valid APDU containing one valid BillingDetailsADU with:
                 		// action code = send
                  		// value of billingDetailsNum = 1
					//  Wait Ack within time constraints
                 		
				
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = adjust 
                 	// billingDetailsNum = 1
                 	// paymentFeeAmount = 45
                 // Step 2: Wait for positive Ack within TSP_GNSS_BILLINGDETAILS.TIME1
				
					// Set test success                
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_05           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_06() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_06: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a response to a single BillingDetailsADU containing only mandatory fields and revoking a previously issued BillingDetailsADU 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                  
                 // Initialisation 
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// Send one valid APDU containing one valid BillingDetailsADU with:
                 		// action code = send
                  		// value of billingDetailsNum = 1
					//  Wait Ack within time constraints
                 		
				
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = revoke 
                 	// billingDetailsNum = 1
                 // Step 2: Wait for positive Ack within TSP_GNSS_BILLINGDETAILS.TIME1
				
					// Set test success                
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_06                    
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_01: Verify that the TSP correctly responds to a series of BillingDetailsADUs bearing only mandatory fields, each BillingDetailsADU having one mandatory field bearing an incorrect value 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                  
                 // Initialisation 
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// PT140: TODO TSS&TP says one BillingDetails transaction to be executed before the test. Why?
				
                 // Step 1: Send one valid APDU containing 13 valid BillingDetailsADUs, each one with the following parameters respectively set to one incorrect value:
                 	// billingDetailsId.issuerId, tollContext, userId, Period, billingDetailsAmount, usageDetails.contextName, usageDetails.appliedUserClass, usageDetails.perDeclaredVehicleClasses, usageDetails.appliedTimeClass, usageDetails.entranceTime, usageList.ListofSections.chargeObjectId, exitChargeObject, exitTime

                 	
                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 with issue list present and the following issue codes:
                 	// billingDetailsIssuerIdRejected, billingDetailsContextIdRejected, billingDetailsUserIdRejected, billingDetailsPeriodRejected, billingDetailsAmountRejected, billingDetailsContextNameRejected, billingDetailsAppliedUserClassRejected, billingDetailsDeclaredVehicleClassRejected, billingDetailsAppliedTimeClassRejected, billingDetailsEntranceTimeRejected, billingDetailsIntermediateSectionRejected, billingDetailsExitChargeObjectRejected, billingDetailsExitTimeRejected
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_01           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_02() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_02: Verify that the TSP correctly responds to a single BillingDetailsADU with only mandatory fields, followed by a second valid BillingDetailsADU issued before TIMEA_MIN expires 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                  
                 // Initialisation 
					// PT140: TODO TSS&TP does not require GNSS.TOLLDECLARATION
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// Send one valid APDU containing one valid BillingDetailsADU with:
                 		// action code = send
                  		// value of billingDetailsNum = 13
					//  Wait Ack within time constraints

                 // Step 1: Send one valid APDU before TIMEA_MIN containing one valid BillingDetailsADU with:
                 	// action code = send 
                 	// billingDetailsNum = 14
                 // Step 2: Wait for NAck_requestSentTooOften within TSP_GNSS_BILLINGDETAILS.TIME1
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_02           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_03() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_03: Verify that the TSP correctly responds to a BillingDetailsADU adjusting the fee for a BillingDetailsADU that does not exist 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                  
                 // Initialisation 

					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// Send one valid APDU containing one valid BillingDetailsADU with:
                 		// action code = send
                  		// value of billingDetailsNum = 13
					//  Wait Ack within time constraints

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = adjust 
                 	// billingDetailsNum = 14
                 	// paymentFeeAmount = 45
                 // Step 2: Wait for NAck with issueCode = actionCodeNotSupported within TSP_GNSS_BILLINGDETAILS.TIME1
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_03           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_04() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_04: Verify that the TSP correctly responds to a BillingDetailsADU revoking a BillingDetailsADU that does not exist at the TSP 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                  
                 // Initialisation 

					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send Ack within time constraints
					// Send one valid APDU containing one valid BillingDetailsADU with:
                 		// action code = send
                  		// value of billingDetailsNum = 13
					//  Wait Ack within time constraints

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = revoke 
                 	// billingDetailsNum = 14
                 	// paymentFeeAmount = 45
                 // Step 2: Wait for NAck with issueCode = actionCodeNotSupported within TSP_GNSS_BILLINGDETAILS.TIME1
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_04           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_05() runs on IutComp system TestAdapter {
// PT140: TODO seems the same as TP_TSP_GNSS.BILLINGDETAILS.TC_BI_02             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_05: Verify that the TSP correctly responds to a BillingDetailsADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                  
                 // Initialisation 
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_05           
		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.BILLINGDETAILS.TC
    
    group GNSS_PAYMENTANNOUNCEMENT {
         group Valid_Behaviour {

           testcase TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_01() runs on IutComp system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_01: Verify that the TSP correctly performs the GNSS.PAYMENTANNOUNCEMENT transaction with actionCode=send 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.2/2 AND Table A.52/4 
                  */
                  
                 // Initialisation 

					// Start by setting test success
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					// Wait for TollDeclarationADU
					// Send one positive Ack within allowed time constraints
	                // Send one correct BillingDetailsADU related to the received Toll Declaration within allowed timeconstraints
	                // Wait for positive Ack
					// Send one PAYMENTCLAIM related to the sent BILLINGDETAILS within allowed time constraints
					// Wait for positive Ack
					
				// Step 1: Trigger IUT with GNSS.PAYMENTANNOUNCEMENT.TR_TC_TSP_1 to send one valid PaymentAnnouncementADU with actionCode = send
					// Wait for PaymentAnnouncementADU within allowed time constraints
					// Send positive Ack within time constraints
					// Set test success
                
                } // End of TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_01                    

           testcase TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_02() runs on IutComp system TestAdapter {
 // PT140: TODO TSS&TP text to be corrected            
                  /**
                  * @desc    TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_02: Verify that the TSP correctly performs the GNSS.PAYMENTANNOUCEMENT transaction with actionCode=revoke and adjust 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.2/2 AND Table A.52/4 
                  */
                  
                 // Initialisation 
                
                } // End of TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_02                    

 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
           // No Test Cases are defined for invalid behaviour.		           		
        } // End of group Invalid_Behaviour

    } // End of group GNSS.PAYMENTANNOUNCEMENT
} // End of module Toll_Service_Provider
