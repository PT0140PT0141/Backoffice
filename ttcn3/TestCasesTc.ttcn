    
/**
 * @author  PT0140 
 * @desc    This module provides test cases based on Charging TPs
 * @see     [16407-1:2016]: Test suite structure and test purpose
 * @see     [16407-1:2016], Clause 5.3.2 TP namimg conventions
 * @version $id$
 */
module EfcInfoExchange_TestCasesTc {
 import from EfcInfoExchange_ParameterisedAsn1Data all;

 /**
     * @desc    [17575-1:2016]: Charging
     * @see     Annex A (normative) EFC data type specifications
     */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    

    // LibEfc_Common
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     *          Common_Parametrised_Asn1_Data TTCN-3 module is a workaround
     */
    import from Common_ParametrisedAsn1Data all;
    import from EfcInfoExchange_Functions all;
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Templates all;
    
    // Backoffice
    import from EfcInfoExchange_Functions all;
    import from EfcInfoExchange_Templates all;
    import from EfcInfoExchange_Ics all;
    import from EfcInfoExchange_Interfaces all;

 group USERDETAILS {
         group Valid_Behaviour {
              
         	testcase Testcase_TP_TC_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_USERDETAILS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserDetailsADUs 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noParamsToUse ;
				var RecordOfUserParameterRequest listOfParameterReq;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noParamsToUse := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noParamsToUse;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParameterReq := v_apduReceived.infoExchangeContent.adus.requestAdus[v_ct].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParameterReq);v_loop2:=v_loop2+1) {
									if (not (match(listOfParameterReq[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement
				
				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noParamsToUse];
				
				for (var integer v_loop1 :=0; v_loop1<v_noParamsToUse;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu :=v_adus.provideUserDetailsADUs[v_loop1];
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.statusFlag := UserStatus_standardCommercialUserContract_;
					for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParameterReq);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:=omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= USER_PARAMETER_RESPONSE_DUMMY_VALUES[listOfParameterReq[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:=omit;
					}
				}								                   
				
				var InfoExchange v_apduProvideUserDetailsSend:=m_apduNoSec( m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduProvideUserDetailsSend);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduProvideUserDetailsSend)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BV_01
            
	
         } // End group Valid Behaviour
    } 
} // End of module Toll_Charger
