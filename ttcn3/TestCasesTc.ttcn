 /**
 * @author  PT0140 
 * @desc    This module provides test cases for TPs specified in Annex A of CEN/TC 17154-1 (i.e. Toll Charger system is IUT)
 * @see     [17154-1:2017]: Test suite structure and test purpose
 * @see     [17154-1:2017], Clause 5.3.2 for TP namimg conventions
 * @version $id$
 */
 
 
 /**
 * work in progress status overview
 *
 *	Transaction type			!	BV					! BI			! Comments
 * 	----------------------------!-----------------------!---------------!--------------------------------
 *	Base						! done					! done			! ready for compile
 *	UserDetails					! done					! done			! ready for compile
 *	ListOfUsers					! done					! done			! ready for compile
 *	ExceptionList				! done					! done			! ready for compile
 *	TrustObjects				! done					! done			! ready for compile
 *	PaymentClaim				! done					! n.a.			! ready for compile
 *	DSRC.ContractIssuerList		! done					! done			! ready for compile
 *	DSRC.EFCContextData			! done					! n.a.			! ready for compile 
 *	DSRC.BillingDetails			! done					! n.a.			! ready for compile
 *	DSRC.ReportAbnormalOBE		! done					! n.a.			! ready for compile
 *	GNSS.TollDeclaration		! done					! done			! done but need to revise List of ChargeReports in template
 *	GNSS.BillingDetails.TSP		! done					! open			! ready for compile for BVs
 *	GNSS.BillingDetails.TC		! done					! n.a.			! ready for compile
 *	GNSS.PaymentAnnouncement	! done					! done			! ready for compile
 */
 
module EfcInfoExchange_TestCasesTc {
	/**
    * @desc    [12855:2015]: 
    * @see     Annex A (normative)  data type specifications
    */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
    * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
    *          Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
    */
    import from LibEfc_Common_Parameterised_Asn1_Data all;
	import from EfcInfoExchange_ParameterisedAsn1Data all;
    import from EfcInfoExchange_Interfaces all;
	import from EfcInfoExchange_InteroperabilityStatement all;
    import from EfcInfoExchange_Functions all;	
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Ics all;
    import from EfcInfoExchange_Templates all;
	import from EfcInfoExchange_TesterData all;
    import from EfcInfoExchange_Profile all;
		
     /**
      * @desc	These test cases apply to Toll Charger claiming conformance to [16986:2016]
      *			and applying Test Purposes as from CEN/TS17154-1:2018 Annex A
      * @remark
      */
 
	group BASE {
		group Valid_Behaviour {

			testcase TP_TC_BASE_BV_01() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BV_01: Verify that the TC validates correct infoExchanceAuthenticators in received APDUs
	 		* and generates correct infoExchangeAuthenticators
	 		* @remark  [16986:2016], Clause 6.2.2 and Table A.1/1 and Table A.3/3 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A3_3_useAuthenticator and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 1:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list with authenticator
                v_apduForSending := m_apduAuthInitTester({c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduAuthRespIut(v_apduForSending, m_oneAckInAdusStruct(m_aduDefaultAck(v_apduForSending)))) -> value v_apduReceived {
						
						if (fx_checkAuthenticator(v_apduReceived)) {
							f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
							setverdict(pass);
						}
						else {
							setverdict(fail);
							f_addLogEntry("Incorrect authenticator");
						};
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BV_01
		} //end group valid_behaviour         

		group Invalid_Behaviour {

			testcase TP_TC_BASE_BI_01() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_01: Verify that the TC correctly responds to invalid aidIdentifier
	 		* in the APCI field received in an APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with invalid aidIdentifier
				template (value) ApciFields m_apciInvalidAidInitTester modifies m_apciInitTester:= {aidIdentifier:=0};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidAidInitTester, {c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(protocolVersionError (6))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_protocolVersionError_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_01

			testcase TP_TC_BASE_BI_02() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_02: Verify that the TC correctly responds to invalid apduOriginator
	 		* in the APCI field received in an APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with invalid apduOriginator (= not Tester Originator)
				template (value) ApciFields m_apciInvalidAidInitTester modifies m_apciInitTester:= {apduOriginator:= TD_INVALID_APDU_ORIGINATOR_TESTER};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidAidInitTester, {c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(originatorRejected (7))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_originatorRejected_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_02

			testcase TP_TC_BASE_BI_03() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_03: Verify that the TC correctly responds to invalid or unknown informationSenderID
	 		* in the APCI field received in an APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with invalid or unknown informationSenderID (= not Sender Id of the Tester)
				template (value) ApciFields m_apciInvalidSenderIdInitTester modifies m_apciInitTester:= {informationSenderID:= TD_INVALID_INFORMATION_SENDER_TESTER};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidSenderIdInitTester, {c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(originatorRejected (7))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_originatorRejected_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_03

			testcase TP_TC_BASE_BI_04() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_04: Verify that the TC correctly validates an informationRecipientID
	 		* in APCI field which does not address the IUT
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with invalid or unknown informationRecipientID (= not Id of the Iut)
				template (value) ApciFields m_apciInvalidRecipientIdInitTester
					modifies m_apciInitTester:= {informationrecipientID:= TD_INVALID_INFORMATION_RECEPIENT_ID_FOR_IUT};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidRecipientIdInitTester, {c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(recipientUnknown (8))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_recipientUnknown_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_04

			testcase TP_TC_BASE_BI_05() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_05: Verify that the TC correctly respond to invalid apduIdentifier in APCI field
	 		* received in an APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 0:
				// Prepare and capture the apdu to be sent in a variable to avoid apduIdentifier to be re-generated
				v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduWhiteValid});

				// Send APDU
				f_sendAndLogApdu(v_apduForSending);              	

                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               

              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
					}
				}											
											
                // Send the same APDU again with same apduIdentifier 
				f_sendAndLogApdu(v_apduForSending);              	

                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               

                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_05

			testcase TP_TC_BASE_BI_06() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_06: Verify that the TC correctly responds to a received APDU
	 		* in which the nextAPDUId field is present in APCI field
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with containing nextApduId field
				template (value) ApciFields m_apciInvalidWithNextApduIdInitTester
					modifies m_apciInitTester:= {nextApduId := 1};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidWithNextApduIdInitTester, {c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_06

			testcase TP_TC_BASE_BI_07() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_07: Verify that the TC correctly responds to a received APDU in which
	 		* the inResponseToApduId is present in APCI field but the received APDU is not in response to a previous APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI for an Initiating APDU in which inResponseToApdu field is present
				template (value) ApciFields m_apciInvalidWithInResponseToApduIdInitTester
					modifies m_apciInitTester:= {inResponseToApduId := 1};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidWithInResponseToApduIdInitTester, {c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3)) or NAck_Protocol_Apdu(sequenceError (4)) 
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
					
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_sequenceError_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_07

			testcase TP_TC_BASE_BI_08() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_08: Verify that the TC correctly responds
	 		* to an invalid inResponseToApduId in APCI field of the APDU received
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/2
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Trigger Iut to send userListRequest
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_ONEADU);

             	// Wait for RequestADU of type userListRequest 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({mw_aduRequestListOfUsers})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// capture ApduId received
				var ApduIdentifier v_apduId := v_apduReceived.infoExchangeContent.apci.apduIdentifier;
				
				// prepare wrong APCI-fields with wrong inResponseToApduId
				template (value) ApciFields m_apciInvalidInResponseToApduIdRespTester
					modifies m_apciRespTester := {inResponseToApduId := {APDU_ORIGINATOR_FOR_IUT, v_apduId+1}};

				// Step 2
				// Prepare ProvideUserIdListADUs depending on received request

				var Adus v_adus;
				var integer v_i, v_numberOfRequestAdus := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				for (v_i := 0; v_i < v_numberOfRequestAdus; v_i := v_i + 1) {
					v_adus.provideUserIdListADUs[v_i]:=
					m_aduProvideUserIdList(
						v_apduReceived.infoExchangeContent.adus.requestAdus[v_i].userListRequest.userId
					);
				};

                // Including the invalid APCI with wrong inResponseToApduId
                v_apduForSending := m_apduNoAuth(m_apciInvalidInResponseToApduIdRespTester, v_adus);           	

				// send ProvideUserIdList within TIME1
				f_wait(LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				
				// Start timer
                t_step.start(LISTOFUSERS_TIME2_MAX_TC);               	
             	             
                // Step 3:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3)) or NAck_Protocol_Apdu(sequenceError (4)) 
              	// within time LISTOFUSERS.TIME2
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}
					
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_sequenceError_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_08

			testcase TP_TC_BASE_BI_09() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_09: Verify that the TC correctly responds to an
	 		* invalid apduDate in the APCI field of the received APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI for an Initiating APDU in which the apduDate is invalid (= presents a future date/time)
				template (value) ApciFields m_apciInvalidApduDateInitTester
					modifies m_apciInitTester:= {apduDate := fx_getUtc(100000)};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidApduDateInitTester, {c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3)) 
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_09
	
			testcase TP_TC_BASE_BI_10() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_10: Verify that the TC responds to incorrect infoExchanceAuthenticators in received APDUs
	 		* @remark  [16986:2016], Clause 6.2.2, Clause 6.3.2 and Table A.1/1 and Table A.3/3 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A3_3_useAuthenticator and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 

				// Set up a correct apdu which not be sent (Black-list) and create an valid authenticator		
				v_apduForSending := m_apduAuthInitTester({c_exceptionListAduBlackValid1});

				// Get this correctly computed authenticator				
				var ApduAuthenticator v_authenticator:= v_apduForSending.infoExchangeAuthenticator;
					
				// Step 0:
				// Prepare APCI for an Initiating APDU (White-list) in which the authenticator is replaced by
				// the one calculated above for the black-list, thus inserting an incorrect authenticator
				template (value) InfoExchange m_apduInvalidAuthInitTester
					modifies m_apduAuthInitTester := {infoExchangeAuthenticator := v_authenticator};
											
				// Step 1:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list with authenticator
                v_apduForSending := m_apduInvalidAuthInitTester({c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               

               	// Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3)) 
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_10				
		} //end group invalid_behaviour 
	} // end group base TPs 


	group USERDETAILS {
         group Valid_Behaviour {
              
         	testcase TP_TC_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc	TP_TC_USERDETAILS_BV_01: Verify that the TC correctly sends an APDU containing valid RequestADUs
				 *			and provides valid ProvideUserDetailsADUs 
				 * @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({{mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;
				// PT140 TODO: I have replaced sizeof by lengthof in below assignment
				// Attention: sizeof shall not be used any longer for getting the length of a record of
				// according to TTCN-3 and is replaced by lengthof !!!
				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
			
				//TODO PT140. I think we don't need the piece in comments now below
				// allowed values of UserParameterRequest (=0..255) are implicitely checked by the template
				// mw_aduRequestProvideUserDetails
				// the tester is anyhow prepared with tester data for all predefined user details parameters
				// Note: in case we finally need it we need to introduce the template mw_userDetailsSupportedListOfParameters
				// which could also be included in the template mw_aduRequestProvideUserDetails
				// remaining usefull part (get list of requested user parameters per adu) is mooved downwards

				/* 
				var RecordOfUserParameterRequest v_listOfParametersRequested;
												
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {	
					var RequestADU v_receivedRequestAdu:=v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1];
 					if ( match(v_receivedRequestAdu, mw_aduRequestProvideUserDetails)) {
						v_listOfParametersRequested := v_receivedRequestAdu.userDetailsRequest.listOfParametersRequested;
						for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
							if (not (match(v_listOfParametersRequested[v_loop2], mw_userDetailsSupportedListOfParameters))) {
								setverdict(fail);
								stop;
							}
						}
 					} else {
 						setverdict(fail);
 						stop;
 					}						
				}
				*/								                   
				
				//Step 2 send ProvideUserDetails after TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);

				//Prepare ProvideUserDetailsADUs
				//All ADUs will be put in the array v_adus
				var Adus v_adus[v_noReqAdusReceived];
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RecordOfUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_standardCommercialUserContract_;
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus[v_loop1]:=v_theAdu;
				}								                   
				
                // Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//Step 3 wait for AckADU
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BV_01
		} //end group valid behaviour         
         
		group Invalid_Behaviour { 	
			testcase TP_TC_USERDETAILS_BI_01() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc    TP_TC_USERDETAILS_BI_01: Verify that the TC correctly responds to an incorrect ProvideUserDetailsADUs 
				* @remark  [16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({{mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;
				// PT140 TODO: I have replaced sizeof by lengthof in below assignment
				// Attention: sizeof shall not be used any longer for getting the length of a record of
				// according to TTCN-3 and is replaced by lengthof !!!
				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				//Step 2 send ProvideUserDetails after TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);

				//Prepare ProvideUserDetailsADUs
				//All ADUs will be put in the array v_adus
				var Adus v_adus[v_noReqAdusReceived];
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RecordOfUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_standardCommercialUserContract_;
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						// PT140 TODO: ensure the provided perameter does never match the requested one 
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus[v_loop1]:=v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = semantic error (3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semantic error (3000) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var NAckParams v_nAckParamsList; //Nte, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_semanticError_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_01				
				
			testcase TP_TC_USERDETAILS_BI_02() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc		TP_TC_USERDETAILS_BI_02: Verify that the TC correctly responds to a provideUserDetailsADU
				*			with no statusFlag being present 
				* @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({{mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;

				// PT140 TODO: I have replaced sizeof by lengthof in below assignment
				// Attention: sizeof shall not be used any longer for getting the length of a record of
				// according to TTCN-3 and is replaced by lengthof !!!
				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				//Step 2 send ProvideUserDetails after TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);

				//Prepare ProvideUserDetailsADUs
				// StatusFlg not present
				//All ADUs will be put in the array v_adus
				var Adus v_adus[v_noReqAdusReceived];
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RecordOfUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := omit;
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus[v_loop1]:=v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var NAckParams v_nAckParamsList; //Nte, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_invalidADU_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_02				
				
			testcase TP_TC_USERDETAILS_BI_03() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc		TP_TC_USERDETAILS_BI_03: Verify that the TC correctly responds to a ProvideUserDetailsADU
				*			with statusFlag ranging from 1 to 5 and no listOfUserParameters being present
				* @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({{mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;

				// PT140 TODO: I have replaced sizeof by lengthof in below assignment
				// Attention: sizeof shall not be used any longer for getting the length of a record of
				// according to TTCN-3 and is replaced by lengthof !!!
				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				// Step 2 send ProvideUserDetails after TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);

				// Prepare ProvideUserDetailsADUs
				// with statusFlag ranging from 1 to 5 and no listOfUserParameters being present
				// All ADUs will be put in the array v_adus
				var Adus v_adus[v_noReqAdusReceived];
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RecordOfUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_standardPrivateUserContract_;
					v_theAdu.listOfUserParameters := omit;
					v_adus[v_loop1]:= v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var NAckParams v_nAckParamsList; //Nte, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_invalidADU_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_03				

			testcase TP_TC_USERDETAILS_BI_04() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc		TP_TC_USERDETAILS_BI_04: Verify that the TC correctly responds to a provideUserDetailsADU with statusFlag value
				*			not included in the interval from 1 to 5 and listOfUserParameters being present
				* @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({{mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;

				// PT140 TODO: I have replaced sizeof by lengthof in below assignment
				// Attention: sizeof shall not be used any longer for getting the length of a record of
				// according to TTCN-3 and is replaced by lengthof !!!
				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				//Step 2 send ProvideUserDetails after TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);

				// Prepare ProvideUserDetailsADUs
				// with statusFlag value not included in the interval from 1 to 5
				// All ADUs will be put in the array v_adus
				var Adus v_adus[v_noReqAdusReceived];
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RecordOfUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_noContractualRelation_; //i.e. "0"
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus[v_loop1]:=v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var NAckParams v_nAckParamsList; //Nte, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_invalidADU_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_04				

			testcase TP_TC_USERDETAILS_BI_05() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc		TP_TC_USERDETAILS_BI_05: Verify that the TC correctly responds to a provideUserDetailsADU
				*			with invalid parameters in the UserParameterResponse field
				* @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({{mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;

				// PT140 TODO: I have replaced sizeof by lengthof in below assignment
				// Attention: sizeof shall not be used any longer for getting the length of a record of
				// according to TTCN-3 and is replaced by lengthof !!!
				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				//Step 2 send ProvideUserDetails after TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);

				// Prepare ProvideUserDetailsADUs
				// with invalid parameters in the UserParameterResponse field; i.e. requestUserParameter present OR
				// userParameterStatus not present OR userInfoValidityPeriod present OR userParameterResponse not present
				// All ADUs will be put in the array v_adus
				var Adus v_adus[v_noReqAdusReceived];
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RecordOfUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_tempExceptionListed_; //i.e. ""
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= omit;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus[v_loop1]:=v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var NAckParams v_nAckParamsList; //Nte, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_invalidADU_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_05				

         } // End group Invalid_Behaviour

    } // End goup USERDETAILS
    
    
    group LISTOFUSERS {
		group Valid_Behaviour {
		
			testcase TP_TC_LISTOFUSERS_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_01: Verify that the TC correctly performs a LISTOFUSERS transaction 
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
  
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1_ONEORMOREADUS to send one or more valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_ONEORMOREADUS);

             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({{mw_aduRequestListOfUsers}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Step 2
				// Prepare ProvideUserIdListADUs depending on received request
				var Adus v_adusProvideUserIdList;
				var integer v_i, v_numberOfRequestAdus := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				for (v_i := 0; v_i < v_numberOfRequestAdus; v_i := v_i + 1) {
					v_adusProvideUserIdList.provideUserIdListADUs[v_i]:=
					m_aduProvideUserIdList(
						v_apduReceived.infoExchangeContent.adus.requestAdus[v_i].userListRequest.userId
					);
				};
																	
                // Prepare APDU to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adusProvideUserIdList);              	

				// send ProvideUserIdList within TIME1
				f_wait(LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				

				// Start timer
                t_step.start(LISTOFUSERS_TIME2_MAX_TC);               	
             	             
                // Step 3:	
              	// Wait for Default_Ack 
              	// within time LISTOFUSERS.TIME2
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_LISTOFUSERS_BV_01			
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase TP_TC_LISTOFUSERS_BI_01() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_01: Verify that the TC correctly responds
                 * 			to a ProvideUserIdListADU with originalUserId not present
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1_ONEADU to send one valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber} present,
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_ONEADU);

             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({mw_aduRequestListOfUsers})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Step 2
				// Prepare the ProvideUserIdListADU depending on received request
				// but not containing the originalUserId field
				var ProvideUserIdListADU v_adusProvideUserIdList:= m_aduProvideUserIdList(omit);
																	
                // Prepare APDU to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adusProvideUserIdList);              	

				// send ProvideUserIdList within TIME1
				f_wait(LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				

				// Start timer
                t_step.start(LISTOFUSERS_TIME2_MAX_TC);               	
             	             
              	// Wait for Ack_Apdu within time LISTOFUSERS.TIME2
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for ADU#1
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {{1, AduReasonCode_invalidADU_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();              
			
			} // End of TP_TC_LISTOFUSERS_BI_01

			testcase TP_TC_LISTOFUSERS_BI_02() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_02: Verify that the TC correctly responds to a ProvideUserIdListADU
                 *			with userIds which have not be requested in the requestADU
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1_THREEADUS to send three(3) valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber} present,
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_THREEADUS);

             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(
						{mw_aduRequestListOfUsers},
						{mw_aduRequestListOfUsers},
						{mw_aduRequestListOfUsers})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Step 2
				// Prepare ProvideUserIdListADUs depending on received request
				// but with userIds which have not been requested
				var Adus v_adus;
				var integer v_i, v_numberOfRequestAdus := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				for (v_i := 0; v_i < v_numberOfRequestAdus; v_i := v_i + 1) {
					v_adus.provideUserIdListADUs[v_i]:=
					m_aduProvideUserIdList(
						PX_USERS_NOT_EXISTING[v_i]
					);
				};
																	
                // Prepare APDU to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// send ProvideUserIdList within TIME1
				f_wait(LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				

				// Start timer
                t_step.start(LISTOFUSERS_TIME2_MAX_TC);               	
             	             
              	// Wait for Ack_Apdu within time LISTOFUSERS.TIME2
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for ADU#1, #2 and #3
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending,{
						{1, AduReasonCode_semanticError_},
						{2, AduReasonCode_semanticError_},
						{3, AduReasonCode_semanticError_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();              
			} // End of TP_TC_LISTOFUSERS_BI_02
			
			testcase TP_TC_LISTOFUSERS_BI_03() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_03: Verify that the TC correctly responds to a ProvideUserIdListADU
                 *			with invalid userId data
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                
                // Step 3: Wait for NAck_Apdu with ({0, invalidADU(0)})
                // or NAck_Apdu with ({1, InvalidADU(0)}, , {n, invalidADU(0)})
                // where n is the number of ProvideUserIdListADUs
                // within LISTOFUSERS.TIME2 
		  		
		  		// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1_THREEADUS to send exactely one(1) valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber} present,
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_ONEADU);

             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({mw_aduRequestListOfUsers})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(0.0); // no minimum time specified
					}
				}

				// Step 2
				// Prepare the ProvideUserIdListADU depending on received request
				var ProvideUserIdListADU v_aduProvideUserIdList:=
				m_aduProvideUserIdList(v_apduReceived.infoExchangeContent.adus.requestAdus[0].userListRequest.userId);

				//Make the userId-list invalid by setting the userIds to empty
				v_aduProvideUserIdList.userIdList:={{},{},{}};
																	
                // Prepare APDU to be sent
                v_apduForSending:= m_apduNoAuthRespTester(v_apduReceived, v_aduProvideUserIdList);              	

				// send ProvideUserIdList within TIME1
				f_wait(LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				

				// Start timer
                t_step.start(LISTOFUSERS_TIME2_MAX_TC);               	
             	             
              	// Wait for Ack_Apdu within time LISTOFUSERS.TIME2
                //		- NAck_Apdu with aduReasonCode = invalidADU(0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU(0) for ADU#1
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending,{{1, AduReasonCode_invalidADU_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();              			
			} // End of TP_TC_LISTOFUSERS_BI_03
		} // End of Invalid_Behaviour
		
	} // End of group LISTOFUSERS
    

	group DSRC_REPORTABNORMALOBE {
		group Valid_Behaviour {
			testcase TP_TC_DSRC_REPORTABNORMALOBE_BV_01() runs on MainTestComponent system TestAdapter {							
               /**
                * @desc    TP_TC_DSRC_REPORTABNORMALOBE_BV_01: Verify that the TC correctly performs a DSRC.REPORTABNORMALOBE transaction
                * @remark  [16986:2016], Clause 7.4 and Table A.1/1 AND Table A.2/1 AND Table A.26/4
                */

  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
                // Step 1: Trigger IUT with DSRC.REPORTABNORMALOBE_TR_TC_1 to send valid Initiating_APDU containing
                // one or more ADUs of type ReportAbnormalOBEADU containing different combinations of valid
                // and IUT declared values in the following data elements
				//		- userID = at least one element shall be present (ensured in the template);
				//		- dateAndTime = present and valid;
				//		- efcContextMark = present and valid;
				//		- abnormalOBEReason code = present and valid                
				f_sendAndLogTrigger(DSRC_REPORTABNORMALOBE_TR_TC_1);

				//  Wait for DSRC.REPORTABNORMALOBE ADU
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_adusReportAbnormalObe)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus[v_i],mw_aduReportAbnormalObe))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();   						           
			} // End testcase TP_TC_DSRC_REPORTABNORMALOBE_BV_01	
		} // End Valid_Behaviour

		group Invalid_Bahaviour {
               /**
                 * @remark  No TPs have been defined
                 */			
		} // End Invalid_Behaviour		
	} // End DSRC_REPORTABNORMALOBE

	group DSRC_EFCCONTEXTDATA {
		group Valid_Behaviour {
			testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_01: Verify that the TC correctly performs a DSRC.EFCCONTEXTDATA transaction
                 *			for a domain type = dsrcContext  
                 * @remark  [16986:2016], Clause 7.2 and Table A.1/1 AND Table A.2/1 AND Table A.26/2 AND Table A.30/2 = dsrcContext
                 */
 
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_2_implementedDSRCEFCCONTEXTDATA and ICS_A30_2_implementedDSRCCONTEXT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  					
                // Step 1: Tigger IUT with DSRC.EFCCONTEXTDATA_TR_TC_1_A to send valid Initiating_Apdu
                // containing a EFCContextDataADU as the only ADU, with
                //		- domainType = dsrcContext;
                //		- the values of all fields in EFCContextDataADU being within the range specified by the IUT
				f_sendAndLogTrigger(DSRC_EFCCONTEXTDATA_TR_TC_1_DSRC_OPEN);

                // Wait for above specified Initiating_Apdu within time constraints
                // if not received or received outside specification set test fail (done in altstep)

				// PT140 TODO : mw_aduDsrcEfcContextData template existing but details yet to be defined

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_aduDsrcEfcContextData)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_01	
			
			testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_02: Verify that the TC correctly performs a DSRC.EFCCONTEXTDATA transaction
                 *			for a domain type = dsrcClosedContext  
                 * @remark  [16986:2016], Clause 7.2 and Table A.1/1 AND Table A.2/1 AND Table A.26.2 AND Table A.30/2 = dsrcContext
                 */
 			
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_2_implementedDSRCEFCCONTEXTDATA and ICS_A30_2_implementedDSRCCONTEXT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  
				// Step 1: Tigger IUT with DSRC.EFCCONTEXTDATA_TR_TC_1_B to send valid Initiating_Apdu
                // containing a EFCContextDataADU as the only ADU, with
                //		- domainType = dsrcClosedContext;
                //		- the values of all fields in EFCContextDataADU being within the range specified by the IUT
				f_sendAndLogTrigger(DSRC_EFCCONTEXTDATA_TR_TC_1_DSRC_CLOSED);

                // Wait for above specified Initiating_Apdu within time constraints
                // if not received or received outside specification set test fail (done in altstep)

				// PT140 TODO : aduDsrcClosedContextEfcContextData template exsisting but details yet to be defined

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_aduDsrcClosedContextEfcContextData)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_02							
		} // End Valid_Behaviour

		group Invalid_Behaviour {
               /**
                 * @remark  No TPs have been defined
                 */			
		} // End Invalid_Behaviour		
	} // End DSRC_EFCCONTEXTDATA


	group DSRC_BILLINGDETAILS {
		group Valid_Behaviour {
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_01: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=send
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A26.3
                */
				
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  
                // Step 1: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1_SEND to send valid Initiating_Apdu containing BillingDetailsADUs
                // containing all valid permutations of present and not present optional fields and choices that are used
                // in the IUT implementation, all with actionCode = send

				f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_SEND);

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduDsrcBillingDetails:= {actionCode := ActionCode_send_ }}}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time	
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TC);					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_01
			
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_02: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=adjust
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A.36/15 = adjust
                */
 
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  
                // Step 0: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1_ADJUST to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send and adjust the same BillingDetailsId in a second step
                
                f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_ADJUST);

				// receive the BillingDetailsADU

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduDsrcBillingDetails:= {actionCode := ActionCode_send_ }}}) 
           		};                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						f_checkMinimumTStep(DSRC_BILLINGDETAILS_TIME1_MIN_TC);	
					}
				}

				// capture the billingDetailsId for validation in step 2
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs.billingDetailsId;

				// Step 2: Send NAck within time constraints
				f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);				

				// send a negative Ack (except of issueCode "acceptedWithWarning")
				f_sendAndLogApdu(m_apduNAckIndividualIssuesTester(v_apduReceived, {1, AduReasonCode_semanticError_}));

                // Step 2: Wait for IUT to send adjusted BillingDetailsADU
                // with actionCode = adjust
                // with same billingDetailsId as already received billingDetailsId
                
				v_apduToBeReceived := {
				  	mw_apduNoAuthRespIut({{mw_aduDsrcBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_adjust_
				  	}
				  }}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TC);					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_02
						
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_03: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=revoke
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A.36/15 = revoke
                */
 
   				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  
                // Step 1: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1_REVOKE to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send and revoke the same BillingDetailsId in a second step
                
                f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_ADJUST);

				// receive the BillingDetailsADU

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_adusDsrcBillingDetails:= {actionCode := ActionCode_send_ }}}) 
           		};                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						f_checkMinimumTStep(DSRC_BILLINGDETAILS_TIME1_MIN_TC);	
					}
				}

				// capture the billingDetailsId for validation in step 2
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs.billingDetailsId;

				// Step 2: Send NAck within time constraints
				f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
				f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));

                // Step 3: Wait for IUT to send adjusted BillingDetailsADU
                // with actionCode = revoke
                // with billingDetailsId as already received billingDetailsId
                
				v_apduToBeReceived := {
				  	mw_apduNoAuthRespIut({{mw_aduDsrcBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_revoke_
				  	}
				  }}) 
           		}; 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TC);					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_03
		} // End Valid_Behaviour
		
		group Invalid_Behaviour {

               /**
                 * @remark  No TPs have been defined
                 */			
			
		} // End Invalid_Behaviour
		
	} // End DSRC_BILLINGDETAILS


	group DSRC_CONTRACTISSUERLIST {
		group Valid_Behaviour {		
			testcase TP_TC_DSRC_CONTRACTISSUERLIST_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BV_01: Verify that the TC correctly performs
                 *			a DSRC.CONTRACTISSUERLIST transaction with three ContractIssuerListADUs  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.2/1 AND Table A.26/1
                 */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                		              
                // Step 1:
                // Prepare and send Initiating_Apdu containing three ContractIssuerListADUs with differing manufacturerID values
				v_apduForSending := m_apduNoAuthInitTester({
					  	TD_CONTRACT_ISSUER_DATA_VALID_1,
					  	TD_CONTRACT_ISSUER_DATA_VALID_2,
					  	TD_CONTRACT_ISSUER_DATA_VALID_3
					  	});                 
				f_sendAndLogApdu(v_apduForSending);                     
                
                // Start timer
                t_step.start(DSRC_CONTRACTISSUERLIST_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time DSRC.CONTRACTISSUERLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
				} 
				f_closeDownMtc();                	
              } // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BV_01              
		} // End group Valid_Behaviour
					
		group Invalid_Behaviour {	
			testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BI_01: Verify that the TC correctly responds to
                 *			a ContractIssuerListADUs with three different semantically faulty parameters  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.2/1 AND Table A.26/1
                 */

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                        		
                 
                // Step 1:
                // Send Initiating_Apdu containing three ContractIssuerListADUs each one with exactly
                // one incorrect parameter value from the set [uniquePartOfPan, acCrKeyReference, authKeyReference]

				v_apduForSending := m_apduNoAuthInitTester({
					  	TD_CONTRACT_ISSUER_DATA_INVALID_1,
					  	TD_CONTRACT_ISSUER_DATA_INVALID_2,
					  	TD_CONTRACT_ISSUER_DATA_INVALID_3
					});                 
				f_sendAndLogApdu(v_apduForSending); 
                
                // Start timer
                t_step.start(DSRC_CONTRACTISSUERLIST_TIME1_MAX_TC);   

              	// Wait for NAck_Apdu within time DSRC.CONTRACTISSUERLIST.TIME1
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for ADU#1, #2 and #3
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}

					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {
						{1, AduReasonCode_semanticError_},
						{2, AduReasonCode_semanticError_},
						{3, AduReasonCode_semanticError_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}										
				}
				f_closeDownMtc();				            	          				
			} // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_01			

			testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BI_02: Verify that the TC correctly responds to a RequestADU
                 *			sent earlier than allowed  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.2/1 AND Table A.26/1
                 */

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                        		

                // Step 0: Send Initiating_Apdu containing one ContractIssuerListADU
                // Prepare and send one Initiating_Apdu containing exactly one ContractIssuerListADU
                v_apduForSending := m_apduNoAuthInitTester({TD_CONTRACT_ISSUER_DATA_VALID_1});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                                                
                // Step 1: Send second Initiating_Apdu containing one ContractIssuerListADU
                // before DSRC.CONTRACTISSUERLIST.TIMEA_MIN has passed
				f_wait(DSRC_CONTRACTISSUERLIST_TIMEA_MIN_TC / 2);

				v_apduForSending := m_apduNoAuthInitTester({TD_CONTRACT_ISSUER_DATA_VALID_1});                 
				f_sendAndLogApdu(v_apduForSending); 
                
                // Start timer
                t_step.start(DSRC_CONTRACTISSUERLIST_TIME1_MAX_TC);   

				// Step 2: Wait for NAck_Apdu with issueCode=NAck_requestSentTooOften(10)
            	// within the time DSRC.CONTRACTISSUERLIST.TIME1  
              	// if other Ack or not received set test failure --> is done in altstep            	

				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				            	
			} // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_02
		} // End group Invalid_Behaviour
	} // End DSRC_CONTRACTISSUERLIST 

	
	group EXCEPTIONLIST {
		
		group Valid_Behaviour {
		
			testcase TP_TC_EXCEPTIONLIST_BV_01() runs on MainTestComponent system TestAdapter {
										
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BV_01: 1)	Verify that the TC correctly responds to an ExceptionListADU
                 *			for blacklist and whitelist
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				// Start by setting test success
				
				// Loop (first intertation [LIST_TYPE] = black; second iteration [LIST_TYPE] = white)
							
                // Step 1 / loop 1 for black list:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for black list
                v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduBlackValid1});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
					}
				}
				
				// Note: Step 2 may start immediately as no TIMEA is defined for EXCEPTIONLIST
				
				// Step 2 / loop 2 for white list:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduWhiteValid});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
				} 				 
				f_closeDownMtc();              
			} // End of TP_TC_EXCEPTIONLIST_BV_01                              

			testcase TP_TC_EXCEPTIONLIST_BV_02() runs on MainTestComponent system TestAdapter {
										
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BV_02: Verify that the TC correctly responds to an ExceptionListADU
                 *			for discounted user list
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */

 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				// Start by setting test success
							
                // Step 1:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for discounted user list
                v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduDiscountedValid});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_DISCOUNT_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
                //		- Default_Ack, or
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {{1, AduReasonCode_semanticError_}})) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}								
				}			 
				f_closeDownMtc();
			}            
		} // End of group Valid_Behaviour
			
		group Invalid_Behaviour {
		
			testcase TP_TC_EXCEPTIONLIST_BI_01() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_01: Verify that the TC correctly responds to an ExceptionListADU for blacklist containing
            *			exceptionValidityEnd field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */
		
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
							
            	// Prepare Initiating_Apdu containing
 				//		- exactly one ExceptionListADU indicating list type BLACK and containing exceptionValidityEnd of any value

				// prepare this invalid adu below
				const ExceptionListADU c_exceptionListAduBlackInvalid1 := {
					exceptionListVersion := TD_EXCEPTIONLIST_VERSION,
					exceptionListType := ExceptionListType_blackList_,
			  		exceptionValidityStart := fx_getUtc(),
			  		exceptionValidityEnd := fx_getUtc() + 100000, // the presence of this value makes the adu invalid
			  		exceptionListEntries := {{
			  	  		userId := TD_USERID_1,
			  	  		statusType := ExceptionListStatusType_locallyBlocked_,
			  	  		reasonCode := ExceptionListReasonType_notToBeDisclosed_,
			  	  		entryValidityStart := fx_getUtc(),
			  	  		entryValidityEnd := omit,
			  	  		vehicleParameters := TD_VEHICLE_PARAMETERS,
			  	  		actionRequested := ExceptionListActionType_rejectOBE_,
			  	  		efcContextMark := omit,
			  	  		vatId := TD_VAT_ID
					}}
				};
				  			
                v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduBlackInvalid1});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
            	
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               

              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = exceptionListsDateAndTimeRejected(405) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsDateAndTimeRejected(405) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_exceptionListsDateAndTimeRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {{1, AduReasonCode_exceptionListsDateAndTimeRejected_}})) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}								
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_01

			testcase TP_TC_EXCEPTIONLIST_BI_02() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_02: Verify that the TC correctly responds to an ExceptionListADU for blacklist
            *			containing the efcContextMark field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
          
            	// Step 1: Send Initiating_Apdu containing exactly one ExceptionListADU indicating list type BLACK containing
            	//		- efcContextMark of any value
            	
            	// prepare this invalid adu below
 				const ExceptionListADU c_exceptionListAduBlackInvalid2 := {
					exceptionListVersion := TD_EXCEPTIONLIST_VERSION,
					exceptionListType := ExceptionListType_blackList_,
			  		exceptionValidityStart := fx_getUtc(),
			  		exceptionValidityEnd := omit,
			  		exceptionListEntries := {{
			  	  		userId := TD_USERID_2,
			  	  		statusType := ExceptionListStatusType_locallyBlocked_,
			  	  		reasonCode := ExceptionListReasonType_notToBeDisclosed_,
			  	  		entryValidityStart := fx_getUtc(),
			  	  		entryValidityEnd := omit,
			  	  		vehicleParameters := TD_VEHICLE_PARAMETERS,
			  	  		actionRequested := ExceptionListActionType_rejectOBE_,
			  	  		efcContextMark := TD_EFC_CONTEXT_MARK, // the presence of this value makes the adu invalid
			  	  		vatId := TD_VAT_ID
					}}
				};
            	            	
               	v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduBlackInvalid2});
				f_sendAndLogApdu(v_apduForSending);                	 	 	

                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);     
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {{1, AduReasonCode_invalidADU_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_02

			testcase TP_TC_EXCEPTIONLIST_BI_03() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_03: Verify that the TC correctly responds to one APDU
            *			containing more than one ExceptionListADU
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */ 				

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 

            	// Step 1: Send Initiating_Apdu containing more than one ExceptionListADU indicating list type BLACK
               	v_apduForSending := m_apduNoAuthInitTester({
               		c_exceptionListAduBlackValid1,c_exceptionListAduBlackValid2
               	});
               	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
		
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with apduNotOk(3)
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_03

			testcase TP_TC_EXCEPTIONLIST_BI_04() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_04: Verify that the TC correctly responds to an ExceptionListADU
            *			bearing an incorrect value for exceptionListVersion field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */
		
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 

           		// Step 1: Send Initiating_Apdu containing one ExceptionListADU indicating list type BLACK
            	//		- with exceptionListVersion not larger than 0

            	// prepare this invalid adu below
 				const ExceptionListADU c_exceptionListAduBlackInvalid3 := {
					exceptionListVersion := 0, // this makes the adu invalid 
					exceptionListType := ExceptionListType_blackList_,
			  		exceptionValidityStart := fx_getUtc(),
			  		exceptionValidityEnd := omit,
			  		exceptionListEntries := {{
			  	  		userId := TD_USERID_2,
			  	  		statusType := ExceptionListStatusType_locallyBlocked_,
			  	  		reasonCode := ExceptionListReasonType_notToBeDisclosed_,
			  	  		entryValidityStart := fx_getUtc(),
			  	  		entryValidityEnd := omit,
			  	  		vehicleParameters := TD_VEHICLE_PARAMETERS,
			  	  		actionRequested := ExceptionListActionType_rejectOBE_,
			  	  		efcContextMark := omit,
			  	  		vatId := TD_VAT_ID
					}}
				};

               	v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduBlackInvalid3});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
		
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = exceptionListsVersionRejected(400) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsVersionRejected(400) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_exceptionListsVersionRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {{1, AduReasonCode_exceptionListsVersionRejected_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();	
			} // End of TP_TC_EXCEPTIONLIST_BI_04

			testcase TP_TC_EXCEPTIONLIST_BI_05() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_05: Verify that the TC correctly responds to an ExceptionListADU
			*			bearing an incorrect value for exceptionListType field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */   				

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 

             	// Step 1: Send Initiating_Apdu containing one ExceptionListADU indicating exceptionListType = 4

            	// prepare this invalid adu below
 				const ExceptionListADU c_exceptionListAduListType4 := {
					exceptionListVersion := TD_EXCEPTIONLIST_VERSION, 
					exceptionListType := ExceptionListType_otherListType2_, // list type 4 which is nit allowed in IAP
			  		exceptionValidityStart := fx_getUtc(),
			  		exceptionValidityEnd := omit,
			  		exceptionListEntries := {{
			  	  		userId := TD_USERID_1,
			  	  		statusType := ExceptionListStatusType_locallyBlocked_,
			  	  		reasonCode := ExceptionListReasonType_notToBeDisclosed_,
			  	  		entryValidityStart := fx_getUtc(),
			  	  		entryValidityEnd := omit,
			  	  		vehicleParameters := TD_VEHICLE_PARAMETERS,
			  	  		actionRequested := ExceptionListActionType_rejectOBE_,
			  	  		efcContextMark := omit,
			  	  		vatId := TD_VAT_ID
					}}
				};

               	v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduListType4});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
		
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);            
            	
              	// Wait for Ack_Apdu within time TIME_DEFAULT
                //		- NAck_Apdu with aduReasonCode = exceptionListsTypeRejected(401) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsTypeRejected(401) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_exceptionListsTypeRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logApduReceivedAndTStep();
						//Check minumum time and stop timer
						t_step.stop;
						setverdict(pass);
					}					

					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {{1, AduReasonCode_exceptionListsTypeRejected_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logApduReceivedAndTStep();
						//Check minumum time and stop timer
						t_step.stop;
						setverdict(pass);
					}										
				}
				f_closeDownMtc();	
			} // End of TP_TC_EXCEPTIONLIST_BI_05

			testcase TP_TC_EXCEPTIONLIST_BI_06() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_06: Verify that the TC correctly responds to an ExceptionListADU
            *			bearing an incorrect value for userId field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */
  				
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 

	            // Step 1: Send Initiating_Apdu containing one ExceptionListADU of list type BLACK
    	        // and userId = contractSerialNumber present
				
				var ExceptionListADU v_exceptionListADU:=m_aduExceptionList(
					ExceptionListType_blackList_,
					TD_USERID_DISCOUNTED_1,
					ExceptionListStatusType_locallyBlocked_,
					ExceptionListReasonType_notToBeDisclosed_,
					ExceptionListActionType_rejectOBE_
				);
               	v_apduForSending := m_apduNoAuthInitTester({v_exceptionListADU});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
		
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);           
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = exceptionListsUserIdRejected(402) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsUserIdRejected(402) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_exceptionListsUserIdRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {{1, AduReasonCode_exceptionListsUserIdRejected_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();	
			} // End of TP_TC_EXCEPTIONLIST_BI_06

			testcase TP_TC_EXCEPTIONLIST_BI_07() runs on MainTestComponent system TestAdapter {
													
            /**
             * @desc    TP_TC_EXCEPTIONLIST_BI_07: Verify that the TC responds correctly
             *			to a RequestADU sent earlier than allowed
             * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
             */  				

				// Initialisation
				//check if the testcase should be run, activate altsteps on ports, etc 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST and (EXCEPTIONLIST_BLACK_TIME0_MIN_TC > 0);
				f_intialiseMtc(v_runOrNot);                 
							
                // Transaction 1
            	// Step 1: Send Initiating_Apdu containing one valid ExceptionListADU of list type BLACK
            
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for black list
                v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduBlackValid1});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               

                // Transaction 1 / Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
					}
				}
								
				// Transaction 2
            	// Step 1: Send second Initiating_Apdu containing one valid ExceptionListADU of list type BLACK
            	// before TIME0 MIN has passed = immediately after the Ack in Transaction 1 
            	
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for black list
                v_apduForSending := m_apduNoAuthInitTester({c_exceptionListAduBlackValid1});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               

				// Step 2: Wait for NAck_Apdu with issueCode=NAck_requestSentTooOften(10)
            	// within the time EXCEPTIONLIST.BLACK_TIME1 
              	// if negative Ack or not received set test failure --> is done in altstep            	

				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time		
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_07
		} // End of group Invalid_Behaviour 	
	} // End of group EXCEPTIONLIST		
			
//	group TRUSTOBJECTS {
//         
//		group Valid_Behaviour {
//           
//			testcase TP_TC_TRUSTOBJECTS_BV_01() runs on MainTestComponent system TestAdapter {
//						
//                /**
//                 * @desc    TP_TC_TRUSTOBJECTS_BV_01: Verify that the TC correctly provides a TrustObjectADU without TSP request
//                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
//                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_01
//                 */
//
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				
//				var boolean isCertificateOrPublicKey:=false;
//				var boolean isDsrcKeyRef := false;
//				var boolean isMacMasterKey := false;
//				var boolean isDsrcMasterKey := false;
//				var boolean isCertificateRevocationList := false;
//				var boolean isDsrcKey:=false;
//				
//				var integer objectsReceived := 0;
//				// Step 1: Trigger IUT with TRUSTOBJECTS_TR_2
//				f_sendAndLogTrigger(TRUSTOBJECTS_TR_2);
//
//				//  Wait for TRUSTOBJECTS
//				// We expect to receive as many APDUs containing TRUSTOBJECTS ADUs as the number of declared supported trust objects
//				// PT140 TODO: No timeout set, so risk to wait indifinetely to receive all APDUs. Alternative is to set a PIXIT timeout parameter
//
//				alt { //TODO Jan this section of code is roken now. Look at corresponding code in TSP test cases and use as a template
//					[] mtcPort.receive(mw_apduTrustObject) -> value v_apduReceived {
//						// Log what we received
//						f_logApduReceivedAndTStep();	
//						//send Ack whichever object received
//						f_logReceivedWaitAndAcknowledge(v_apduReceived); 							
//						// Look at the type of Trust Object received and set the related variable 				
//						if (match(v_apduReceived, mw_apduTrustObjectCertificate)) 
//							{isCertificateOrPublicKey:=true;}
//						if (match(v_apduReceived, mw_apduTrustObjectPublicKey)) 
//							{isCertificateOrPublicKey:=true;}
//						if (match(v_apduReceived, mw_apduTrustObjectGeneric))
//							{isCertificateRevocationList := true;}
//						if (match(v_apduReceived ,mw_apduTrustObjectDsrcKeyRef)) 
//							{isDsrcKeyRef:=true;}
//						if (match(v_apduReceived ,mw_apduTrustObjectMacKey)) 
//							{isMacMasterKey:=true;}
//						if (match(v_apduReceived, mw_apduTrustObjectDsrcKey)) 
//							{isDsrcKey:=true;}
//	
//						objectsReceived := objectsReceived + 1; // Count the number of trust objects received
//						if (objectsReceived == sizeof(SENT_TRUST_OBJECTS_SUPPORTED)) {
//						  	goto ReceivedAll;
//						}
//						repeat;
//					}										
//				} // End of alt statement
//				// Exiting the alt means that the expected number of Trust Objects have been received
//				label ReceivedAll;
//				if (ICS_A2_1_isDsrc and isCertificateOrPublicKey and isDsrcKeyRef and isMacMasterKey and isDsrcMasterKey) {
//					setverdict(pass);
//				}			 				
//				if (ICS_A2_2_isGnss and isCertificateOrPublicKey and isDsrcKeyRef){
//					setverdict(pass);
//				}			 				
//				f_closeDownMtc();              
//			} // End of TP_TC_TRUSTOBJECTS_BV_01
//
//			testcase TP_TC_TRUSTOBJECTS_BV_02() runs on MainTestComponent system TestAdapter {
//						
//            /**
//            * @desc    TP_TC_TRUSTOBJECTS_BV_02: Verify that the TC correctly responds to a Trust Object received
//            *			from a TSP without having issued a request
//            * @remark  [16986:2016], Clause 6.7 and Table A.1/1
//            * @remark	same as TP_TSP_TRUSTOBJECT_BV_02
//            */
//
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				
//            	// Step 1: Send one valid APDU containing the a valid TrustObjectADU with the only mandatorily supported type in both profiles, for all possible purposes
//				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(m_aduTrustObject
//				({TrustObjectPurposes_dSRCCharging_,TrustObjectPurposes_dSRCAC_,TrustObjectPurposes_oBEInterrogation_,TrustObjectPurposes_oBEInterrogationAC_}, dsrcKeyRefObjectTESTER_VALUE));                 
//				f_sendAndLogApdu(v_apduRespondedTo);                 
//            	// Step 2: Wait for positive Ack within TRUSTOBJECTS.TIME2
//				// Set timer
//            	t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                 
//			
//				alt {
//					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduRespondedTo)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME2_MIN_TC);
//						setverdict(pass);
//					} 
//				} // End of Alt statement 
//				f_closeDownMtc();                   
//			} // End of TP_TC_TRUSTOBJECTS_BV_02
//
//			testcase TP_TC_TRUSTOBJECTS_BV_03() runs on MainTestComponent system TestAdapter {
//						
//                /**
//                 * @desc    TP_TC_TRUSTOBJECTS_BV_03: Verify that the TC correctly provides a TrustObjectADU
//                 *			following a TSP request
//                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
//                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_03
//                 */
//
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				// Loop in all available types of trustobject supported by the IUT as specified by the length of SENT_TRUST_OBJECTS_SUPPORTED Pixit record
//
//				var integer v_trustObjectsToBeSent := sizeof(SENT_TRUST_OBJECTS_SUPPORTED);
//				for (var integer v_trustObjectsReceived :=1; v_trustObjectsReceived<v_trustObjectsToBeSent;v_trustObjectsReceived:=v_trustObjectsReceived+1)
//					{
//						// Prepare a request of a Trust Object by taking allowed type and purpose from the RECEIVED_TRUST_OBJECTS_SUPPORTED Pixit value
//						
//						var integer v_requestedTrustObjectType := SENT_TRUST_OBJECTS_SUPPORTED[v_trustObjectsReceived].trustObjectType;
//						var TrustObjectPurposes v_requestedTrustObjectPurposes := SENT_TRUST_OBJECTS_SUPPORTED[v_trustObjectsReceived].trustObjectPurpose;
//						
//						var InfoExchange v_apduRequestForTrustObject := m_apduNoAuth(
//							m_apciInitTester, Adus:{
//								requestAdus:= {
//									requestedADUType:= 3,
//									requestedTrustObject:={
//										trustObjectSpec:={
//											typeOfTrustObject := v_requestedTrustObjectType,
//					    					purposesOfTrustObject := v_requestedTrustObjectPurposes
//					    				}
//									}
//								}
//							}
//						);
//						f_sendAndLogApdu(v_apduRequestForTrustObject);
//			
//						// Set timer
//                		 t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TC);
//						// Step #2: Wait for TrustObjects ADU
//						// Either we receive an APDU containing  TrustObject or the timeout expires
//                 		alt {
//                      		[] mtcPort.receive(mw_apduTrustObject) -> value v_apduReceived {
//								f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TC);  
//
//                        		// Step #3: Send DefaultACK with correct identifier
//								f_logReceivedWaitAndAcknowledge(TRUSTOBJECTS_TYPE1_TIME2_MIN_TC);
//                      			}
//                    		} // End of alt statement
//						}; // end of for statement
//				//Set verdict
//				setverdict(pass);
//				f_closeDownMtc(); 				 
//
//			} // End of TP_TC_TRUSTOBJECTS_BV_03
//
//			testcase TP_TC_TRUSTOBJECTS_BV_04() runs on MainTestComponent system TestAdapter {
//						
//                /**
//                 * @desc    TP_TC_TRUSTOBJECTS_BV_04: Verify that the TC correctly requests and responds to a TrustObjectADU
//                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
//                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_04
//                 */
//  
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				
//				// Step 1: Trigger IUT with TRUSTOBJECTS_TR_1
//				f_sendAndLogTrigger(TRUSTOBJECTS_TR_1);
//				//  Wait for request for TRUSTOBJECTS
//				// Loop in all available types of trustobject requested supported by the IUT by repeating receive
//				var integer v_expectedTrustObjectRequests := sizeof(SENT_TRUST_OBJECTS_SUPPORTED);
//				var integer v_receivedTrustObjects := 0;
//				// Set timer
//                t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TC);                 
//				alt {
//					[] mtcPort.receive(mw_apduRequestTrustObjects) -> value v_apduReceived {
//						// Log what we received
//						f_logApduReceivedAndTStep();
//						t_step.stop;
//						v_receivedTrustObjects := v_receivedTrustObjects + 1;
//                		// Step 1: Send one valid APDU containing one valid TrustObjectADU
//
//						// Analysis of what requested and what to be sent						
//						if (ispresent(v_apduReceived.infoExchangeContent.adus.requestAdus.trustObjectRequest.requestedTrustObject.trustObjectId)) {
//							f_addLogEntry("Received a request for a specific TrustObjectId, this is not supported according to CEN/TS 16986:2016");
//							setverdict(fail);
//							break;					
//							}
//						var TrustObjectSpec v_requestedTrustObjectSpec := v_apduReceived.infoExchangeContent.adus.requestAdus.trustObjectRequest.requestedTrustObject.trustObjectSpec;
//						var TrustObjectTypes v_requestedTrustObjectType := v_requestedTrustObjectSpec.typeOfTrustObject;
//						var RecOfTrustObjectPurposes v_requestedTrustObjectPurposesRecords := v_requestedTrustObjectSpec.purposesOfTrustObject;
//						var InfoExchange v_apduToSend; 
//						                												
//						//TODO this is not complete! THere are other possibilities as well that can be requested
//						if (v_requestedTrustObjectType == TrustObjectTypes_certificate_){
//							v_apduToSend := m_apduTrustObjectResponse(
//								v_apduReceived, 
//								v_requestedTrustObjectPurposesRecords,
//								TD_CERTIFICATE_OBJECT			
//								);
//							};
//						if (v_requestedTrustObjectType == TrustObjectTypes_publicKey_){
//							v_apduToSend := m_apduTrustObjectResponse(
//								v_apduReceived, 
//								v_requestedTrustObjectPurposesRecords,
//								TD_PUBLICKEY_OBJECT
//								);                 												
//							};
//						if (v_requestedTrustObjectType == TrustObjectTypes_symmetricKey_){
//							v_apduToSend := m_apduTrustObjectResponse(
//								v_apduReceived, 
//								v_requestedTrustObjectPurposesRecords,
//								TD_DSRCKEY_OBJECT
//								);                 												
//							};
//						f_sendAndLogApdu(v_apduToSend);                 
//                
//                		// Step 2: Wait for positive Ack within TRUSTOBJECTS.TIME2
//						// Set timer
//                 		t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                 
//						alt {
//							[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToSend)) -> value v_apduReceived {
//								// Log what we received
//								f_logApduReceivedAndTStep();
//								t_step.stop;
//							}
//						} // End of second alt 
//					
//						if (v_receivedTrustObjects == v_expectedTrustObjectRequests) {
//							setverdict(pass);
//							break;  
//						};
//	                	t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TC);  // Restart timer               
//						repeat;
//					}	
//				} // End of first alt 					
//				f_closeDownMtc();                  
//
//			} // End of TP_TC_TRUSTOBJECTS_BV_04
//		} // End group Valid_Behaviour
//		
//		group Invalid_Behaviour {
//		
//			testcase TP_TC_TRUSTOBJECTS_BI_01() runs on MainTestComponent system TestAdapter {   
// 		
//                /**
//                 * @desc    TP_TC_TRUSTOBJECTS_BI_01: Verify that the TC correctly responds to a TrustObjectADU received
//                 *			without having issued a request and containing incorrect ADU parameters
//                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
//                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_01
//                 */
//
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//
//				v_apduForSending := m_apduNoAuthInitTester(m_aduTrustObjectInvalidStatus);                 
//				f_sendAndLogApdu(v_apduForSending);                 
//                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
//				// Set timer
//                t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                		
//
//				alt {
//					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduRespondedTo, AduReasonCode_invalidADU_)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
//						setverdict(pass);
//						}
//					[] mtcPort.receive(mw_apduNAck_IndividualAdus(v_apduRespondedTo, {{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}})) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
//						setverdict(pass);
//						}
//					} // End of Alt statement
//				f_closeDownMtc();                   
//                          
//			} // End of TP_TC_TRUSTOBJECTS_BI_01 
// 
// 			testcase TP_TC_TRUSTOBJECTS_BI_02() runs on MainTestComponent system TestAdapter {   
// 		
//                /**
//                 * @desc    TP_TC_TRUSTOBJECTS_BI_02: Verify that the TC correctly responds to more than one correct TrustObjectADU
//                 *			in the same APDU without having issued a request
//                 *			without having issued a request and containing incorrect ADU parameters
//                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
//                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_02
//                 */
//
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//
//				// Set two different TrustObject adus by varying the type of trust object 
//				v_apduForSending := m_apduNoAuthInitTester(
//					{
//					 m_aduTrustObject(
//						{TrustObjectPurposes_dSRCCharging_,TrustObjectPurposes_dSRCAC_,TrustObjectPurposes_oBEInterrogation_,TrustObjectPurposes_oBEInterrogationAC_},
//						dsrcKeyRefObjectTESTER_VALUE),
//					 m_aduTrustObject(
//					 	{TrustObjectPurposes_dSRCCharging_},
//					 	certificateTESTER_OBJECT) }
//					);                 
//				f_sendAndLogApdu(v_apduForSending);                 
//                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
//				// Set timer
//                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                		
//				//Create parameters for the m_apduNAck			
//
//				alt {
//					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduRespondedTo, AduReasonCode_semanticError_)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
//						setverdict(pass);
//						}
//					[] mtcPort.receive(mw_apduNAck_IndividualAdus(v_apduRespondedTo, {{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}})) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
//						setverdict(pass);
//						}
//					} // End of Alt statement
//				f_closeDownMtc();                   
//
//			} // End of TP_TC_TRUSTOBJECTS_BI_02 
// 
//			testcase TP_TC_TRUSTOBJECTS_BI_03() runs on MainTestComponent system TestAdapter {   
// 		
//                /**
//                 * @desc    TP_TC_TRUSTOBJECTS_BI_03: Verify that the TC correctly responds to a request
//                 *			for a not supported Trust Object
//                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
//                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_03
//                 */
//
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//
//				// Prepare an invalid certificate (not supported by the profile)
//				var InfoExchange v_apduRespondedTo := m_apduNoAuthInitTester(TrustObjectADU({TrustObjectPurposes_certIssuing_},invalidTESTERGenericObject));                 
//				f_sendAndLogApdu(v_apduRespondedTo);                 
//                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
//				// Set timer
//                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                		
//				//Create parameters for the m_apduNAck			
//
//				alt {
//					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduRespondedTo, AduReasonCode_semanticError_)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
//						setverdict(pass);
//						}
//					[] mtcPort.receive(mw_apduNAck_IndividualAdus(v_apduRespondedTo, {{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}})) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
//						setverdict(pass);
//						}
//					} // End of Alt statement
//				f_closeDownMtc();                   
//
//           } // End of TP_TC_TRUSTOBJECTS_BI_03 
// 
//			testcase TP_TC_TRUSTOBJECTS_BI_04() runs on MainTestComponent system TestAdapter {   
// 		
//                /**
//                 * @desc    TP_TC_TRUSTOBJECTS_BI_04: Verify that the TC correctly responds to a RequestADU sent earlier than allowed
//                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
//                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_04
//                 */
//
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//
//				// Step1: send RequestADU by specifying the type of trustobject
//				// Prepare a request of a Trust Object by taking allowed type and purpose from the SENT_TRUST_OBJECTS_SUPPORTED Pixit value
//				var RequestADU requestAdu :={
//					requestedADUType := 3,
//					requestedTrustObject:={
//						trustObjectSpec := {
//							typeOfTrustObject := SENT_TRUST_OBJECTS_SUPPORTED[1].trustObjectType,
//							purposesOfTrustObject := SENT_TRUST_OBJECTS_SUPPORTED[1].trustObjectPurpose}
//						}
//				}
//
//				var Adus requestAduInWrapper:= {requestAdus:={requestAdu}};
//				
//				var InfoExchange v_firstApduRequest:=m_apduNoAuthInitTester(requestAduInWrapper); 
//				var InfoExchange v_secondApduRequest:=m_apduNoAuthInitTester(requestAduInWrapper); 
//								
//				// Now send the first apdu
//				f_sendAndLogApdu(v_firstApduRequest);
//				
//       			//Immediately send same ADU with different APDUid				
//				f_sendAndLogApdu(v_secondApduRequest);
//                              
//				//Set timer
//				t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);
//                
//				// Step #2: Wait for NAck ADU				 					
//				// Either we receive an APDU containing  NAck or the timeout expires
//				// timeout expiration is handled in the altstep branch
//				
//				alt {
//					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_secondApduRequest)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME2_MIN_TC);  
//						setverdict(pass);
//						}
//					} // End of Alt statement 
//				f_closeDownMtc();              
//
//           } // End of TP_TC_TRUSTOBJECTS_BI_04 
// 
//			testcase TP_TC_TRUSTOBJECTS_BI_05() runs on MainTestComponent system TestAdapter {   
// 		
//                /**
//                 * @desc    TP_TC_TRUSTOBJECTS_BI_05: Verify that the TC correctly responds to a 
//                 * @desc 	TrustObjectADU sent earlier than allowed
//                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
//                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_05
//                 */
//
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//
//				// Step1: prepare TrustObjectADU by specifying KeyRef as type of trustobject
//				var TrustObjectADU v_trustObjectAdu := m_aduTrustObject(
//						{TrustObjectPurposes_dSRCCharging_,TrustObjectPurposes_dSRCAC_,TrustObjectPurposes_oBEInterrogation_,TrustObjectPurposes_oBEInterrogationAC_},
//						TrustObjectCode:{dsrcKeyRef := dsrcKeyRefObjectTESTER_VALUE}
//				);                 
//				
//				var InfoExchange v_firstApduToBeSent := m_apduNoAuthInitTester(v_trustObjectAdu);
//				var InfoExchange v_secondApduToBeSent := m_apduNoAuthInitTester(v_trustObjectAdu);
//
//				// Send the first apdu
//				f_sendAndLogApdu(v_firstApduToBeSent);
//				// Send second apdu immediately
//				f_sendAndLogApdu(v_secondApduToBeSent);				
//
//				//Set timer
//				t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TC);
//                
//				// Step #2: Wait for NAck ADU				 					
//				// Either we receive an APDU containing  NAck or the timeout expires
//				// timeout expiration is handled in the altstep branch
//				alt {
//					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_secondApduToBeSent)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TC);  
//						setverdict(pass);
//					}
//				} 
//				f_closeDownMtc(); 
//			           
//             
//           	} // End of TP_TC_TRUSTOBJECTS_BI_05   
// 		} // End group Invalid_Behaviour
//	} // End of group TRUSTOBJECTS		

	group PAYMENTCLAIM {
	
		group Valid_Behaviour {	
			testcase TP_TC_PAYMENTCLAIM_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_01_DSRC: Verify that the TC correctly performs the PAYMENTCLAIM 
                 * @desc	transaction with actionCode=send 
                 * @remark  [16986:2016], Clause 6.8 and Table A.1/1 AND Table A.7/5
                 */
                  
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_5_implementedPAYMENTCLAIM;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                  
                // Step 0:
                // Let IUT perform one BILLINGDETAILS complete and sucessful transaction
                // this step is differnet for TCs operating a DSRC Toll Domain or a GNSS Toll Domain

				if (ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS) {
                
					f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_SEND);

					var InfoExchange v_apduToReceive := 	
					mw_apduNoAuthInitIut({mw_aduDsrcBillingDetails});                 

                	// Wait for above specified APDU within time constraints
                	// if not received or received outside specification or time constraints set test fail (done in the altstep)

					alt {
						[] mtcPort.receive(v_apduToReceive) -> value v_apduReceived {
							// Log what we received, no minimum time	
							f_logApduReceivedAndTStep();

						}
					} // End of alt statement

					// Step 2: Send Ack within time constraints
					f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TC);
					f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
				} // end if-branch
				else { // else-branch for GNSS Toll Charger
					
					f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);

					var InfoExchange v_apduToReceive := {
				  		mw_apduNoAuthInitIut({{mw_aduGnssBillingDetails:= {actionCode := ActionCode_send_ }}}) 
           			};                 

                	// Wait for above specified APDU within time constraints
                	// if not received or received outside specification or time constraints set test fail (done in the altstep)

					alt {
						[] mtcPort.receive(v_apduToReceive) -> value v_apduReceived {
							// Log what we received, no minimum time	
							f_logApduReceivedAndTStep();
						}
					} // End of alt statement

					// Step 2: Send Ack within time constraints
					f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
					f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
				}; // end else-branch      	                              
  
 				// define templates required for later matching with data in PaymentClaim
 				var template UserIdList v_receivedBillingDetailsUserIdList, v_receivedPaymentClaimUserIdList;
 				// Note: Type definition for this is in module templates
 				var template BillingDetailsIdList v_receivedBillingDetailsIdList;
				
				var integer v_numberOfReceivedBillingDetailsAdus, v_numberOfReceivedPaymentClaimAdus;
 				
 				v_numberOfReceivedBillingDetailsAdus := lengthof(v_apduReceived.infoExchangeContent.adus);
 				
 				// fill templates (two records of) with received data
 				for (var integer v_i := 0; v_i < v_numberOfReceivedBillingDetailsAdus; v_i := v_i +1) {
 					v_receivedBillingDetailsUserIdList[v_i] := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i].userId;
 					v_receivedBillingDetailsIdList[v_i] := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i].relatedBillingDetails;
				}
  				  
                // Step 1:
                // Payment Claim transaction

                // Start timer for TIMEB_MAX (time between receiving the AckADU of the BillingDeatails transaction and
                // sending an corresponding PaymentClaim ADU)
                t_step.start(PAYMENTCLAIM_TIMEB_MAX_TC);               

				// Send trigger (IuT to perform a Payment Claim transaction
				// containing exactly one PaymentClaim ADU with action_code = send 
				f_sendAndLogTrigger(PAYMENTCLAIM_TR_TC_1_SEND);

                // Prepare APDU to be received
				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduPaymentClaim:= {
				  		paymentClaimStatus := PaymentClaimStatus_firstVersion_,
				  		actionCode := ActionCode_send_ }}}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail (done in the altstep)

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no minimum time required	

						f_logApduReceivedAndTStep();
							
						// check inside the adu for each billing details id in the billing details list
						// if this billing details ID (and user id used in the adu) is inside the list of pairs received in billing details  
						var boolean v_matchingUserIdBillingDetailsIdPair;
						for (var integer v_j; v_j < lengthof(v_apduReceived.infoExchangeContent.adus.paymentClaimADUs.referenceDetailsList.billingDetailsList); v_j := v_j + 1) {
						// go through list of pairs of userIds and billingDeatilsIds receive in billing details
							v_matchingUserIdBillingDetailsIdPair := false;
							for (var integer v_k := 0; v_k < v_numberOfReceivedBillingDetailsAdus; v_k := v_k + 1) {
								if ((v_apduReceived.infoExchangeContent.adus.paymentClaimADUs.userId == v_receivedBillingDetailsUserIdList[v_k])
								and
								(v_apduReceived.infoExchangeContent.adus.paymentClaimADUs.referenceDetailsList.billingDetailsList[v_j] == v_receivedBillingDetailsIdList[v_k])) {
									v_matchingUserIdBillingDetailsIdPair := true;
								} else { //matching pair not found. Test failed
									v_matchingUserIdBillingDetailsIdPair := false;
									f_addLogEntry("Fail. UserId and/or billingDetailsId in PaymentClaim do not match with those in BillingDetails");
									setverdict(fail);
									stop;
								}
							}
						}			
						if (v_matchingUserIdBillingDetailsIdPair) { 
							// Step 2: Send Ack within time constraints
							f_wait(PAYMENTCLAIM_TIME1_MIN_TC);
							f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
							// Set test success
							setverdict(pass);
						} 
					} // end this alt-branch
				} // End of alt statement            	                              
				f_closeDownMtc();            
			} // End of TP_TC_LISTOFUSERS_BV_01
	 				
			testcase TP_TC_PAYMENTCLAIM_BV_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_02: Verify that the TC correctly performs the PAYMENTCLAIM transaction with
                 *			actionCode=revoke and adjust  
                 * @remark  [16986:2016], Clause 6.8 and Table A.1/1 AND Table A.7/5
                 */

  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_5_implementedPAYMENTCLAIM;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                  
                // Step 0:
                // Let IUT perform one BILLINGDETAILS complete and sucessful transaction
                // this step is differnet for TCs operating a DSRC Toll Domain or a GNSS Toll Domain
				var InfoExchange v_apduToBeReceived;
				if (ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS) {
                
					f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_SEND);

					v_apduToBeReceived := {
				  		mw_apduNoAuthInitIut({m_aduDsrcBillingDetails}) 
           			};                 

                	// Wait for above specified APDU within time constraints
                	// if not received or received outside specification or time constraints set test fail (done in the altstep)

					alt {
						[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
							// Log what we received, no minimum time	
							f_logReceivedThenCheckAndStopTime(0.0);					              		
						}
					} // End of alt statement

					// Step 2: Send Ack within time constraints
					f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TC);
					
					f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
				} // end if-branch
				else { // else-branch for GNSS Toll Charger
					
					f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);

					v_apduToBeReceived := {
				  		mw_apduNoAuthInitIut({{mw_aduGnssBillingDetails:= {actionCode := ActionCode_send_ }}}) 
           			};                 

                	// Wait for above specified APDU within time constraints
                	// if not received or received outside specification or time constraints set test fail (done in the altstep)

					alt {
						[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
							// Log what we received, no minimum time	
							f_logReceivedThenCheckAndStopTime(0.0);					              		
						}
					} // End of alt statement
					
					// Step 2: Send Ack within time constraints
					f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
					f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
				} // end else-branch      	                              

 				// define templates required for later matching with data in PaymentClaim
 				var template UserIdList v_receivedBillingDetailsUserIdList, v_receivedPaymentClaimUserIdList;
 				// Note: Type definition for this is in module templates
 				var template BillingDetailsIdList v_receivedBillingDetailsIdList;
				
				var integer v_numberOfReceivedBillingDetailsAdus, v_numberOfReceivedPaymentClaimAdus;
 				
 				v_numberOfReceivedBillingDetailsAdus := lengthof(v_apduReceived.infoExchangeContent.adus);
 				
 				// fill templates (two records of) with received data
 				for (var integer v_i := 0; v_i < v_numberOfReceivedBillingDetailsAdus; v_i := v_i +1) {
 					v_receivedBillingDetailsUserIdList[v_i] := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i].userId;
 					v_receivedBillingDetailsIdList[v_i] := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i].relatedBillingDetails;
				}
  				  
                // Step 1:
                // Perform a full and valid Payment Claim transaction

                // Start timer for TIMEB_MAX (time between receiving the AckADU of the BillingDeatails transaction and
                // sending an corresponding PaymentClaim ADU)
                t_step.start(PAYMENTCLAIM_TIMEB_MAX_TC);               

				// Send trigger (IuT to perform a Payment Claim transaction
				// containing exactly one PaymentClaim ADU with action_code = send 
				f_sendAndLogTrigger(PAYMENTCLAIM_TR_TC_1_SEND);

                // Prepare APDU to be received
				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduPaymentClaim:= {
				  		paymentClaimStatus := PaymentClaimStatus_firstVersion_,
				  		actionCode := ActionCode_send_ }}}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail (done in the altstep)

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no minimum time required	

						f_logApduReceivedAndTStep();
							
						// check inside the adu for each billing details id in the billing details list
						// if this billing details ID (and user id used in the adu) is inside the list of pairs received in billing details  
						var boolean v_matchingUserIdBillingDetailsIdPair;
						for (var integer v_j; v_j < lengthof(v_apduReceived.infoExchangeContent.adus.paymentClaimADUs.referenceDetailsList.billingDetailsList); v_j := v_j + 1) {
						// go through list of pairs of userIds and billingDeatilsIds receive in billing details
							f_logApduReceivedAndTStep();
							v_matchingUserIdBillingDetailsIdPair := false;
							for (var integer v_k := 0; v_k < v_numberOfReceivedBillingDetailsAdus; v_k := v_k + 1) {
								if ((v_apduReceived.infoExchangeContent.adus.paymentClaimADUs.userId == v_receivedBillingDetailsUserIdList[v_k])
								and
								(v_apduReceived.infoExchangeContent.adus.paymentClaimADUs.referenceDetailsList.billingDetailsList[v_j] == v_receivedBillingDetailsIdList[v_k])) {
									v_matchingUserIdBillingDetailsIdPair := true;
								} else { //matching pair not found. Test failed
									v_matchingUserIdBillingDetailsIdPair := false;
									f_addLogEntry("Fail. UserId and/or billingDetailsId in PaymentClaim do not match with those in BillingDetails");
									setverdict(fail);
									stop;
								}
							}
						}			
						if (v_matchingUserIdBillingDetailsIdPair) { 
							f_addLogEntry("Billing details in payment claim received correspond t the billing details in the previous billing details trasnaction");
							// Step 2: Send Ack within time constraints
							f_wait(PAYMENTCLAIM_TIME1_MIN_TC);
						} 
					} // end this alt-branch
				} // End of alt statement            	                              

				// Step 2: Send NAck (except of issueCode "acceptedWithWarning")
				// within time constraints to initiate the following adjust
				f_wait(PAYMENTCLAIM_TIME1_MIN_TC);
				f_sendAndLogApdu(m_apduNAckIndividualIssuesTester(v_apduReceived, {1, AduReasonCode_semanticError_}));

                // Step 3:
                // Let the IuT perform a PaymentClaim transaction with exactly one PaymentClaim ADU with actionCode = ADJUST
                // Note: It may be the case the IuT send exactly the same pay payment claims as before as they might not contain errors

                // Prepare APDU to be received
                // PaymentId shall be the same as in the previous PaymentClaim ADU
				v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduPaymentClaim:= {
				  		paymentClaimId := v_apduReceived.infoExchangeContent.adus.paymentClaimADUs.paymentClaimId,
				  		paymentClaimStatus := PaymentClaimStatus_amendedVersion_ ,
				  		actionCode := ActionCode_adjust_ }}}) 
           		};                 

 				// Send trigger
				f_sendAndLogTrigger(PAYMENTCLAIM_TR_TC_1_ADJUST);

				// start time to check compliance to TIMEA_MIN
				// Note: there is no maximum time defined but a timer is started check below minimum PAYMENTCLAIM_TIMEA_MIN_TC 
                t_step.start(c_veryLongTime);                
 
                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail (done in the altstep)
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no minimum time required	
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIMEA_MIN_TC);
						f_addLogEntry("Adjust transaction passed");
					}
				}

				// Step 4: Send Ack within time constraints
				f_wait(PAYMENTCLAIM_TIME1_MIN_TC);
				f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
                 
                // Step 5:
                // Let the IuT perform a PaymentClaim transaction with exactly one PaymentClaim ADU with actionCode = REVOKE

                // Prepare APDU to be received
                // PaymentId shall be the same as in the previous PaymentClaim ADU
				v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduPaymentClaim:= {
				  		paymentClaimId := v_apduReceived.infoExchangeContent.adus.paymentClaimADUs.paymentClaimId,
				  		paymentClaimStatus := PaymentClaimStatus_amendedVersion_,
				  		actionCode := ActionCode_revoke_ }}}) 
           		};                 

				// Send trigger
				f_sendAndLogTrigger(PAYMENTCLAIM_TR_TC_1_REVOKE);

				// start time to check compliance to TIMEEA_MIN
				// Note: there is no maximum time defined but a timer shall be started to check below minimum PAYMENTCLAIM_TIMEA_MIN_TC 
                t_step.start(c_veryLongTime);                

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail (done in the altstep)
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no minimum time required	
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIMEA_MIN_TC);
						// Step 6: Send Ack within time constraints
						f_wait(PAYMENTCLAIM_TIME1_MIN_TC);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				}
				f_closeDownMtc();            																
			} // End of TP_TC_PAYMENTCLAIM_BV_02
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {
		
               /**
                 * @remark  No TPs have been defined
                 */
 		
 		} // End Invalid_Behaviour
 		
 	} // End PAYMENTCLAIM	

	group GNSS_TOLLDECLARATION {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_TOLLDECLARATION_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_01: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = send
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
								
                // Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send

                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = send                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for discounted user list
                // TODO Jan: Define tester data required inside the module TesterData               

				v_apduForSending := m_apduTollDeclarationsTen;
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
                
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass)												
					}
				}	
				f_closeDownMtc();						 
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_01

			testcase TP_TC_GNSS_TOLLDECLARATION_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_02: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = revoke
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 

                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = send

				v_apduForSending := m_apduTollDeclarationsTen;
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail 

				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
											
                // Step 2:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations with tollDeclarationId = same value as already received toll declarations and
                // containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = revoke
                             
                // Send second Initiating_Apdu containing ten valid TollDeclarationADUs with actionCode = revoke
                // before GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP has passed
				f_wait(GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP / 2);

                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = revoke
                // Note that it is required to send again with same TollDeclarationId,
                // same TollDeclarations and same Charge Report Id
				v_apduForSending := m_apduTollDeclarationsTen(ActionCode_revoke_);
				                
                // Step 3:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
						//Set verdict
						setverdict(pass)												
					}					
				}
				f_closeDownMtc();				
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_02

			testcase TP_TC_GNSS_TOLLDECLARATION_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_03: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = adjust
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
				// Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 

               // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = send

				v_apduForSending := m_apduTollDeclarationsTen;
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
								
                // Wait for NAck_Apdu within GNSS.TOLLDECLARATION.TIME1             
                // if not received or received outside specification or time constraints set test fail 
				// TODO JAN / PT140: below Ack to be preplaced by a negative ack according to the specifications of is16986
				// for this case of adjusting TollDeclarationADUs
				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
								
                // Step 2:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations with tollDeclarationId = same value as already received toll declarations and
                // containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = adjust

                // Send second Initiating_Apdu containing ten valid TollDeclarationADUs with actionCode = adjust
                // before GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP has passed
				f_wait(GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP / 2);
				
                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = adjust
                // Note that it is required to send again with same TollDeclarationId,
                // but "corrected" TollDeclarations and a new Charge Report Id
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_11,
						11,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						TD_USAGE_STATEMENT_VALID_12,
						12,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3},
						TD_USAGE_STATEMENT_VALID_13,
						13,
						ActionCode_adjust_),							
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4},
						TD_USAGE_STATEMENT_VALID_14,
						14,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5},
						TD_USAGE_STATEMENT_VALID_15,
						15,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 6},
						TD_USAGE_STATEMENT_VALID_16,
						16,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 7},
						TD_USAGE_STATEMENT_VALID_17,
						17,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 8},
						TD_USAGE_STATEMENT_VALID_18,
						18,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 9},
						TD_USAGE_STATEMENT_VALID_19,
						19,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 10},
						TD_USAGE_STATEMENT_VALID_20,
						20,
						ActionCode_adjust_)
				});
				
                // Step 3:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
						//Set verdict
						setverdict(pass)												
					}
				}
				f_closeDownMtc();				
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_03
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_01: Verify that the TC correctly responds to an APDU containing
                *			a number of TollDeclarationADUs which exceeds PARAM1_MAX
                *			that are not the same as the original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
								
                // Step 1:
                // Send Initiating_Apdu containing TollDeclarationADUs
                // with valid and IUT declared values but exceeding GNSS.TOLLDECLARATION.PARAM1_MAX

               // Prepare and send an Initiating_Apdu with PARAM1_MAX + 1 TollDeclarationADUs with actionCode = send

				 
				var Adus v_adusToBeSent; //List of ADUs to be sent 
				var UsageStatement v_usageStatementToBeSent;

				for (var integer v_loop := 0; v_loop < GNSS_TOLLDECLARATIONS_PARAM1_MAX_TC; v_loop := v_loop + 1) {	
 					v_usageStatementToBeSent := {
						usageStatementId := v_loop,
						tollContext := TD_TOLL_CONTEXT,
						aggregatedSingleTariffClassSession := TD_SINGLE_TARIFF_CLASS_SESSION,
						listOfChargeObjects:=TD_LIST_OF_CHARGE_OBJECTS,
						listOfRawUsageData := TD_LIST_OF_RAW_USAGE_DATA,
						additionalUsageInformation := omit
					};
 					v_adusToBeSent[v_loop] := m_aduTollDeclarationToSendOneObe(
							{TD_IDENTIFIER, v_loop},
							v_usageStatementToBeSent,
							v_loop,
							ActionCode_send_);
				}		
 					
				v_apduForSending := m_apduNoAuthInitTester(v_adusToBeSent);
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
                
                // Step 2:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({n,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
                
                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams_2 := {{GNSS_TOLLDECLARATIONS_PARAM1_MAX_TC, AduReasonCode_semanticError_}};

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_01
		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_02: Verify that the TC correctly responds to an APDU containing
                * 			valid TollDeclarationADUs with actionCode = revoke but tollDeclarationIds
                *			that are not the same as the original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // gnssTollDeclarations containing valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = send

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
					});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
								
                // Step 2:
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // a gnssTollDeclaration with tollDeclarationId /= the value as already received toll declaration and
				// containing valid and IUT declared values for
				// 		- chargeReport,
				//		- chargeReportUsageStatementList and
				//		- usageStatement; and
				//		- actionCode = revoke

                // Send second Initiating_Apdu containing one valid TollDeclarationADUs with actionCode = revoke
                // before GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP has passed
				f_wait(GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP / 2);

                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = revoke
                // same TollDeclarations and same Charge Report Id
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						TD_USAGE_STATEMENT_VALID_2,
						2,
						ActionCode_revoke_)
					});
                
                // Step 3:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams_2 := {{1, AduReasonCode_semanticError_}};

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_02

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_03: Verify that the TC correctly responds to an APDU containing
                *			valid TollDeclarationADUs with actionCode = adjust but tollDeclarationIds
                *			that are not the same the as original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // gnssTollDeclarations containing valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = send

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
					});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
								
                // Step 2:
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // a gnssTollDeclaration with tollDeclarationId /= the value as already received toll declaration and
				// containing valid and IUT declared values for
				// 		- chargeReport,
				//		- chargeReportUsageStatementList and
				//		- usageStatement; and
				//		- actionCode = adjust

                // Send second Initiating_Apdu containing one valid TollDeclarationADUs with actionCode = revoke
                // before GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP has passed
				f_wait(GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP / 2);

                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = revoke
                // same TollDeclarations and same Charge Report Id
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						TD_USAGE_STATEMENT_VALID_2,
						2,
						ActionCode_adjust_)
					});
                
                // Step 3:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams_2 := {{1, AduReasonCode_semanticError_}};

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_03

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_04: Verify that the TC correctly responds to an APDU
                *			containing valid TollDeclarationADUs with tollDeclarationIds being not unique
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing two TollDeclarationADU containing
				//		- tollDeclarationId = same values in the two toll declarations, and
				//		- gnssTollDeclarations with valid and IUT declared values, and
				//		- actionCode = send
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = send

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						2,
						ActionCode_send_)
					});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with apduAckCode = apduNotOK (3)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams := {{0, ApduReasonCode_apduNotOK_}};

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_04
               		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_05: Verify that the TC correctly responds to an APDU containing
                *			valid TollDeclarationADUs with gnssTollDeclaration of Choice AuthenticatedChargeReport
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing
				//		- gnssTollDeclaration of Choice AuthenticatedChargeReport, and
				//		- actionCode = send
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclaratioN
                // of Choice AuthenticatedChargeReport with actionCode = send
                // TODO define TD_AUTHENTICATED_CHARGE_REPORT in module TesterData

				var TollDeclarationADU v_aduTollDeclarationAuthenticatedChargeReport := {
					tollDeclarationId := {TD_IDENTIFIER, 1}, 
					gnssTollDeclaration := {
						authenticatedChargeReport := TD_AUTHENTICATED_CHARGE_REPORT
					},
				actionCode:= ActionCode_send_
				};
				
				v_apduForSending := m_apduNoAuthInitTester({v_aduTollDeclarationAuthenticatedChargeReport});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with apduAckCode = apduNotOK (3)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams := {{0, ApduReasonCode_apduNotOK_}};

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                								
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_05

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_06: Verify that the TC correctly responds to an APDU containing
                *			a number of chargeReports which exceeds GNSS.TOLLDECLARATION.PARAM2_MAX
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
								
                // Step 1:
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- more than GNSS.TOLLDECLARATION.PARAM2_MAX chargeReports containing valid and IUT declared values;
				//		- actionCode = send

				// Prepare and send an Initiating_Apdu with PARAM2_MAX + 1 TollDeclarationADUs with actionCode = send

				 
				var Adus v_adusToBeSent; //List of ADUs to be sent
				// TODO: revise because of only one ADU required 
				var UsageStatement v_usageStatementToBeSent;

				for (var integer v_loop := 0; v_loop < GNSS_TOLLDECLARATIONS_PARAM2_MAX_TC; v_loop := v_loop + 1) {	
 					v_usageStatementToBeSent := {
						usageStatementId := v_loop,
						tollContext := TD_TOLL_CONTEXT,
						aggregatedSingleTariffClassSession := TD_SINGLE_TARIFF_CLASS_SESSION,
						listOfChargeObjects := TD_LIST_OF_CHARGE_OBJECTS,
						listOfRawUsageData := TD_LIST_OF_RAW_USAGE_DATA,
						additionalUsageInformation := omit
					};
 					v_adusToBeSent[v_loop] := m_aduTollDeclarationToSendOneObe( 
							{TD_IDENTIFIER, v_loop}, // TODO: is the assumption correct that one TD contains one ChargeReport?
							v_usageStatementToBeSent,
							v_loop,
							ActionCode_send_);
				};		
 					
				v_apduForSending := m_apduNoAuthInitTester(v_adusToBeSent);
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
                
                // Step 2:
                // Wait for NAck_Apdu with (with issues= NULL)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
                
                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams := {{0, ApduReasonCode_apduNotOK_}};

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                								
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_06

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_07() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_07: Verify that the TC correctly responds to an APDU containing
                *			a TollDeclarationADU in which the actionCode is not present
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- with valid and IUT declared values, and
                //		- actionCode = NULL
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclaration
                // with actionCode = NULL

				template (value) TollDeclarationADU m_aduTollDeclarationToSendOneObeOtherActionCodes
					modifies m_aduTollDeclarationToSendOneObe:={actionCode := ?}; // to allow any value for actionCode

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObeOtherActionCodes(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						null)
					});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams_2 := {{1, AduReasonCode_semanticError_}};

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_07
	                		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_08() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_08: Verify that the TC correctly responds to an APDU containing
                *			a TollDeclarationADU in which the actionCode is neither send, revoke nor adjust
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- with valid and IUT declared values, and
                //		- actionCode /= {send, revoke, adjust}
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclaration
                // with actionCode = 4

				template (value) TollDeclarationADU m_aduTollDeclarationToSendOneObeOtherActionCodes
					modifies m_aduTollDeclarationToSendOneObe:={actionCode := ?}; // to allow any value for actionCode

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObeOtherActionCodes(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_resend_) // other actionCode = 4
					});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with
                //		- ({0,actionCodeNotSupported(3010)}) OR
                //		- ({1,actionCodeNotSupported(3010)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_actionCodeNotSupported_}};
				var NAckParams v_nAckParams_2 := {{1, AduReasonCode_actionCodeNotSupported_}};

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_08

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_09() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_09: Verify that the TC correctly responds to an APDU containing
                *			more than one TollDeclarationADUs with actionCode send of which
                *			one or more fields in the toll declarations and/or underlying data elements are invalid
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send Initiating_Apdu containing
                //		- one TollDeclarationADU with valid and IUT declared values; and
                //		- one TollDeclarationADU with values not declared as IUT implemented
                //		- actionCode = send
                
                // Step 2:
                // Wait for Ack_Apdu with
                //		- issueADUStruct =2, and
                //		- issueCode = semanticError(3000)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdus
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_09
			
		} // End Invalid_Behaviour
		
	} // End GNSS_TOLLDECLARATION

	group GNSS_BILLINGDETAILS_TSP {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when a TSP provides a single BillingDetailsADU
                *			with no optional fields except includedDiscounts and actionCode=send
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56.6
                */
 								                 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_6_implementedIncludedDiscounts;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};
				 	
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

				// Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- includedDiscounts is present; and
				//		- actionCode=send

				// prepare this adu below
				const UsageList c_usageListSectionedRoadsWithDiscount := {}; // TODO and use template as base
				
				const BillingDetailsADU c_aduGnssBillingDetailsWithDiscounts := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM,
					TD_USERID_1,
					TD_PERIOD_1,
					{c_usageListSectionedRoadsWithDiscount},
					TD_DISCOUNT_AMOUNT,
					c_refTollDeclaration1, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);
																
				v_apduForSending := m_apduNoAuthInitTester({c_aduGnssBillingDetailsWithDiscounts});	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined				
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides
                *			a single BillingDetailsADU with no optional fields, actionCode = send
                *			and having selected forSectionedRoads
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/1
                */
 								                 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_1_implementedSectionedRoads;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send
		
				//var UsageList v_sectionsUsed;
				//template (value) UsageList m_sectionsUsed modifies mw_sectionedRoadGnssUsageList := {
				//	usageListEntry {
				//		forSectionedRoads {		
				//			howManyTimes := 1,
				//			listOfSections := {mw_section := {
				//				chargeObjectId := TD_CHARGE_OBJECT_ID,
				//				tollEventId := TD_TOLL_EVENT_ID, // mandatory in IAP
				//				tollEventTime := TD_TOLL_EVENT_TIME // mandatory in IAP
				//			}} 
				//		}
				//	},
				//	includedDiscounts := omit,
				//	externalCosts := omit
				//};

				// prepare this adu below
				const UsageList c_usageListSectionedRoads := {}; // TODO and use template as base
				
				var BillingDetailsADU v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM,
					TD_USERID_1,
					TD_PERIOD_1,
					{c_usageListSectionedRoads},
					omit, // No discount field
					c_refTollDeclaration1, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({v_aduGnssBillingDetailsSectionedRoads});	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined				
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forTravellingInArea
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_2_implementedTravellingInArea;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for TravellingInArea, and
				//		- the value of entranceChargeObjectName in forCordonCrossing being a correct UTF8String, and
				//		- actionCode=send

				// prepare this adu below
				const UsageList c_usageListTravellingInArea := {}; // TODO and use template as base
				
				const BillingDetailsADU c_aduGnssBillingDetailsTravellingInArea := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM,
					TD_USERID_1,
					TD_PERIOD_1,
					{c_usageListTravellingInArea},
					omit, // no toll discount
					c_refTollDeclaration1, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({c_aduGnssBillingDetailsTravellingInArea});	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined				
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forStayingInArea
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/3
                */
 								
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_3_implementedStayingInArea;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack

				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for StayingInArea, and
				//		- actionCode=send

				// prepare this adu below
				const UsageList c_usageListStayingInArea := {}; // TODO and use template as base
				
				const BillingDetailsADU c_aduGnssBillingDetailsStayingInArea := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM,
					TD_USERID_1,
					TD_PERIOD_1,
					{c_usageListStayingInArea},
					omit, // no toll discount
					c_refTollDeclaration1, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({c_aduGnssBillingDetailsStayingInArea});	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined								
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forCordonCrossings
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/4
                */
                  
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_4_implementedCordonCrossing;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack

				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for CordonCrossing, and
				//		- actionCode=send

				// prepare this adu below
				const UsageList c_usageListCordonCrossing := {}; // TODO and use template as base
				
				const BillingDetailsADU c_aduGnssBillingDetailsCordonCrossing := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM,
					TD_USERID_1,
					TD_PERIOD_1,
					{c_usageListCordonCrossing},
					omit, // no toll discount
					c_refTollDeclaration1, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({c_aduGnssBillingDetailsCordonCrossing});	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined								
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06: Verify that the TC correctly performs
                *			a GNSS_BILLINGDETAILS_TSP transaction when the TSP provides multiple BillingDetailsADUs
                *			with no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_4_implementedCordonCrossing;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with GNSS.BILLINGDETAILS.TSP.PARAM1_MAX tollDeclaration adus
				// receive positive Ack

				// create APDU with GNSS.BILLINGDETAILS.TSP.PARAM1_MAX toll declaration adus				   
				 
				var Adus v_adusToBeSent; //List of ADUs to be sent 
				var UsageStatement v_usageStatementToBeSent;
				var ListOfTollDeclarationIds v_listOfTollDeclarationIds;				

				for (var integer v_loop := 0; v_loop < GNSS_BILLINGDETAILS_TSP_PARAM1_MAX_TC; v_loop := v_loop + 1) {	
 					v_usageStatementToBeSent := {
						usageStatementId := v_loop,
						tollContext := TD_TOLL_CONTEXT,
						aggregatedSingleTariffClassSession := TD_SINGLE_TARIFF_CLASS_SESSION,
						listOfChargeObjects:=TD_LIST_OF_CHARGE_OBJECTS,
						listOfRawUsageData := TD_LIST_OF_RAW_USAGE_DATA,
						additionalUsageInformation := omit
					};
 					v_listOfTollDeclarationIds[v_loop] := {TD_IDENTIFIER, v_loop}; 
 					v_adusToBeSent[v_loop] := m_aduTollDeclarationToSendOneObe(
							v_listOfTollDeclarationIds[v_loop],
							v_usageStatementToBeSent,
							v_loop,
							ActionCode_send_);
				}					   

				v_apduForSending := m_apduNoAuthInitTester(v_adusToBeSent);	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a GNSS.BILLINGDETAILS.TSP.PARAM1_MAX valid BillingDetailsADUs with
                //		- actionCode = send and no optional fields
 
 				// prepare this adu below
				const UsageList c_usageListSectionedRoads := {}; // TODO and use template as base

				 
				var RoBillingDetailsId v_listOfBillingDetailsIds;
				
				for (var integer v_loop:= 0; v_loop < GNSS_BILLINGDETAILS_TSP_PARAM1_MAX_TC; v_loop := v_loop + 1) {	
				v_adusToBeSent[v_loop] := m_aduGnssBillingDetails (
					v_listOfBillingDetailsIds[v_loop],
					TD_USERID_1,
					TD_PERIOD_1,
					{c_usageListSectionedRoads},
					omit, // no toll discount
					v_listOfTollDeclarationIds[v_loop], // same array of toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);
				}
				v_apduForSending := m_apduNoAuthInitTester(v_adusToBeSent);	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined								
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP sends a single BillingDetailsADU
                *			with actionCode = adjust and no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */

				// Initialitastion 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_1_implementedSectionedRoads;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send invalid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send
				//		- Toll Declaration reference which does not correspond to the last Toll Declaration

				// prepare this adu below
				const UsageList c_usageListSectionedRoads := {}; // TODO and use template as base
				
				var BillingDetailsADU v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM,
					TD_USERID_2, // user ID does not match the user Id in the corresponding toll declaratiuon
					TD_PERIOD_1,
					{c_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_1,
					c_refTollDeclaration1,
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({v_aduGnssBillingDetailsSectionedRoads});	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined				
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for negative Ack_Apdu with AduReason code
                //		- NAck_Apdu with aduReasonCode = billingDetailsUserIdRejected (704) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = billingDetailsUserIdRejected (704) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep
                // within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_billingDetailsUserIdRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {{1, AduReasonCode_billingDetailsUserIdRejected_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}										
				}	

                // Step 3:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = adjust, and
				//		- no optional fields, and
				//		- billingDetailsNum referencing the previously received BillingDetailsADU
                  
				// prepare this adu below
				
				v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM,
					TD_USERID_1, // now with correct user ID
					TD_PERIOD_1,
					{c_usageListSectionedRoads},
					omit, // no toll discount
					c_refTollDeclaration1,
					ActionCode_adjust_
					);

				v_apduForSending := m_apduNoAuthInitTester({v_aduGnssBillingDetailsSectionedRoads});	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined				
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				

                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
  				// Initialisation

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08: VVerify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP sends a single BillingDetailsADU
                *			with actionCode =revoke and no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */

				// Initialitastion 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_1_implementedSectionedRoads;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send invalid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send

				// prepare this adu below
				const UsageList c_usageListSectionedRoads := {}; // TODO and use template as base
				
				var BillingDetailsADU v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM,
					TD_USERID_1,
					TD_PERIOD_1,
					{c_usageListSectionedRoads},
					omit, // no toll discount
					c_refTollDeclaration1,
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({v_aduGnssBillingDetailsSectionedRoads});	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined				
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	

                // Step 3:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = revoke, and
				//		- no optional fields, and
				//		- billingDetailsNum referencing the previously received BillingDetailsADU
                  
				// prepare this adu below
				v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM,
					TD_USERID_1, // now with correct user ID
					TD_PERIOD_1,
					{c_usageListSectionedRoads},
					omit, // no toll discount
					c_refTollDeclaration1,
					ActionCode_revoke_
					);

				v_apduForSending := m_apduNoAuthInitTester({v_aduGnssBillingDetailsSectionedRoads});	

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined				
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				

                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
  				// Initialisation

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08
			
		} // End Valid_Behaviour

		group Invalid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01: Verify that the TC correctly responds
                *			when receiving multiple BillingDetailsADUs with no optional fields present
                *			with each BillingDetailsADU having one field with an incorrect value
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing 10 BillingDetailsADUs with
                //		- all mandatory fields, and
                //		- no optional fields,
                //		- where the following fields have an incorrect value
                //			(a) billingDetailsId.issuerId
                //			(b) tollContext
                //			(c)	userId
                //			(d) billingDetailsAmount
                //			(e) usageDetails.contextName
                //			(f) usageDetails.appliedUserClass
                //			(g) usageDetails.perDeclaredVehicleClasses
                //			(h)	usageDetails.appliedTimeClass
                //			(i) usageDetails.entranceTime
                //			(j) usageList.ListofSections.chargeObjectId
                 
                // Step 2:
                // Wait for NAck_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1
                // with issueCodes corresponding to the incorrect velues above:
                //			(a) billingDetailsIssuerIdRejected
                //			(b) billingDetailsContextIdRejected
                //			(c) billingDetailsUserIdRejected
                //			(d) billingDetailsAmountRejected
                //			(e) billingDetailsContextNameRejected
                //			(f) billingDetailsAppliedUserClassRejected
                //			(g) billingDetailsDeclaredVehicleClassRejected
                //			(h) billingDetailsAppliedTimeClassRejected
                //			(i) billingDetailsEntranceTimeRejected
                //			(j) billingDetailsIntermediateSectionRejected
                             
                // use template(s) for NAck_Apdu
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02: Verify that the TC correctly responds
                * 			when the TSP provides a single BillingDetailsADU with only mandatory fields,
                *			then issues a second BillingDetailsADU too early
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
                // Step 1:
                // Before TIMEA_MIN as passed, send valid Initiating_Apdu containing exactly one BillingDetailsADUs with
                //		- all mandatory fields, and
                //		- no optional fields,
                 
                // Step 2:
                // Wait for NAck_requestSentTooOften(10) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck_requestSentTooOften(10)
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03: Verify that the TC correctly responds
                *			when the TSP sends too many BillingDetailsADUs
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing
                // (GNSS.BILLINGDETAILS.TSP. PARAM1_MAX +1) BillingDetailsADUs, with no optional fields
                 
                // Step 2:
                // Wait for NAck containing issueCode = semanticError(3000) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04: Verify that the TC correctly reponds
                *			when the TSP adjusts billing details that do not exist at IUT side
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing containing exactly one a BillingDetailsADU with
                //		- all mandatory fields, and
                //		- actionCode = adjust, and
                //		- no optional fields, and
                //		- billingDetailsNum referencing a billing details that do not exist at the IUT side
                 
                // Step 2:
                // Wait for NAck containing issueCode = semanticError(3000) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05: Verify that the TC correctly reponds
                *			when the TSP tries to revoke billing details that do not exist at TC side
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing containing exactly one a BillingDetailsADU with
                //		- all mandatory fields, and
                //		- actionCode = revoke, and
                //		- no optional fields, and
                //		- billingDetailsNum referencing a billing details that do not exist at the IUT side
                 
                // Step 2:
                // Wait for NAck containing issueCode = semanticError(3000) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05

		} // End Invalid_Behaviour
		
	} // End GNSS_BILLINGDETAILS_TSP

	group GNSS_BILLINGDETAILS_TC {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_01: Verify that the TC correctly performs a GNSS.BILLINGDETAILS.TC transaction
                *			with BillingDetailsADUs containing all permutations of present and
                *			not present optional fields that vary in the IUT implementation, all with actionCode=send
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_2_implementedGNSSBILLINGDETAILSTC;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed

				// Step 1:
				// Perform a full GNSS.TOLLDECLARATION transaction with five(5) tollDeclarations
				// receive positive Ack
				// wait respective time constraints until next transaction 	
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						TD_USAGE_STATEMENT_VALID_2,
						2,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3},
						TD_USAGE_STATEMENT_VALID_3,
						3,
						ActionCode_send_),							
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4},
						TD_USAGE_STATEMENT_VALID_4,
						4,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5},
						TD_USAGE_STATEMENT_VALID_5,
						5,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	
								
                // Step 2:
                // Trigger IUT with GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND to send BillingDetailsADUs containing
                //		- all valid permutations of present and not present optional fields and choices that are used in the IUT implementation
                //		- and correspond to the toll declarations sent by the Tester

				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);
				
				// PT140 TDO: the assumption is that the five Toll Declarations (sse above)
				// are used to create in one BillingDetailsAdu.

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduGnssBillingDetails:= {
				  		refTollDeclaration := {
				  			{TD_IDENTIFIER, 1},
				  			{TD_IDENTIFIER, 2},
				  			{TD_IDENTIFIER, 3},
				  			{TD_IDENTIFIER, 4},
				  			{TD_IDENTIFIER, 5}
				  		},
				  		actionCode := ActionCode_send_
				  	}}}) 
           		};                 
				
                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					              		
						// Step 3: Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_02: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TC transaction when it sends a single BillingDetailsADU
                *			with actionCode = adjust and no optional fields
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_2_implementedGNSSBILLINGDETAILSTC;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed

				// Step 1:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				// wait respective time constraints until next transaction 	
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 2: Tigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_SEND to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send
                
                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduGnssBillingDetails:= {
				  		refTollDeclaration := {{TD_IDENTIFIER, 1}},
				  		actionCode := ActionCode_send_
				  	}}}) 
           		};                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no time check
						f_logApduReceivedAndTStep();					              		
					}
				}

				// capture the billingDetailsId for validation in step 3
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs.billingDetailsId;

				// Step 3: Send NAck (except of issueCode "acceptedWithWarning") within time constraints
				f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
				f_sendAndLogApdu(m_apduNAckIndividualIssuesTester(v_apduReceived, {1, AduReasonCode_semanticError_}));

                // Step 4: Tigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_ADJUST to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = adjust the same BillingDetailsId from Step 2

                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_ADJUST);

                // Wait for IUT to send adjusted BillingDetailsADU
                // with actionCode = adjust
                // with same billingDetailsId as already received billingDetailsId
				v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduGnssBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_adjust_
				  	}
				  }}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);					              		
						// Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_03: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TC transaction when it sends a single BillingDetailsADU
                *			with actionCode = revoke and no optional fields
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_2_implementedGNSSBILLINGDETAILSTC;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed

				// Step 1:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				// wait respective time constraints until next transaction 	
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 2: Tigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_SEND to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send
                
                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduGnssBillingDetails:= {
				  		refTollDeclaration := {{TD_IDENTIFIER, 1}},
				  		actionCode := ActionCode_send_
				  	}}}) 
           		};                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no time check
						f_logApduReceivedAndTStep();					              		
					}
				}

				// capture the billingDetailsId for validation in step 3
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs.billingDetailsId;

				// Step 3: Send Ack within time constraints
				f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
				f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));

                // Step 4: Tigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_REVKE to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = revoke the same BillingDetailsId from Step 2

                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_ADJUST);

                // Wait for IUT to revke BillingDetailsADU
                // with actionCode = revoke
                // with same billingDetailsId as already received billingDetailsId
				v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduGnssBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_revoke_
				  	}
				  }}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no time check
						f_logApduReceivedAndTStep();					              		
						// Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_03			
		} // End Valid_Behaviour

		group Invalid_Bahaviour {

               /**
                 * @remark  No TPs have been defined
                 */			
			
		} // End group Invalid_Behaviour		
		
	} // End group GNSS_BILLINGDETAILS_TC
	
	group GNSS_PAYMENTANNOUNCEMENT {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01: Verify that the TC correctly performs
                *			a GNSS.PAYMENTANNOUNCEMENT transaction
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with five(5) tollDeclarations
				
				// Prepare APDU with five(5) TollDeclaration ADUs 
				
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_1, // usageStatement
						1, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_2, // usageStatement
						2, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_3, // usageStatement
						3, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_4, // usageStatement
						4, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_5, // usageStatement
						5, // chargeReportCounter
						ActionCode_send_ // actionCode
					)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

				// Step 3:
                // Send valid Initiating_Apdu containing five(5) BillingDetailsADU, with
				//		- the values corresponding the previous TollDeclarationADUs; and
				//		- actionCode=send

				var UsageList v_sectionsUsed;
				v_sectionsUsed := {
					usageListEntry := {
						forSectionedRoads := {		
							howManyTimes := 1,
							listOfSections := {
								chargeObjectId := TD_CHARGE_OBJECT_ID,
								tollEventId := TD_TOLL_EVENT_ID, // mandatory in IAP
								tollEventTime := TD_TOLL_EVENT_TIME // mandatory in IAP
							},
							invoiceAggregationNumber := omit,
							fee := omit,
							feeQualifier := omit
						}
					},
					includedDiscounts := omit,
					associatedEventData := omit,
					externalCosts := omit
				};				

				v_apduForSending := m_apduNoAuthInitTester({
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 1},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_1,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 1},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 2},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_2,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 2},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 3},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_3,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 3},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 4},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_4,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 4},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 5},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_5,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 5},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	}				  	
				});	
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_BILLINGDETAILS_TSP_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	

				// Step 5:
                // Send valid Initiating_Apdu containing three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous five(5) BillingDetailsADUs; and
				//		- actionCode=send

				v_apduForSending := m_apduNoAuthInitTester ({
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_1,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 1}},
							amount := TD_BILLINGDETAILS_AMOUNT_1,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_2,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 3, // this ADU contains reference to three BillingDeatails
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 2},{TD_IDENTIFIER, 3},{TD_IDENTIFIER, 4}},
							amount := TD_BILLINGDETAILS_AMOUNT_2,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_3,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1, // this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 5}},
							amount := TD_BILLINGDETAILS_AMOUNT_3,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					}					
				});
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for Default_Ack_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01


			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_02: Verify that the TC correctly performs
                *			a GNSS.PAYMENTANNOUNCEMENT transaction with actionCode=adjust
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with five(5) tollDeclarations
				
				// Prepare APDU with five(5) TollDeclaration ADUs 
				
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_1, // usageStatement
						1, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_2, // usageStatement
						2, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_3, // usageStatement
						3, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_4, // usageStatement
						4, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_5, // usageStatement
						5, // chargeReportCounter
						ActionCode_send_ // actionCode
					)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

				// Step 3:
                // Send valid Initiating_Apdu containing five(5) BillingDetailsADU, with
				//		- the values corresponding the previous TollDeclarationADUs; and
				//		- actionCode=send
//TODO Jan replace the mw_aduGnssBillingDetails below with the following template:
//m_aduGnssBillingDetails(
//					in integer p_billingDetailsNum,
//					in UserId p_userId,
//					in Period p_period,
//					in RoUsageList p_roUsageList,
//					in ExtendedPaymentAmount p_billingDetailsAmount,
//					in RoTollDeclarationId p_refTollDeclaration,
//					in ActionCode p_actionCode
//				)
//Please note that the parameter p_roUsageList should be filled with {m_sectionsUsed}

				v_apduForSending := m_apduNoAuthInitTester({
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 1},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_1,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {m_sectionsUsed} //NB this template also uses some discounts, this is not necessary for the testcase, but allowed
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 1},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 2},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_2,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							//TODO Jan the v_sectionsUsed produces an error (not delcared), should it be m_sectionsUsed?
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 2},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 3},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_3,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							//TODO Jan the v_sectionsUsed produces an error (not delcared), should it be m_sectionsUsed?
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 3},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 4},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_4,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 4},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 5},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_5,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 5},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	}				  	
				});	
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_BILLINGDETAILS_TSP_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	

				// Step 5:
                // Send valid Initiating_Apdu containing three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous five(5) BillingDetailsADUs; and
				//		- actionCode=send
				// 		- which shall be negatively acknowledge by the IuT
				//		This is achieved by referencing to billingDetailsIDs not reported to the IuT  

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 21}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 22},{TD_IDENTIFIER, 23},{TD_IDENTIFIER, 24}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_3,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						{{TD_IDENTIFIER, 25}},
						ActionCode_send_
					)
				});
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for Negative_Ack_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {
						{1, AduReasonCode_semanticError_},
						{2, AduReasonCode_semanticError_},
						{3, AduReasonCode_semanticError_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
				}

				// Step 7:
                // Adjust the previously send three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous three(3) PaymentAnnoucments; and
				//		- actionCode=adjust

				v_apduForSending := m_apduNoAuthInitTester({
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 1}},
						ActionCode_adjust_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 2},{TD_IDENTIFIER, 3},{TD_IDENTIFIER, 4}},
						ActionCode_adjust_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_3,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						{{TD_IDENTIFIER, 5}},
						ActionCode_adjust_
					)
				});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 8: Wait for Default_Ack_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_02


			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_03: Verify that the TC correctly performs
                *			a GNSS.PAYMENTANNOUNCEMENT transaction with actionCode=revoke
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with five(5) tollDeclarations
				
				// Prepare APDU with five(5) TollDeclaration ADUs 
				
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_1, // usageStatement
						1, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_2, // usageStatement
						2, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_3, // usageStatement
						3, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_4, // usageStatement
						4, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5}, //tollDeclarationId
						TD_USAGE_STATEMENT_VALID_5, // usageStatement
						5, // chargeReportCounter
						ActionCode_send_ // actionCode
					)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

				// Step 3:
                // Send valid Initiating_Apdu containing five(5) BillingDetailsADU, with
				//		- the values corresponding the previous TollDeclarationADUs; and
				//		- actionCode=send

				var UsageList v_sectionsUsed;
				v_sectionsUsed := {
					usageListEntry := {
						forSectionedRoads := {		
							howManyTimes := 1,
							listOfSections := {
								chargeObjectId := TD_CHARGE_OBJECT_ID,
								tollEventId := TD_TOLL_EVENT_ID, // mandatory in IAP
								tollEventTime := TD_TOLL_EVENT_TIME // mandatory in IAP
							},
							invoiceAggregationNumber := omit,
							fee := omit,
							feeQualifier := omit
						}
					},
					includedDiscounts := omit,
					associatedEventData := omit,
					externalCosts := omit
				};				

				v_apduForSending := m_apduNoAuthInitTester({
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 1},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_1,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 1},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 2},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_2,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 2},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 3},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_3,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 3},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 4},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_4,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 4},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	},
				  	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
				  		billingDetailsId := {TD_IDENTIFIER, 5},
				  		tollContext := TOLL_CONTEXT_ID_IUT,
				  		userId := TD_USERID_5,
				  		period := TD_PERIOD_1,
				  		usageDetails := {
							contextName := TOLL_CONTEXT_NAME_IUT,
      						appliedUserClass := TD_USER_CLASS,
      						perDeclaredVehicleClass := {{
        						declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
        						perUsedTimeClasses := {{
          							appliedTimeClass := TD_APPLIED_TIME_CLASS,
          							costCenter := TD_COST_CENTER,
          							usageList := {v_sectionsUsed} 
          						}}
 				  			}}
 				  		},
 				  		refTollDeclaration := {TD_IDENTIFIER, 5},
    					actionCode := ActionCode_send_,
    					paymentReference := omit 				  		
				  	}				  	
				});	
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_BILLINGDETAILS_TSP_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	

				// Step 5:
                // Send valid Initiating_Apdu containing three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous five(5) BillingDetailsADUs; and
				//		- actionCode=send

				v_apduForSending := m_apduNoAuthInitTester ({
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_1,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 1}},
							amount := TD_BILLINGDETAILS_AMOUNT_1,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_2,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 3, // this ADU contains reference to three BillingDeatails
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 2},{TD_IDENTIFIER, 3},{TD_IDENTIFIER, 4}},
							amount := TD_BILLINGDETAILS_AMOUNT_2,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_3,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1, // this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 5}},
							amount := TD_BILLINGDETAILS_AMOUNT_3,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					}					
				});
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for DefaultAck_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
				}

				// Step 7:
                // Revoke the previously send three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous three(3) PaymentAnnoucments; and
				//		- actionCode=revoke

				v_apduForSending := m_apduNoAuthInitTester ({
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_1, // same Id as in the previous transaction
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 1}}, // correct BillingDetailsId
							amount := TD_BILLINGDETAILS_AMOUNT_1,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_revoke_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_2, // this ADU contains reference to one BillingDeatail
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 3, // this ADU contains reference to three BillingDeatails
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 2},{TD_IDENTIFIER, 3},{TD_IDENTIFIER, 4}}, // correct BillingDetailsIds
							amount := TD_BILLINGDETAILS_AMOUNT_2,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_revoke_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_3, // this ADU contains reference to one BillingDeatail
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1, // this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 5}}, // correct BillingDetailsId
							amount := TD_BILLINGDETAILS_AMOUNT_3,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_revoke_
					}					
				});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 8: Wait for Default_Ack_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_03
			
		} // End Valid_Behaviour
		
		group Invalid_Behaviour {
		
		// Function defionition used in many GNSS_PAYMENTANNOUNCEMENT below
			
			function f_sendTwoTollDeclarationAdusAndTwoBillingDetailsAdus() runs on MainTestComponent {

                // Step 1:
                // Perform a full GNSS.TOLLDECLARATION transaction with two(2) tollDeclarations
                    
                // Prepare APDU with two(2) TollDeclaration ADUs 
                    
                v_apduForSending := m_apduNoAuthInitTester({
                    m_aduTollDeclarationToSendOneObe(
                        {TD_IDENTIFIER, 1}, //tollDeclarationId
                        TD_USAGE_STATEMENT_VALID_1, // usageStatement
                        1, // chargeReportCounter
                        ActionCode_send_ // actionCode
                    ),
                    m_aduTollDeclarationToSendOneObe(
                        {TD_IDENTIFIER, 2}, //tollDeclarationId
                        TD_USAGE_STATEMENT_VALID_2, // usageStatement
                        2, // chargeReportCounter
                        ActionCode_send_ // actionCode
                    )
                });
                                                                                                                                                                            
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
    
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
                    }
                }	
    
                // Step 3:
                // Send valid Initiating_Apdu containing two(2) BillingDetailsADU, with
                //		- the values corresponding the previous TollDeclarationADUs; and
                //		- actionCode=send
    
                // Prepare UsageList
				var UsageList v_sectionsUsed;
				v_sectionsUsed := {
					usageListEntry := {
						forSectionedRoads := {		
							howManyTimes := 1,
							listOfSections := {
								chargeObjectId := TD_CHARGE_OBJECT_ID,
								tollEventId := TD_TOLL_EVENT_ID, // mandatory in IAP
								tollEventTime := TD_TOLL_EVENT_TIME // mandatory in IAP
							},
							invoiceAggregationNumber := omit,
							fee := omit,
							feeQualifier := omit
						}
					},
					includedDiscounts := omit,
					associatedEventData := omit,
					externalCosts := omit
				};				
    
                v_apduForSending := m_apduNoAuthInitTester({
                    mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
                        billingDetailsId := {TD_IDENTIFIER, 1},
                        tollContext := TOLL_CONTEXT_ID_IUT,
                        userId := TD_USERID_1,
                        period := TD_PERIOD_1,
                        usageDetails := {
                            contextName := TOLL_CONTEXT_NAME_IUT,
                            appliedUserClass := TD_USER_CLASS,
                            perDeclaredVehicleClass := {{
                                declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
                                perUsedTimeClasses := {{
                                    appliedTimeClass := TD_APPLIED_TIME_CLASS,
                                    costCenter := TD_COST_CENTER,
                                    usageList := {v_sectionsUsed} 
                                }}
                            }}
                        },
                        refTollDeclaration := {TD_IDENTIFIER, 1},
                        actionCode := ActionCode_send_,
                        paymentReference := omit 				  		
                    },
                    mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
                        billingDetailsId := {TD_IDENTIFIER, 2},
                        tollContext := TOLL_CONTEXT_ID_IUT,
                        userId := TD_USERID_2,
                        period := TD_PERIOD_1,
                        usageDetails := {
                            contextName := TOLL_CONTEXT_NAME_IUT,
                            appliedUserClass := TD_USER_CLASS,
                            perDeclaredVehicleClass := {{
                                declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
                                perUsedTimeClasses := {{
                                    appliedTimeClass := TD_APPLIED_TIME_CLASS,
                                    costCenter := TD_COST_CENTER,
                                    usageList := {v_sectionsUsed} 
                                }}
                            }}
                        },
                        refTollDeclaration := {TD_IDENTIFIER, 2},
                        actionCode := ActionCode_send_,
                        paymentReference := omit 				  		
                    }
                });	
                    
                // respect time restriction TIMEB_MAX set by the IuT
                f_wait(GNSS_BILLINGDETAILS_TSP_TIMEB_MAX_TC/2);
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
                    
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
                    }
                }	
            } // end function definition
			 
			function f_sendTwoPaymentAnnouncementAdus () {
			
				// Step 1:
                // Send valid Initiating_Apdu containing two(2) PaymentAnnouncementADUs, with
				//		- the values referencing the previous two(2) BillingDetailsADUs; and
				//		- actionCode=send

				v_apduForSending := m_apduNoAuthInitTester ({
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_1,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 1}},
							amount := TD_BILLINGDETAILS_AMOUNT_1,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_2,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1, // this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 2}},
							amount := TD_BILLINGDETAILS_AMOUNT_2,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					}					
				});
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
				}	
			} // end function definition		 
		
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU with an incorrect actionCode
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Perform one GNSS_TOLLDECLARATION transaction with two TollDeclaration ADUs with positive Ack
				// and perform one GNSS_BILLINGDETAILS transaction with two BillingDetails ADUs
				// and actionCode = send and with positive Ack	
				f_sendTwoTollDeclarationAdusAndTwoBillingDetailsAdus ();
				
				// Perform one PaymentAnnouncement transaction with two PaymentAnnouncemnet ADUs
				// with actionCode = send and with positive Ack
				f_sendTwoPaymentAnnouncementAdus();
				
                // Step 5:
                // Send Initiating_Apdu containing 
				//		- exactly one PaymentAnnouncementADU with actionCode=credit, and
				//		- exactly one PaymentAnnouncementADU with actionCode=resend
				//		- both referencing to paymentAnnouncementIds previousely sent
 
				v_apduForSending := m_apduNoAuthInitTester ({
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_1,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 1}},
							amount := TD_BILLINGDETAILS_AMOUNT_1,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_credit_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_2,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1, // this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 2}},
							amount := TD_BILLINGDETAILS_AMOUNT_2,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_resend_
					}					
				});
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduRespondedTo, AduReasonCode_actionCodeNotSupported_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduRespondedTo, {
						{1, AduReasonCode_actionCodeNotSupported_},
						{2, AduReasonCode_actionCodeNotSupported_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU with incorrect paymentAnnouncementID 
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Perform one GNSS_TOLLDECLARATION transaction with two TollDeclaration ADUs with positive Ack
				// and perform one GNSS_BILLINGDETAILS transaction with two BillingDetails ADUs
				// and actionCode = send and with positive Ack	
				f_sendTwoTollDeclarationAdusAndTwoBillingDetailsAdus ();
				
				// Perform one PaymentAnnouncement transaction with two PaymentAnnouncemnet ADUs
				// with actionCode = send and with positive Ack
				f_sendTwoPaymentAnnouncementAdus();
				
                // Step 5:
                // Send Initiating_Apdu containing 
				// 		- exactly one PaymentAnnouncementADU with actionCode=send containing
				//			paymentAnnouncementId = value that has previously been used, and
				//		- exactly one PaymentAnnouncementADU with actionCode=revoke containing
				//			paymentAnnouncementId = value that has not previously been used
 
				v_apduForSending := m_apduNoAuthInitTester ({
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_1,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 1}},
							amount := TD_BILLINGDETAILS_AMOUNT_1,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_21,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1, // this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 2}},
							amount := TD_BILLINGDETAILS_AMOUNT_2,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_revoke_
					}					
				});
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) for the entire APDU
                // or invalidADU (0) for ADU#2 only,
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduRespondedTo, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduRespondedTo, {{2, AduReasonCode_invalidADU_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02


			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03: Verify that the TC correctly responds
                *			to PaymentAnnouncementADUs where details from referenceDetailsList are not present
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Perform one GNSS_TOLLDECLARATION transaction with two TollDeclaration ADUs with positive Ack
				// and perform one GNSS_BILLINGDETAILS transaction with two BillingDetails ADUs
				// and actionCode = send and with positive Ack	
				f_sendTwoTollDeclarationAdusAndTwoBillingDetailsAdus ();
				
				// Perform one PaymentAnnouncement transaction with two PaymentAnnouncemnet ADUs
				// with actionCode = send and with positive Ack
				f_sendTwoPaymentAnnouncementAdus();
				
                // Step 5:
                // Send Initiating_Apdu containing
                //		- exactly one valid PaymentAnnouncementADU, and
                //		- exactly one PaymentAnnouncementADU with actionCode=send containing
				//			- referenceDetailsList of the choice billingDetailsList containing
				//				- exactly one BillingDetailsId that does not make reference
				//					to the BillingDetailsADU of the previously performed BILLINGDETAILS transaction
 
				v_apduForSending := m_apduNoAuthInitTester ({
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_1,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 1}},
							amount := TD_BILLINGDETAILS_AMOUNT_1,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_2,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1, // this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 31}},
							amount := TD_BILLINGDETAILS_AMOUNT_2,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					}					
				});
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) for ADU#2,
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduRespondedTo, {{2, AduReasonCode_invalidADU_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03
								

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU where the length of the referenceDetailsList is too long
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Step 1:
				// Perform one GNSS_TOLLDECLARATION transaction
				// with 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX TollDeclaration ADUs with positive Ack

                // Prepare APDU with 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX TollDeclaration ADUs                
                 
                
                for (var integer v_i := 1; v_i == 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX; v_i := v_i + 1) {
                	v_apduForSending := m_apduNoAuthInitTester({
                    	m_aduTollDeclarationToSendOneObe(
                        	{TD_IDENTIFIER, v_i}, //tollDeclarationId
                        	TD_USAGE_STATEMENT_VALID_1, // usageStatement (always the same)
                        	v_i, // chargeReportCounter
                        	ActionCode_send_ // actionCode
						)
                	});
                }
                                                                                                                                                                            
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
    
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
                    }
                }	
    
                // Step 3:
                // Send valid Initiating_Apdu containing 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX BillingDetailsADU, with
                //		- the values corresponding the previous TollDeclarationADUs; and
                //		- actionCode=send
    

				// Prepare UsageList
				var UsageList v_sectionsUsed;
				v_sectionsUsed := {
					usageListEntry := {
						forSectionedRoads := {		
							howManyTimes := 1,
							listOfSections := {
								chargeObjectId := TD_CHARGE_OBJECT_ID,
								tollEventId := TD_TOLL_EVENT_ID, // mandatory in IAP
								tollEventTime := TD_TOLL_EVENT_TIME // mandatory in IAP
							},
							invoiceAggregationNumber := omit,
							fee := omit,
							feeQualifier := omit
						}
					},
					includedDiscounts := omit,
					associatedEventData := omit,
					externalCosts := omit
				};				
    
               	// Prepare APDU with 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX BillingDetails ADUs              	

                  
               	
               	for (var integer v_i := 1; v_i == 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX; v_i := v_i + 1) {
                	v_apduForSending := m_apduNoAuthInitTester({
                    	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
                        	billingDetailsId := {TD_IDENTIFIER, v_i},
                        	tollContext := TOLL_CONTEXT_ID_IUT,
                        	userId := TD_USERID_1,
                        	period := TD_PERIOD_1,
                        	usageDetails := {
                            	contextName := TOLL_CONTEXT_NAME_IUT,
                            	appliedUserClass := TD_USER_CLASS,
                            	perDeclaredVehicleClass := {{
                                	declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
                                	perUsedTimeClasses := {{
                                    	appliedTimeClass := TD_APPLIED_TIME_CLASS,
                                    	costCenter := TD_COST_CENTER,
                                    	usageList := {v_sectionsUsed} 
                                	}}
                            	}}
                        	},
                        	refTollDeclaration := {TD_IDENTIFIER, v_i},
                        	actionCode := ActionCode_send_,
                        	paymentReference := omit 				  		
                    	}
                	});
                }		
                    
                // respect time restriction TIMEB_MAX set by the IuT
                f_wait(GNSS_BILLINGDETAILS_TSP_TIMEB_MAX_TC/2);
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
                    
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
                    }
                }	
								
                // Step 5:
                // Send Initiating_Apdu containing
                //		- one valid PaymentAnnouncementADU with a reference to exactly one(1) BillingDetailsId, and
                //		- one PaymentAnnouncementADU with actionCode=send containing
                //			- referenceDetailsList of the choice billingDetailsList containing
                //				- exactly (1+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX) BillingDetailsId that makes reference to
                //					the BillingDetailsADUs of the previously performed BILLINGDETAILS transaction                  
 
				// Prepare ReferenceDetailsList with total of 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX references
				// for both ADUs
               	var ReferenceDetailsList v_referenceDetailsList;
  
               	for (var integer v_i := 1; v_i == 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX; v_i := v_i + 1) {
               		v_referenceDetailsList[v_i] := {
						billingDetailsList := {{TD_IDENTIFIER, v_i}},
						amount := TD_BILLINGDETAILS_AMOUNT_1, // PT140 TODO we may want to randomize this
						paymentMeansType := omit,
						valueDate := omit,
						interestAmount := omit
					};
				}
               		              	             					  
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 1}},
						ActionCode_adjust_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 2},{TD_IDENTIFIER, 3},{TD_IDENTIFIER, 4}},
						ActionCode_adjust_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_3,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						{{TD_IDENTIFIER, 5}},
						ActionCode_adjust_
					)
				});

				//TODO Jan replace with m_aduPaymentAnnouncement and all other cases of PaymentAnnocement
				v_apduForSending := m_apduNoAuthInitTester ({
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_1,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
						referenceDetailsList := v_referenceDetailsList[1], // one element only
						attachement := omit,
						actionCode := ActionCode_send_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_2,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX,
							// this ADU contains reference to 1+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX referenceDetails
						referenceDetailsList := v_referenceDetailsList[2 .. (2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX)],
						attachement := omit,
						actionCode := ActionCode_send_
					}					
				});
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) for ADU#2,
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail (in altstep)

				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduRespondedTo, {{2, AduReasonCode_invalidADU_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}                               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU where the attachement is too big
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Perform one GNSS_TOLLDECLARATION transaction with two TollDeclaration ADUs with positive Ack
				// and perform one GNSS_BILLINGDETAILS transaction with two BillingDetails ADUs
				// and actionCode = send and with positive Ack	
				f_sendTwoTollDeclarationAdusAndTwoBillingDetailsAdus ();
				
				// Perform one PaymentAnnouncement transaction with two PaymentAnnouncemnet ADUs
				// with actionCode = send and with positive Ack
				f_sendTwoPaymentAnnouncementAdus();
				
                // Step 5:
                // Send Initiating_Apdu containing
                //		- one valid PaymentAnnouncementADU, and
                //		- one PaymentAnnouncementADU with actionCode=send containing an attachment larger than (2^31)-1 kbytes
 
 				var octetstring v_attachement;//length 2^31
 				
 				for (var integer v_i; v_i == ((2147483648)/8); v_i := v_i + 1) {
 					v_attachement := v_attachement & '0123456789ABCDEF'O;
 				}

				//TODO Jan replace with m_aduPaymentAnnouncement
				v_apduForSending := m_apduNoAuthInitTester ({
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_1,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 1}},
							amount := TD_BILLINGDETAILS_AMOUNT_1,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := omit,
						actionCode := ActionCode_send_
					},
					mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
						paymentAnnouncemmentID := TD_PAYMENTANNOUNCEMENT_ID_2,
						dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
						totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						paymentStatus := PaymentStatus_paid_,
						numberOfItems := 1, // this ADU contains reference to one BillingDeatail
						referenceDetailsList := {{
							billingDetailsList := {{TD_IDENTIFIER, 2}},
							amount := TD_BILLINGDETAILS_AMOUNT_2,
							paymentMeansType := omit,
							valueDate := omit,
							interestAmount := omit
							}},
						attachement := v_attachement,
						actionCode := ActionCode_send_
					}					
				});
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) for ADU#2,
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduRespondedTo, {{2, AduReasonCode_invalidADU_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05

								
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06: Verify that the TC correctly responds to
                *			an APDU containing too many PaymentAnnouncementADUs
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Step 1:
				// Perform one GNSS_TOLLDECLARATION transaction
				// with 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX TollDeclaration ADUs with positive Ack

                // Prepare APDU with 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX TollDeclaration ADUs                
                 
                
                for (var integer v_i := 1; v_i == 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX; v_i := v_i + 1) {
                	v_apduForSending := m_apduNoAuthInitTester({
                    	m_aduTollDeclarationToSendOneObe(
                        	{TD_IDENTIFIER, v_i}, //tollDeclarationId
                        	TD_USAGE_STATEMENT_VALID_1, // usageStatement (always the same)
                        	v_i, // chargeReportCounter
                        	ActionCode_send_ // actionCode
						)
                	});
                }
                                                                                                                                                                            
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
    
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
                    }
                }	
    
                // Step 3:
                // Send valid Initiating_Apdu containing 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX BillingDetailsADU, with
                //		- the values corresponding the previous TollDeclarationADUs; and
                //		- actionCode=send
    
				// Prepare UsageList
				var UsageList v_sectionsUsed;
				v_sectionsUsed := {
					usageListEntry := {
						forSectionedRoads := {		
							howManyTimes := 1,
							listOfSections := {
								chargeObjectId := TD_CHARGE_OBJECT_ID,
								tollEventId := TD_TOLL_EVENT_ID, // mandatory in IAP
								tollEventTime := TD_TOLL_EVENT_TIME // mandatory in IAP
							},
							invoiceAggregationNumber := omit,
							fee := omit,
							feeQualifier := omit
						}
					},
					includedDiscounts := omit,
					associatedEventData := omit,
					externalCosts := omit
				};				
    
               	// Prepare APDU with 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX BillingDetails ADUs              	
                  
               	
               	for (var integer v_i := 1; v_i == 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX; v_i := v_i + 1) {
                	v_apduForSending := m_apduNoAuthInitTester({
                    	mw_aduGnssBillingDetails:= { // original template with wildcards, but now all given values below
                        	billingDetailsId := {TD_IDENTIFIER, v_i},
                        	tollContext := TOLL_CONTEXT_ID_IUT,
                        	userId := TD_USERID_1,
                        	period := TD_PERIOD_1,
                        	usageDetails := {
                            	contextName := TOLL_CONTEXT_NAME_IUT,
                            	appliedUserClass := TD_USER_CLASS,
                            	perDeclaredVehicleClass := {{
                                	declaredVehicleClass := TD_DECLARED_VEHICLE_CLASS,
                                	perUsedTimeClasses := {{
                                    	appliedTimeClass := TD_APPLIED_TIME_CLASS,
                                    	costCenter := TD_COST_CENTER,
                                    	usageList := {v_sectionsUsed} 
                                	}}
                            	}}
                        	},
                        	refTollDeclaration := {TD_IDENTIFIER, v_i},
                        	actionCode := ActionCode_send_,
                        	paymentReference := omit 				  		
                    	}
                	});
                }		
                    
                // respect time restriction TIMEB_MAX set by the IuT
                f_wait(GNSS_BILLINGDETAILS_TSP_TIMEB_MAX_TC/2);
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
                    
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
                    }
                }	
								
                // Step 5:
                // Send Initiating_Apdu containing
                //		- 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX valid PaymentAnnouncementADU
				 
               	
               	for (var integer v_i := 1; v_i == 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX; v_i := v_i + 1) {               		              	             					  
					v_apduForSending := m_apduNoAuthInitTester ({
						//TODO Jan replace with m_aduPaymentAnnouncement
						mw_aduPaymentAnnouncement := { // original template with wildcards, but now all fields filled below				  	
							paymentAnnouncemmentID := v_i,
							dueDate := TD_PAYMENTANNOUNCEMENT_DUE_DATE,
							totalamount := TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1, // PT140 TODO we may want to randomize this
							paymentStatus := PaymentStatus_paid_,
							numberOfItems := 1,	// this ADU contains reference to one BillingDeatail
							referenceDetailsList := {{
								billingDetailsList := {{TD_IDENTIFIER, v_i}}, // one billingDetail per ADU
								amount := TD_BILLINGDETAILS_AMOUNT_1, // PT140 TODO we may want to randomize this
								paymentMeansType := omit,
								valueDate := omit,
								interestAmount := omit
								}},
							attachement := omit,
							actionCode := ActionCode_send_
						}					
					});
				}
				
				// respect time restriction TIMEB_MAX set by the IuT
				f_wait(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TC/2);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with APDU ReasonCode apduNotOK(3),
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail (in altstep)
 
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduRespondedTo, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}                               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06			
		} // End group Invalid_Behaviour
		
	} // End group GNSS_PAYMENTANNOUNCEMENT	
	                		
} // End of module EfcInfoExchange_TestCasesTc

