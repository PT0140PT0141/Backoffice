 /**
 * @author  PT0140 
 * @desc    This module provides test cases for TPs specified in Annex A of CEN/TC 17154-1 (i.e. Toll Charger system is IUT)
 * @see     [17154-1:2018]: Test suite structure and test purpose
 * @see     [17154-1:2018], Clause 5.3.2 for TP namimg conventions
 * @version $id$
 */ 
 
module EfcInfoExchange_TestCasesTc {
	/**
    * @desc    [12855:2015]: 
    * @see     Annex A (normative)  data type specifications
    */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
    * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
    *          Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
    */
    import from LibEfc_Common_Parameterised_Asn1_Data all;
	import from EfcInfoExchange_ParameterisedAsn1Data all;
    import from EfcInfoExchange_Interfaces all;
	import from EfcInfoExchange_InteroperabilityStatement all;
    import from EfcInfoExchange_Functions all;	
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Ics all;
    import from EfcInfoExchange_Templates all;
	import from EfcInfoExchange_TesterData all;
    import from EfcInfoExchange_Profile all;
		
     /**
      * @desc	These test cases apply to Toll Charger claiming conformance to [16986:2016]
      *			and applying Test Purposes as from CEN/TS17154-1:2018 Annex A
      * @remark
      */
 
	group BASE {
		group Valid_Behaviour {

			testcase TP_TC_BASE_BV_01() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BV_01: Verify that the TC validates correct infoExchanceAuthenticators in received APDUs
	 		* and generates correct infoExchangeAuthenticators
	 		* @remark  [16986:2016], Clause 6.2.2 and Table A.1/1 and Table A.3/3 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A3_3_useAuthenticator and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 1:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list with authenticator
                v_apduForSending := m_apduAuthInitTester({exceptionListADUs:={c_exceptionListAduWhiteValid}});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduAuthRespIut(v_apduForSending, m_oneAckInAdusStruct(m_aduDefaultAck(v_apduForSending)))) -> value v_apduReceived {
						
						if (fx_checkAuthenticator(v_apduReceived)) {
							f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
							setverdict(pass);
						}
						else {
							setverdict(fail);
							f_addLogEntry("Incorrect authenticator");
						};
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BV_01
		} //end group valid_behaviour         

		group Invalid_Behaviour {

			testcase TP_TC_BASE_BI_01() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_01: Verify that the TC correctly responds to invalid aidIdentifier
	 		* in the APCI field received in an APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with invalid aidIdentifier
				template (value) ApciFields m_apciInvalidAidInitTester modifies m_apciInitTester:= {aidIdentifier:=0};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidAidInitTester, {exceptionListADUs:={c_exceptionListAduWhiteValid}});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(protocolVersionError (6))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_protocolVersionError_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_01

			testcase TP_TC_BASE_BI_02() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_02: Verify that the TC correctly responds to invalid apduOriginator
	 		* in the APCI field received in an APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with invalid apduOriginator (= not Tester Originator)
				template (value) ApciFields m_apciInvalidAidInitTester modifies m_apciInitTester:= {apduOriginator:= TD_INVALID_APDU_ORIGINATOR_TESTER};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidAidInitTester, {exceptionListADUs:={c_exceptionListAduWhiteValid}});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(originatorRejected (7))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_originatorRejected_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_02

			testcase TP_TC_BASE_BI_03() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_03: Verify that the TC correctly responds to invalid or unknown informationSenderID
	 		* in the APCI field received in an APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with invalid or unknown informationSenderID (= not Sender Id of the Tester)
				template (value) ApciFields m_apciInvalidSenderIdInitTester modifies m_apciInitTester:= {informationSenderID:= TD_INVALID_INFORMATION_SENDER_TESTER};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidSenderIdInitTester, {exceptionListADUs:={c_exceptionListAduWhiteValid}});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(originatorRejected (7))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_originatorRejected_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_03

			testcase TP_TC_BASE_BI_04() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_04: Verify that the TC correctly validates an informationRecipientID
	 		* in APCI field which does not address the IUT
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with invalid or unknown informationRecipientID (= not Id of the Iut)
				template (value) ApciFields m_apciInvalidRecipientIdInitTester
					modifies m_apciInitTester:= {informationrecipientID:= PX_INVALID_INFORMATION_RECIPIENT_ID_FOR_IUT};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidRecipientIdInitTester, {exceptionListADUs:={c_exceptionListAduWhiteValid}});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(recipientUnknown (8))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_recipientUnknown_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_04

			testcase TP_TC_BASE_BI_05() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_05: Verify that the TC correctly respond to invalid apduIdentifier in APCI field
	 		* received in an APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 0:
				// Prepare and capture the apdu to be sent in a variable to avoid apduIdentifier to be re-generated
				v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduWhiteValid}});

				// Send APDU
				f_sendAndLogApdu(v_apduForSending);              	

                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               

              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
					}
				}											
											
                // Send the same APDU again with same apduIdentifier 
				f_sendAndLogApdu(v_apduForSending);              	

                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               

                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_05

			testcase TP_TC_BASE_BI_06() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_06: Verify that the TC correctly responds to a received APDU
	 		* in which the nextAPDUId field is present in APCI field
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI with containing nextApduId field
				template (value) ApciFields m_apciInvalidWithNextApduIdInitTester := {
    				aidIdentifier := 1, // 12855 Protocol Version number 
    				apduOriginator := TD_APDU_ORIGINATOR_FOR_TESTER, 
    				informationSenderID := TD_INFORMATION_SENDER_TESTER, // Sender of this content 
    				informationrecipientID := PX_INFORMATION_SENDER_ID_FOR_IUT,  
    				apduIdentifier := float2int(rnd()) * 65535,
    				previousApduId := omit,
    				nextApduId := {TD_APDU_ORIGINATOR_FOR_TESTER, 1}, // now present in the BI
    				inResponseToApduId := omit, 
    				apduDate := fx_getUtc()
    			}
				
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidWithNextApduIdInitTester, {exceptionListADUs:={c_exceptionListAduWhiteValid}});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3))
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_06

			testcase TP_TC_BASE_BI_07() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_07: Verify that the TC correctly responds to a received APDU in which
	 		* the inResponseToApduId is present in APCI field but the received APDU is not in response to a previous APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 1:

                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidWithInResponseToApduIdInitTester, {exceptionListADUs:={c_exceptionListAduWhiteValid}});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3)) or NAck_Protocol_Apdu(sequenceError (4)) 
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
					
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_sequenceError_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_07

			testcase TP_TC_BASE_BI_08() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_08: Verify that the TC correctly responds
	 		* to an invalid inResponseToApduId in APCI field of the APDU received
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/2
	 		*/
				var ApciFields v_apciInvalidInResponseToApduIdRespTester;
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Trigger Iut to send userListRequest
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_ONEADU);

             	// Wait for RequestADU of type userListRequest 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduRequestListOfUsersOneAdu) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified
					}
				}

				// capture ApduId received
				var ApduIdentifier v_apduId := v_apduReceived.infoExchangeContent.apci.apduIdentifier;
				
				// prepare wrong APCI-fields with wrong inResponseToApduId
				v_apciInvalidInResponseToApduIdRespTester:=m_apciRespTester(v_apduReceived);
				v_apciInvalidInResponseToApduIdRespTester.inResponseToApduId.apduIdentifier:=v_apduId+1;

				// Step 2
				// Prepare ProvideUserIdListADUs depending on received request

				var Adus v_adus;
				var integer v_i, v_numberOfRequestAdus := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				for (v_i := 0; v_i < v_numberOfRequestAdus; v_i := v_i + 1) {
					v_adus.provideUserIdListADUs[v_i]:=
					m_aduProvideUserIdList(
						v_apduReceived.infoExchangeContent.adus.requestAdus[v_i].userListRequest.userId
					);
				};

                // Including the invalid APCI with wrong inResponseToApduId
                v_apduForSending := m_apduNoAuthInitTester(v_adus);
                v_apduForSending.infoExchangeContent.apci:=v_apciInvalidInResponseToApduIdRespTester;        	

				// send ProvideUserIdList within TIME1
				f_wait(IS_LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				
				// Start timer
                t_step.start(IS_LISTOFUSERS_TIME2_MAX_TC);               	
             	             
                // Step 3:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3)) or NAck_Protocol_Apdu(sequenceError (4)) 
              	// within time LISTOFUSERS.TIME2
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}
					
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_sequenceError_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_08

			testcase TP_TC_BASE_BI_09() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_09: Verify that the TC correctly responds to an
	 		* invalid apduDate in the APCI field of the received APDU
	 		* @remark  [16986:2016], Clause 6.2.1 and Table A.1/1 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
				// Step 1:
				// Prepare APCI for an Initiating APDU in which the apduDate is invalid (= presents a future date/time)
				template (value) ApciFields m_apciInvalidApduDateInitTester
					modifies m_apciInitTester:= {apduDate := fx_getUtc(100000)};
							
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                // Including the invalid APCI 
                v_apduForSending := m_apduNoAuth(m_apciInvalidApduDateInitTester, {exceptionListADUs:={c_exceptionListAduWhiteValid}});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3)) 
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_09
	
			testcase TP_TC_BASE_BI_10() runs on MainTestComponent system TestAdapter {		
			/**
	 		* @desc TP_TC_Base_BI_10: Verify that the TC responds to incorrect infoExchanceAuthenticators in received APDUs
	 		* @remark  [16986:2016], Clause 6.2.2, Clause 6.3.2 and Table A.1/1 and Table A.3/3 and Table A.7/3
	 		*/
	 
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A3_3_useAuthenticator and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 

				// Set up a correct apdu which not be sent (Black-list) and create an valid authenticator		
				v_apduForSending := m_apduAuthInitTester({exceptionListADUs:={c_exceptionListAduBlackValid1}});

				// Get this correctly computed authenticator				
				var ApduAuthenticator v_authenticator:= v_apduForSending.infoExchangeAuthenticator;
					
				// Step 0:
				// Prepare APCI for an Initiating APDU (White-list) in which the authenticator is replaced by
				// the one calculated above for the black-list, thus inserting an incorrect authenticator
															
				// Step 1:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list with authenticator
                v_apduForSending := m_apduAuthInitTester({exceptionListADUs:={c_exceptionListAduWhiteValid}});
				v_apduForSending.infoExchangeAuthenticator := v_authenticator;
				 
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               

               	// Step 2:	
              	// Wait for NAck_Protocol_Apdu(apduNotOk (3)) 
              	// within time EXCEPTIONLIST.TIME1
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_BASE_BI_10				
		} //end group invalid_behaviour 
	} // end group base TPs 


	group USERDETAILS {
         group Valid_Behaviour {
              
         	testcase TP_TC_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc	TP_TC_USERDETAILS_BV_01: Verify that the TC correctly sends an APDU containing valid RequestADUs
				 *			and provides valid ProvideUserDetailsADUs 
				 * @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_i],mw_aduRequestProvideUserDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;
				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);			
				
				//Step 2 send ProvideUserDetails after TIME1
				f_wait(IS_USERDETAILS_TIME1_MIN_TC);

				//Prepare ProvideUserDetailsADUs
				//All ADUs will be put in the array v_adus
				var Adus v_adus;
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RoUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_standardCommercialUserContract_;
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus.provideUserDetailsADUs[v_loop1]:=v_theAdu;
				}								                   
				
                // Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(IS_USERDETAILS_TIME2_MAX_TC);
				
				//Step 3 wait for AckADU
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BV_01
		} //end group valid behaviour         
         
		group Invalid_Behaviour { 	
			testcase TP_TC_USERDETAILS_BI_01() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc    TP_TC_USERDETAILS_BI_01: Verify that the TC correctly responds to an incorrect ProvideUserDetailsADUs 
				* @remark  [16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_i],mw_aduRequestProvideUserDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;
				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				//Step 2 send ProvideUserDetails after TIME1
				f_wait(IS_USERDETAILS_TIME1_MIN_TC);

				//Prepare ProvideUserDetailsADUs
				//All ADUs will be put in the array v_adus
				var Adus v_adus;
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RoUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest :=PX_USER_ID_NON_EXISTING;//This shall provoke a semanticError
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_standardCommercialUserContract_;
					
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus.provideUserDetailsADUs[v_loop1]:=v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(IS_USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = semantic error (3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semantic error (3000) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var RoNackParams v_nAckParamsList; //Note, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_semanticError_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_01				
				
			testcase TP_TC_USERDETAILS_BI_02() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc		TP_TC_USERDETAILS_BI_02: Verify that the TC correctly responds to a provideUserDetailsADU
				*			with no statusFlag being present 
				* @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_i],mw_aduRequestProvideUserDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;

				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				// Step 2 send ProvideUserDetails after TIME1
				f_wait(IS_USERDETAILS_TIME1_MIN_TC);

				// Prepare ProvideUserDetailsADUs
				// StatusFlg not present
				// All ADUs will be put in the array v_adus
				var Adus v_adus;
				
				// Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RoUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := omit;
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus.provideUserDetailsADUs[v_loop1]:=v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(IS_USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var RoNackParams v_nAckParamsList; //Nte, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_invalidADU_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_02				
				
			testcase TP_TC_USERDETAILS_BI_03() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc		TP_TC_USERDETAILS_BI_03: Verify that the TC correctly responds to a ProvideUserDetailsADU
				*			with statusFlag ranging from 1 to 5 and no listOfUserParameters being present
				* @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_i],mw_aduRequestProvideUserDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;

				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				// Step 2 send ProvideUserDetails after TIME1
				f_wait(IS_USERDETAILS_TIME1_MIN_TC);

				// Prepare ProvideUserDetailsADUs
				// with statusFlag ranging from 1 to 5 and no listOfUserParameters being present
				// All ADUs will be put in the array v_adus
				var Adus v_adus;
				
				// Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RoUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_standardPrivateUserContract_;
					v_theAdu.listOfUserParameters := omit;
					v_adus.provideUserDetailsADUs[v_loop1]:= v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(IS_USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var RoNackParams v_nAckParamsList; //Nte, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_invalidADU_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_03				

			testcase TP_TC_USERDETAILS_BI_04() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc		TP_TC_USERDETAILS_BI_04: Verify that the TC correctly responds to a provideUserDetailsADU with statusFlag value
				*			not included in the interval from 1 to 5 and listOfUserParameters being present
				* @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_i],mw_aduRequestProvideUserDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;

				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				// Step 2 send ProvideUserDetails after TIME1
				f_wait(IS_USERDETAILS_TIME1_MIN_TC);

				// Prepare ProvideUserDetailsADUs
				// with statusFlag value not included in the interval from 1 to 5
				// All ADUs will be put in the array v_adus
				var Adus v_adus;
				
				// Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RoUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_noContractualRelation_; //i.e. "0"
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus.provideUserDetailsADUs[v_loop1]:=v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				// Start timer
				t_step.start(IS_USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var RoNackParams v_nAckParamsList; //Nte, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_invalidADU_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_04				

			testcase TP_TC_USERDETAILS_BI_05() runs on MainTestComponent system TestAdapter {             
				/**
				* @desc		TP_TC_USERDETAILS_BI_05: Verify that the TC correctly responds to a provideUserDetailsADU
				*			with invalid parameters in the UserParameterResponse field
				* @remark	[16986:2016], Clause 6.4 and Table A.1/1 AND Table A.7/1  
				*/
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc

				//Step 1: Trigger IUT with USERDETAILS_TR_TC_1 t send Initiating_APDU
				// containing one or more valid RequestADUs of type userDetailsRequest
				f_sendAndLogTrigger(USERDETAILS_TR_TC_1);
				
             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep				
				
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={mw_aduRequestProvideUserDetails}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_i],mw_aduRequestProvideUserDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
					}
				}

				// Capture the number of Adus received
				var integer v_noReqAdusReceived;

				v_noReqAdusReceived := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				//Step 2 send ProvideUserDetails after TIME1
				f_wait(IS_USERDETAILS_TIME1_MIN_TC);

				// Prepare ProvideUserDetailsADUs
				// with invalid parameters in the UserParameterResponse field; i.e. requestUserParameter present OR
				// userParameterStatus not present OR userInfoValidityPeriod present OR userParameterResponse not present
				// All ADUs will be put in the array v_adus
				var Adus v_adus;
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					var RoUserParameterRequest v_listOfParametersRequested;
					// capture the requested user parameters for this individual adu
					v_listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
					// prepare adu elements
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.userId; // It is enough to resend the received UserIds
					v_theAdu.statusFlag := UserStatus_tempExceptionListed_; //i.e. "�"
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:= omit;
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= TD_USER_PARAM_RESP_DETAILS[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= omit;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:= omit;
					}
					v_adus.provideUserDetailsADUs[v_loop1]:=v_theAdu;
				}								                   

				// Prepare Apdu to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// Send Apdu
				f_sendAndLogApdu(v_apduForSending);

				//Start timer
				t_step.start(IS_USERDETAILS_TIME2_MAX_TC);

				// Step 3: Wait for
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU (0) for ADU#1 ...#n
              	// if not received set test failure --> is done in altstep
              	
              	// prepare nackParams for second alternative
				var RoNackParams v_nAckParamsList; //Nte, this is a record of record
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					v_nAckParamsList[v_loop1] := {
						issueADUStruct := v_loop1+1,
						issueLocation := omit,
						issueContent := omit,
						issueCode := AduReasonCode_invalidADU_,
						issueText := omit
					}
				}
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParamsList)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_USERDETAILS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();   						           
			} // End of TP_TC_USERDETAILS_BI_05				

         } // End group Invalid_Behaviour

    } // End goup USERDETAILS
    
    
    group LISTOFUSERS {
		group Valid_Behaviour {
		
			testcase TP_TC_LISTOFUSERS_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_01: Verify that the TC correctly performs a LISTOFUSERS transaction 
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
  
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1_ONEORMOREADUS to send one or more valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_ONEORMOREADUS);

             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={mw_aduRequestListOfUsers}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified

						for (var integer v_loop:=0; v_loop<lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);v_loop:=v_loop+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop],mw_aduRequestListOfUsers))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
					}
				}

				// Step 2
				// Prepare ProvideUserIdListADUs depending on received request
				var Adus v_adusProvideUserIdList;
				var integer v_i, v_numberOfRequestAdus := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				for (v_i := 0; v_i < v_numberOfRequestAdus; v_i := v_i + 1) {
					v_adusProvideUserIdList.provideUserIdListADUs[v_i]:=
					m_aduProvideUserIdList(
						v_apduReceived.infoExchangeContent.adus.requestAdus[v_i].userListRequest.userId
					);
				};
																	
                // Prepare APDU to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adusProvideUserIdList);              	

				// send ProvideUserIdList within TIME1
				f_wait(IS_LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				

				// Start timer
                t_step.start(IS_LISTOFUSERS_TIME2_MAX_TC);               	
             	             
                // Step 3:	
              	// Wait for Default_Ack 
              	// within time LISTOFUSERS.TIME2
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logReceivedThenCheckAndStopTime(IS_LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();              
			} // End of TP_TC_LISTOFUSERS_BV_01			
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase TP_TC_LISTOFUSERS_BI_01() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_01: Verify that the TC correctly responds
                 * 			to a ProvideUserIdListADU with originalUserId not present
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1_ONEADU to send one valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber} present,
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_ONEADU);

             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={mw_aduRequestListOfUsers}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_i],mw_aduRequestListOfUsers))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
					}
				}

				// Step 2
				// Prepare the ProvideUserIdListADU 
				// but not containing the originalUserId field
                // Prepare APDU to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, {provideUserIdListADUs:={m_aduProvideUserIdList(omit)}});              	

				// send ProvideUserIdList within TIME1
				f_wait(IS_LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				

				// Start timer
                t_step.start(IS_LISTOFUSERS_TIME2_MAX_TC);               	
             	             
              	// Wait for Ack_Apdu within time LISTOFUSERS.TIME2
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for ADU#1
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_invalidADU_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();              
			
			} // End of TP_TC_LISTOFUSERS_BI_01

			testcase TP_TC_LISTOFUSERS_BI_02() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_02: Verify that the TC correctly responds to a ProvideUserIdListADU
                 *			with userIds which have not be requested in the requestADU
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                
	  			// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1_THREEADUS to send three(3) valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber} present,
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_THREEADUS);

             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={
						mw_aduRequestListOfUsers,
						mw_aduRequestListOfUsers,
						mw_aduRequestListOfUsers}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified
					}
				}

				// Step 2
				// Prepare ProvideUserIdListADUs depending on received request
				// but with userIds which have not been requested
				var Adus v_adus;
				var integer v_i, v_numberOfRequestAdus := lengthof(v_apduReceived.infoExchangeContent.adus.requestAdus);
				
				for (v_i := 0; v_i < v_numberOfRequestAdus; v_i := v_i + 1) {
					v_adus.provideUserIdListADUs[v_i]:=
					m_aduProvideUserIdList(
						PX_USERS_NOT_EXISTING[v_i]
					);
				};
																	
                // Prepare APDU to be sent
                v_apduForSending := m_apduNoAuthRespTester(v_apduReceived, v_adus);              	

				// send ProvideUserIdList within TIME1
				f_wait(IS_LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				

				// Start timer
                t_step.start(IS_LISTOFUSERS_TIME2_MAX_TC);               	
             	             
              	// Wait for Ack_Apdu within time LISTOFUSERS.TIME2
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for ADU#1, #2 and #3
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(
						mw_apduNAckIndividualIssuesIut(
							v_apduForSending,
							{
								m_nackParams(1, AduReasonCode_semanticError_),
								m_nackParams(2, AduReasonCode_semanticError_),
								m_nackParams(3, AduReasonCode_semanticError_)
							}
						)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();              
			} // End of TP_TC_LISTOFUSERS_BI_02
			
			testcase TP_TC_LISTOFUSERS_BI_03() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_03: Verify that the TC correctly responds to a ProvideUserIdListADU
                 *			with invalid userId data
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                
                // Step 3: Wait for NAck_Apdu with ({0, invalidADU(0)})
                // or NAck_Apdu with ({1, InvalidADU(0)}, ... {n, invalidADU(0)})
                // where n is the number of ProvideUserIdListADUs
                // within LISTOFUSERS.TIME2 
		  		
		  		// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_2_implementedLISTOFUSERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1_THREEADUS to send exactely one(1) valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber} present,
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data
				f_sendAndLogTrigger(LISTOFUSERS_TR_TC_1_ONEADU);

             	// Wait for expected RequestADU 
              	// if not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({requestAdus:={mw_aduRequestListOfUsers}})) -> value v_apduReceived {
						// Log what we received, check and stop time
						f_logApduReceivedAndTStep(); // no minimum time specified
					}
				}

				// Step 2
				// Prepare the ProvideUserIdListADU depending on received request
				var ProvideUserIdListADU v_aduProvideUserIdList:=
				m_aduProvideUserIdList(v_apduReceived.infoExchangeContent.adus.requestAdus[0].userListRequest.userId);

				//Make the userId-list invalid by setting the userIds to empty
				v_aduProvideUserIdList.userIdList:={{},{},{}};
																	
                // Prepare APDU to be sent
                v_apduForSending:= m_apduNoAuthRespTester(v_apduReceived, {provideUserIdListADUs:={v_aduProvideUserIdList}});              	

				// send ProvideUserIdList within TIME1
				f_wait(IS_LISTOFUSERS_TIME1_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);       				

				// Start timer
                t_step.start(IS_LISTOFUSERS_TIME2_MAX_TC);               	
             	             
              	// Wait for Ack_Apdu within time LISTOFUSERS.TIME2
                //		- NAck_Apdu with aduReasonCode = invalidADU(0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidADU(0) for ADU#1
              	// if not received set test failure --> is done in altstep
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending,m_roNackParamsSingle(1, AduReasonCode_invalidADU_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_LISTOFUSERS_TIME2_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();              			
			} // End of TP_TC_LISTOFUSERS_BI_03
		} // End of Invalid_Behaviour
		
	} // End of group LISTOFUSERS
    
	group EXCEPTIONLIST {
		
		group Valid_Behaviour {
		
			testcase TP_TC_EXCEPTIONLIST_BV_01() runs on MainTestComponent system TestAdapter {
										
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BV_01: 1)	Verify that the TC correctly responds to an ExceptionListADU
                 *			for blacklist and whitelist
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				// Start by setting test success
				
				// Loop (first intertation [LIST_TYPE] = black; second iteration [LIST_TYPE] = white)
							
                // Step 1 / loop 1 for black list:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for black list
                v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduBlackValid1}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
					}
				}
				
				// Note: Step 2 may start immediately as no TIMEA is defined for EXCEPTIONLIST
				
				// Step 2 / loop 2 for white list:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduWhiteValid}});
				f_sendAndLogApdu(v_apduForSending);                	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
				} 				 
				f_closeDownMtc();              
			} // End of TP_TC_EXCEPTIONLIST_BV_01                              

			testcase TP_TC_EXCEPTIONLIST_BV_02() runs on MainTestComponent system TestAdapter {
										
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BV_02: Verify that the TC correctly responds to an ExceptionListADU
                 *			for discounted user list
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */

 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
				// Start by setting test success
							
                // Step 1:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for discounted user list
                v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduDiscountedValid}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_DISCOUNT_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
                //		- Default_Ack, or
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_semanticError_))) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}								
				}			 
				f_closeDownMtc();
			}            
		} // End of group Valid_Behaviour
			
		group Invalid_Behaviour {
		
			testcase TP_TC_EXCEPTIONLIST_BI_01() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_01: Verify that the TC correctly responds to an ExceptionListADU for blacklist containing
            *			exceptionValidityEnd field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */
		
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
							
            	// Prepare Initiating_Apdu containing
 				//		- exactly one ExceptionListADU indicating list type BLACK and containing exceptionValidityEnd of any value

				// prepare this invalid adu below
				const ExceptionListADU c_exceptionListAduBlackInvalid1 := {
					exceptionListVersion := TD_EXCEPTIONLIST_VERSION,
					exceptionListType := ExceptionListType_blackList_,
			  		exceptionValidityStart := fx_getUtc(),
			  		exceptionValidityEnd := fx_getUtc(100000), // the presence of this value makes the adu invalid
			  		exceptionListEntries := {{
			  	  		userId := TD_USERID_1,
			  	  		statusType := ExceptionListStatusType_locallyBlocked_,
			  	  		reasonCode := ExceptionListReasonType_notToBeDisclosed_,
			  	  		entryValidityStart := fx_getUtc(),
			  	  		entryValidityEnd := omit,
			  	  		vehicleParameters := TD_VEHICLE_PARAMETERS,
			  	  		actionRequested := ExceptionListActionType_rejectOBE_,
			  	  		efcContextMark := omit,
			  	  		vatId := TD_VAT_ID
					}}
				};
				  			
                v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduBlackInvalid1}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
            	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               

              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = exceptionListsDateAndTimeRejected(405) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsDateAndTimeRejected(405) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_exceptionListsDateAndTimeRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_exceptionListsDateAndTimeRejected_))) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}								
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_01

			testcase TP_TC_EXCEPTIONLIST_BI_02() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_02: Verify that the TC correctly responds to an ExceptionListADU for blacklist
            *			containing the efcContextMark field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 
          
            	// Step 1: Send Initiating_Apdu containing exactly one ExceptionListADU indicating list type BLACK containing
            	//		- efcContextMark of any value
            	
            	// prepare this invalid adu below
 				const ExceptionListADU c_exceptionListAduBlackInvalid2 := {
					exceptionListVersion := TD_EXCEPTIONLIST_VERSION,
					exceptionListType := ExceptionListType_blackList_,
			  		exceptionValidityStart := fx_getUtc(),
			  		exceptionValidityEnd := omit,
			  		exceptionListEntries := {{
			  	  		userId := TD_USERID_2,
			  	  		statusType := ExceptionListStatusType_locallyBlocked_,
			  	  		reasonCode := ExceptionListReasonType_notToBeDisclosed_,
			  	  		entryValidityStart := fx_getUtc(),
			  	  		entryValidityEnd := omit,
			  	  		vehicleParameters := TD_VEHICLE_PARAMETERS,
			  	  		actionRequested := ExceptionListActionType_rejectOBE_,
			  	  		efcContextMark := TD_EFC_CONTEXT_MARK, // the presence of this value makes the adu invalid
			  	  		vatId := TD_VAT_ID
					}}
				};
            	            	
               	v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduBlackInvalid2}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	

                // Start timer
                t_step.start(IS_EXCEPTIONLIST_BLACK_TIME1_MAX_TC);     
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_invalidADU_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_02

			testcase TP_TC_EXCEPTIONLIST_BI_03() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_03: Verify that the TC correctly responds to one APDU
            *			containing more than one ExceptionListADU
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */ 				

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 

            	// Step 1: Send Initiating_Apdu containing more than one ExceptionListADU indicating list type BLACK
               	v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={
               		c_exceptionListAduBlackValid1,c_exceptionListAduBlackValid2
               	}});
               	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
		
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with apduNotOk(3)
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_03

			testcase TP_TC_EXCEPTIONLIST_BI_04() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_04: Verify that the TC correctly responds to an ExceptionListADU
            *			bearing an incorrect value for exceptionListVersion field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */
		
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 

           		// Step 1: Send Initiating_Apdu containing one ExceptionListADU indicating list type BLACK
            	//		- with exceptionListVersion not larger than 0

            	// prepare this invalid adu below
 				const ExceptionListADU c_exceptionListAduBlackInvalid3 := {
					exceptionListVersion := 0, // this makes the adu invalid 
					exceptionListType := ExceptionListType_blackList_,
			  		exceptionValidityStart := fx_getUtc(),
			  		exceptionValidityEnd := omit,
			  		exceptionListEntries := {{
			  	  		userId := TD_USERID_2,
			  	  		statusType := ExceptionListStatusType_locallyBlocked_,
			  	  		reasonCode := ExceptionListReasonType_notToBeDisclosed_,
			  	  		entryValidityStart := fx_getUtc(),
			  	  		entryValidityEnd := omit,
			  	  		vehicleParameters := TD_VEHICLE_PARAMETERS,
			  	  		actionRequested := ExceptionListActionType_rejectOBE_,
			  	  		efcContextMark := omit,
			  	  		vatId := TD_VAT_ID
					}}
				};

               	v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduBlackInvalid3}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
		
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = exceptionListsVersionRejected(400) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsVersionRejected(400) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_exceptionListsVersionRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_exceptionListsVersionRejected_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();	
			} // End of TP_TC_EXCEPTIONLIST_BI_04

			testcase TP_TC_EXCEPTIONLIST_BI_05() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_05: Verify that the TC correctly responds to an ExceptionListADU
			*			bearing an incorrect value for exceptionListType field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */   				

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 

             	// Step 1: Send Initiating_Apdu containing one ExceptionListADU indicating exceptionListType = 4

            	// prepare this invalid adu below
 				const ExceptionListADU c_exceptionListAduListType4 := {
					exceptionListVersion := TD_EXCEPTIONLIST_VERSION, 
					exceptionListType := ExceptionListType_otherListType2_, // list type 4 which is nit allowed in IAP
			  		exceptionValidityStart := fx_getUtc(),
			  		exceptionValidityEnd := omit,
			  		exceptionListEntries := {{
			  	  		userId := TD_USERID_1,
			  	  		statusType := ExceptionListStatusType_locallyBlocked_,
			  	  		reasonCode := ExceptionListReasonType_notToBeDisclosed_,
			  	  		entryValidityStart := fx_getUtc(),
			  	  		entryValidityEnd := omit,
			  	  		vehicleParameters := TD_VEHICLE_PARAMETERS,
			  	  		actionRequested := ExceptionListActionType_rejectOBE_,
			  	  		efcContextMark := omit,
			  	  		vatId := TD_VAT_ID
					}}
				};

               	v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduListType4}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
		
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_BLACK_TIME1_MAX_TC);            
            	
              	// Wait for Ack_Apdu within time TIME_DEFAULT
                //		- NAck_Apdu with aduReasonCode = exceptionListsTypeRejected(401) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsTypeRejected(401) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_exceptionListsTypeRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logApduReceivedAndTStep();
						//Check minumum time and stop timer
						t_step.stop;
						setverdict(pass);
					}					

					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_exceptionListsTypeRejected_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logApduReceivedAndTStep();
						//Check minumum time and stop timer
						t_step.stop;
						setverdict(pass);
					}										
				}
				f_closeDownMtc();	
			} // End of TP_TC_EXCEPTIONLIST_BI_05

			testcase TP_TC_EXCEPTIONLIST_BI_06() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_06: Verify that the TC correctly responds to an ExceptionListADU
            *			bearing an incorrect value for userId field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */
  				
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                 

	            // Step 1: Send Initiating_Apdu containing one ExceptionListADU of list type BLACK
    	        // and userId = contractSerialNumber present
				
				var ExceptionListADU v_exceptionListADU:=m_aduExceptionList(
					ExceptionListType_blackList_,
					TD_USERID_DISCOUNTED_1,
					ExceptionListStatusType_locallyBlocked_,
					ExceptionListReasonType_notToBeDisclosed_,
					ExceptionListActionType_rejectOBE_
				);
               	v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={v_exceptionListADU}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
		
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_BLACK_TIME1_MAX_TC);           
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = exceptionListsUserIdRejected(402) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsUserIdRejected(402) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_exceptionListsUserIdRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_exceptionListsUserIdRejected_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();	
			} // End of TP_TC_EXCEPTIONLIST_BI_06

			testcase TP_TC_EXCEPTIONLIST_BI_07() runs on MainTestComponent system TestAdapter {
													
            /**
             * @desc    TP_TC_EXCEPTIONLIST_BI_07: Verify that the TC responds correctly
             *			to a RequestADU sent earlier than allowed
             * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
             */  				

				// Initialisation
				//check if the testcase shall run, activate altsteps on ports, etc 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST and (IS_EXCEPTIONLIST_BLACK_TIME0_MIN_TC > 0.0);
				f_intialiseMtc(v_runOrNot);                 
							
                // Transaction 1
            	// Step 1: Send Initiating_Apdu containing one valid ExceptionListADU of list type BLACK
            
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for black list
                v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduBlackValid1}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               

                // Transaction 1 / Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
					}
				}
								
				// Transaction 2
            	// Step 1: Send second Initiating_Apdu containing one valid ExceptionListADU of list type BLACK
            	// before TIME0 MIN has passed = immediately after the Ack in Transaction 1 
            	
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for black list
                v_apduForSending := m_apduNoAuthInitTester({exceptionListADUs:={c_exceptionListAduBlackValid1}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
  	
                // Start timer
                t_step.start(IS_EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               

				// Step 2: Wait for NAck_Apdu with issueCode=NAck_requestSentTooOften(10)
            	// within the time EXCEPTIONLIST.BLACK_TIME1 
              	// if negative Ack or not received set test failure --> is done in altstep            	

				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time		
						f_logReceivedThenCheckAndStopTime(IS_EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_07
		} // End of group Invalid_Behaviour 	
	} // End of group EXCEPTIONLIST					

	
	group PAYMENTCLAIM {
	
		group Valid_Behaviour {	
			testcase TP_TC_PAYMENTCLAIM_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_01_DSRC: Verify that the TC correctly performs the PAYMENTCLAIM 
                 * @desc	transaction with actionCode=send 
                 * @remark  [16986:2016], Clause 6.8 and Table A.1/1 AND Table A.7/5
                 */
                  
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_5_implementedPAYMENTCLAIM;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc
                  
                // Step 0:
                // Let IUT perform one BILLINGDETAILS complete and sucessful transaction
                // this step is differnet for TCs operating a DSRC Toll Domain or a GNSS Toll Domain

				if (ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS) {
                
					f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_SEND);

					var template InfoExchange v_apduToReceive := 
					mw_apduNoAuthInitIut({billingDetailsADUs:={mw_aduDsrcBillingDetails}});                 

                	// Wait for above specified APDU within time constraints
                	// if not received or received outside specification or time constraints set test fail (done in the altstep)

					alt {
						[] mtcPort.receive(v_apduToReceive) -> value v_apduReceived {
							// Log what we received, no minimum time	
							f_logApduReceivedAndTStep();

                            for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);v_i:=v_i+1){
                                if (not (match(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i],mw_aduDsrcBillingDetails))){
                                    f_addLogEntry("One of the ADUs does not match the ADU restrictions");
                                    setverdict(fail);
                                    f_closeDownMtc();   						           				
                                    stop;
                                }
                            }					               		
						}
					} // End of alt statement

					// Step 2: Send Ack within time constraints
					f_wait(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TC);
					f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
				} // end if-branch
				else { // else-branch for GNSS Toll Charger
					
					f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);

					var template InfoExchange v_apduToReceive := mw_apduNoAuthInitIut(
						{billingDetailsADUs:={modifies mw_aduGnssBillingDetails:= {actionCode := ActionCode_send_ }}}
					);                 

                	// Wait for above specified APDU within time constraints
                	// if not received or received outside specification or time constraints set test fail (done in the altstep)

					alt {
						[] mtcPort.receive(v_apduToReceive) -> value v_apduReceived {
							// Log what we received, no minimum time	
							f_logApduReceivedAndTStep();
							
                            for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);v_i:=v_i+1){
                                if (not (match(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i] , mw_aduGnssBillingDetails))){
                                    f_addLogEntry("One of the ADUs does not match the ADU restrictions");
                                    setverdict(fail);
                                    f_closeDownMtc();   						           				
                                    stop;
                                }
                            }					               									
						}
					} // End of alt statement

					// Step 2: Send Ack within time constraints
					f_wait(IS_GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
					f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
				}; // end else-branch      	                              
  
 				// define templates required for later matching with data in PaymentClaim
 				var template UserIdList v_receivedBillingDetailsUserIdList, v_receivedPaymentClaimUserIdList;
 
 				// Note: Type definition for this is in module templates
 				var template BillingDetailsIdList v_receivedBillingDetailsIdList;
				
				var integer v_numberOfReceivedBillingDetailsAdus, v_numberOfReceivedPaymentClaimAdus;
 				
 				v_numberOfReceivedBillingDetailsAdus := lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);
 				
 				// fill templates (two records of) with received data
 				for (var integer v_i := 0; v_i < v_numberOfReceivedBillingDetailsAdus; v_i := v_i +1) {
 					v_receivedBillingDetailsUserIdList[v_i] := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i].userId;
 					v_receivedBillingDetailsIdList[v_i] := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i].billingDetailsId;
				}
  				  
                // Step 1:
                // Payment Claim transaction

                // Start timer for TIMEB_MAX (time between receiving the AckADU of the BillingDeatails transaction and
                // sending an corresponding PaymentClaim ADU)
                t_step.start(IS_PAYMENTCLAIM_TIMEB_MAX_TC);               

				// Send trigger (IuT to perform a Payment Claim transaction
				// containing exactly one PaymentClaim ADU with action_code = send 
				f_sendAndLogTrigger(PAYMENTCLAIM_TR_TC_1_SEND);

                // Prepare APDU to be received
				var template InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut({paymentClaimADUs:={modifies mw_aduPaymentClaim:= {
			  		paymentClaimStatus := PaymentClaimStatus_firstVersion_,
			  		actionCode := ActionCode_send_ }}}
				);                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail (done in the altstep)
				// Note that according to ISO 12855 only one PaymentClaim ADU is allowed per APDU

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no minimum time required	

						f_logApduReceivedAndTStep();
							
						// check inside the adu for each billing details id in the billing details list
						// if this billing details ID (and user id used in the adu) is inside the list of pairs received in billing details 
						var boolean v_matchingUserIdBillingDetailsIdPair;
						// Note: there is only one paymentClaimAdu and consequentely only one userID
						for (
							var integer v_i:=0; 
							v_i < lengthof(v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].referenceDetailsList); 
							v_i:=v_i + 1
						) {
							for (
								var integer v_j:=0; 
								v_j < lengthof(v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].referenceDetailsList[v_i].billingDetailsList); 
								v_j:=v_j + 1
							) {
								for (var integer v_k:=0; v_k < v_numberOfReceivedBillingDetailsAdus; v_k:=v_k + 1) {									
									if (
										(v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].userId == v_receivedBillingDetailsUserIdList[v_k]) 
										// if matching user Id found
										and (v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].referenceDetailsList[v_i].billingDetailsList[v_j] == v_receivedBillingDetailsIdList[v_k])
									) {	
										v_matchingUserIdBillingDetailsIdPair := true; // matching pair found
										break; // move out from the k-loop
									} else { // matching pair not present
										v_matchingUserIdBillingDetailsIdPair := false;
									}
								}
								if (v_matchingUserIdBillingDetailsIdPair == false) {
									f_addLogEntry("Fail. UserId and/or billingDetailsId in PaymentClaim do not match with those in BillingDetails");
									setverdict(fail);
									stop;
								}
							}
						};

						if (v_matchingUserIdBillingDetailsIdPair) { 
							// Step 2: Send Ack within time constraints
							f_wait(IS_PAYMENTCLAIM_TIME1_MIN_TC);
							f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
							// Set test success
							setverdict(pass);
						} 
					} // end this alt-branch
				} // End of alt statement            	                              
				f_closeDownMtc();            
			} // End of TP_TC_LISTOFUSERS_BV_01
	 				
			testcase TP_TC_PAYMENTCLAIM_BV_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_02: Verify that the TC correctly performs the PAYMENTCLAIM transaction with
                 *			actionCode=revoke and adjust  
                 * @remark  [16986:2016], Clause 6.8 and Table A.1/1 AND Table A.7/5
                 */

  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_5_implementedPAYMENTCLAIM;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc
                  
                // Step 0:
                // Let IUT perform one BILLINGDETAILS complete and sucessful transaction
                // this step is differnet for TCs operating a DSRC Toll Domain or a GNSS Toll Domain
				var template InfoExchange v_apduToBeReceived;
				if (ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS) {
                
					f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_SEND);

					v_apduToBeReceived := mw_apduNoAuthInitIut({billingDetailsADUs:={m_aduDsrcBillingDetails}});                 

                	// Wait for above specified APDU within time constraints
                	// if not received or received outside specification or time constraints set test fail (done in the altstep)

					alt {
						[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
							// Log what we received, no minimum time	
							f_logApduReceivedAndTStep();
							
                            for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);v_i:=v_i+1){
                                if (not (match(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i],mw_aduDsrcBillingDetails))){
                                    f_addLogEntry("One of the ADUs does not match the ADU restrictions");
                                    setverdict(fail);
                                    f_closeDownMtc();   						           				
                                    stop;
                                }
                            }					               														              		
						}
					} // End of alt statement

					// Step 2: Send Ack within time constraints
					f_wait(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TC);
					
					f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
				} // end if-branch
				else { // else-branch for GNSS Toll Charger
					
					f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);

					v_apduToBeReceived := mw_apduNoAuthInitIut({billingDetailsADUs:={modifies mw_aduGnssBillingDetails:= {actionCode := ActionCode_send_ }}});                 

                	// Wait for above specified APDU within time constraints
                	// if not received or received outside specification or time constraints set test fail (done in the altstep)

					alt {
						[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
							// Log what we received, no minimum time	
							f_logApduReceivedAndTStep();
							
                            for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);v_i:=v_i+1){
                                if (not (match(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i], mw_aduGnssBillingDetails))){
                                    f_addLogEntry("One of the ADUs does not match the ADU restrictions");
                                    setverdict(fail);
                                    f_closeDownMtc();   						           				
                                    stop;
                                }
                            }					               														              		
						}
					} // End of alt statement
					
					// Step 2: Send Ack within time constraints
					f_wait(IS_GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
					f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
				} // end else-branch      	                              

 				// define templates required for later matching with data in PaymentClaim
 				var template UserIdList v_receivedBillingDetailsUserIdList, v_receivedPaymentClaimUserIdList;
 				// Note: Type definition for this is in module templates
 				var template BillingDetailsIdList v_receivedBillingDetailsIdList;
				
				var integer v_numberOfReceivedBillingDetailsAdus, v_numberOfReceivedPaymentClaimAdus;
 				
 				v_numberOfReceivedBillingDetailsAdus := lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);
 				
 				// fill templates (two records of) with received data
 				for (var integer v_i := 0; v_i < v_numberOfReceivedBillingDetailsAdus; v_i := v_i +1) {
 					v_receivedBillingDetailsUserIdList[v_i] := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i].userId;
 					v_receivedBillingDetailsIdList[v_i] := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i].relatedBillingDetails;
				}
  				  
                // Step 1:
                // Perform a full and valid Payment Claim transaction

                // Start timer for TIMEB_MAX (time between receiving the AckADU of the BillingDeatails transaction and
                // sending an corresponding PaymentClaim ADU)
                t_step.start(IS_PAYMENTCLAIM_TIMEB_MAX_TC);               

				// Send trigger (IuT to perform a Payment Claim transaction
				// containing exactly one PaymentClaim ADU with action_code = send 
				f_sendAndLogTrigger(PAYMENTCLAIM_TR_TC_1_SEND);

                // Prepare APDU to be received
				v_apduToBeReceived := mw_apduNoAuthInitIut({paymentClaimADUs:=
					{modifies mw_aduPaymentClaim:= {
				  		paymentClaimStatus := PaymentClaimStatus_firstVersion_,
				  		actionCode := ActionCode_send_ 
				  	}}}
				);                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail (done in the altstep)
				// Note that according to ISO 12855 only one PaymentClaim ADU is allowed per APDU

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no minimum time required	

						f_logApduReceivedAndTStep();
							
						// check inside the adu for each billing details id in the billing details list
						// if this billing details ID (and user id used in the adu) is inside the list of pairs received in billing details 
						var boolean v_matchingUserIdBillingDetailsIdPair;
						// Note: there is only one paymentClaimAdu and consequentely only one userID
						for (var integer v_i:=0; v_i < lengthof(v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].referenceDetailsList); v_i:=v_i + 1) {
							for (var integer v_j:=0; v_j < lengthof(v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].referenceDetailsList[v_i].billingDetailsList); v_j:=v_j + 1) {
								for (var integer v_k:=0; v_k < v_numberOfReceivedBillingDetailsAdus; v_k:=v_k + 1) {									
									if ((v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].userId == v_receivedBillingDetailsUserIdList[v_k]) 
										// if matching user Id found
									and (v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].referenceDetailsList[v_i].billingDetailsList[v_j] == v_receivedBillingDetailsIdList[v_k])) {	
										v_matchingUserIdBillingDetailsIdPair := true; // matching pair found
										break; // move out from the k-loop
									} else { // matching pair not present
										v_matchingUserIdBillingDetailsIdPair := false;
									}
								}
								if (v_matchingUserIdBillingDetailsIdPair == false) {
									f_addLogEntry("Fail. UserId and/or billingDetailsId in PaymentClaim do not match with those in BillingDetails");
									setverdict(fail);
									stop;
								}
							}
						};
						
						if (v_matchingUserIdBillingDetailsIdPair) { 
							f_addLogEntry("Billing details in payment claim received correspond t the billing details in the previous billing details trasnaction");
							// Step 2: Send Ack within time constraints
							f_wait(IS_PAYMENTCLAIM_TIME1_MIN_TC);
						} 
					} // end this alt-branch
				} // End of alt statement            	                              

				// Step 2: Send NAck (except of issueCode "acceptedWithWarning")
				// within time constraints to initiate the following adjust
				f_wait(IS_PAYMENTCLAIM_TIME1_MIN_TC);
				f_sendAndLogApdu(m_apduNAckIndividualIssuesTester(v_apduReceived, m_roNackParamsSingle(1, AduReasonCode_semanticError_)));

                // Step 3:
                // Let the IuT perform a PaymentClaim transaction with exactly one PaymentClaim ADU with actionCode = ADJUST
                // Note: It may be the case the IuT send exactly the same pay payment claims as before as they might not contain errors

                // Prepare APDU to be received
                // PaymentId shall be the same as in the previous PaymentClaim ADU
				v_apduToBeReceived := mw_apduNoAuthInitIut(
					{paymentClaimADUs:={modifies mw_aduPaymentClaim:= {
				  		paymentClaimId := v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimId,
				  		paymentClaimStatus := PaymentClaimStatus_amendedVersion_ ,
				  		actionCode := ActionCode_adjust_ 
				  	}}}
				);                 

 				// Send trigger
				f_sendAndLogTrigger(PAYMENTCLAIM_TR_TC_1_ADJUST);

				// start time to check compliance to TIMEA_MIN
				// Note: there is no maximum time defined but a timer is started check below minimum IS_PAYMENTCLAIM_TIMEA_MIN_TC 
                t_step.start(c_veryLongTime);                
 
                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail (done in the altstep)
				// Note that according to ISO 12855 only one PaymentClaim ADU is allowed per APDU				
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no minimum time required	
						f_logReceivedThenCheckAndStopTime(IS_PAYMENTCLAIM_TIMEA_MIN_TC);
						f_addLogEntry("Adjust transaction passed");
					}
				}

				// Step 4: Send Ack within time constraints
				f_wait(IS_PAYMENTCLAIM_TIME1_MIN_TC);
				f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
                 
                // Step 5:
                // Let the IuT perform a PaymentClaim transaction with exactly one PaymentClaim ADU with actionCode = REVOKE

                // Prepare APDU to be received
                // PaymentId shall be the same as in the previous PaymentClaim ADU
				v_apduToBeReceived := mw_apduNoAuthInitIut({paymentClaimADUs:={
					modifies mw_aduPaymentClaim:= {
				  		paymentClaimId := v_apduReceived.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimId,
				  		paymentClaimStatus := PaymentClaimStatus_amendedVersion_,
				  		actionCode := ActionCode_revoke_ 
				  	}
				}});                 

				// Send trigger
				f_sendAndLogTrigger(PAYMENTCLAIM_TR_TC_1_REVOKE);

				// start time to check compliance to TIMEEA_MIN
				// Note: there is no maximum time defined but a timer shall be started to check below minimum IS_PAYMENTCLAIM_TIMEA_MIN_TC 
                t_step.start(c_veryLongTime);                

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail (done in the altstep)
				// Note that according to ISO 12855 only one PaymentClaim ADU is allowed per APDU
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no minimum time required	
						f_logReceivedThenCheckAndStopTime(IS_PAYMENTCLAIM_TIMEA_MIN_TC);
						// Step 6: Send Ack within time constraints
						f_wait(IS_PAYMENTCLAIM_TIME1_MIN_TC);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				}
				f_closeDownMtc();            																
			} // End of TP_TC_PAYMENTCLAIM_BV_02
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {
		
               /**
                 * @remark  No TPs have been defined
                 */
 		
 		} // End Invalid_Behaviour
 		
 	} // End PAYMENTCLAIM	



	group DSRC_BILLINGDETAILS {
		group Valid_Behaviour {
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_BILLINGDETAILS_BV_01: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=send
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A26.3
                */
				
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc
                                  
                // Step 1: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1_SEND to send valid Initiating_Apdu containing BillingDetailsADUs
                // containing all valid permutations of present and not present optional fields and choices that are used
                // in the IUT implementation, all with actionCode = send

				f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_SEND);

				var template InfoExchange v_apduToBeReceived :=	mw_apduNoAuthInitIut(
					{billingDetailsADUs:={
						modifies mw_aduDsrcBillingDetails:= {actionCode := ActionCode_send_ }}
					}
				);                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time	
						f_logReceivedThenCheckAndStopTime(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TC);					              		

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i],mw_aduDsrcBillingDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
						// Step 2: Send Ack within time constraints
						f_wait(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_01
			
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_02: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=adjust
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A.36/15 = adjust
                */
 
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc
                                  
                // Step 0: Trigger IUT with DSRC.BILLINGDETAILS_TR_TC_1_ADJUST to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send and adjust the same BillingDetailsId in a second step
                
                f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_ADJUST);

				// receive the BillingDetailsADU

				var template InfoExchange v_apduToBeReceived :=	mw_apduNoAuthInitIut(
					{billingDetailsADUs:={modifies mw_aduDsrcBillingDetails:= {actionCode := ActionCode_send_ }}}
				);                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						f_checkMinimumTStep(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TC);	

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i],mw_aduDsrcBillingDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
					}
				}

				// capture the billingDetailsId for validation in step 2
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[0].billingDetailsId;

				// Step 2: Send NAck within time constraints
				f_wait(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TSP);				

				// send a negative Ack (except of issueCode "acceptedWithWarning")
				v_apduForSending:=m_apduNAckIndividualIssuesTester(v_apduReceived, m_roNackParamsSingle(1, AduReasonCode_semanticError_));
				f_sendAndLogApdu(v_apduForSending);

                // Step 2: Wait for IUT to send adjusted BillingDetailsADU
                // with actionCode = adjust
                // with same billingDetailsId as already received billingDetailsId
                
				v_apduToBeReceived := mw_apduNoAuthRespIut(
					v_apduForSending,
					{billingDetailsADUs:={
						modifies mw_aduDsrcBillingDetails:= {
					  		billingDetailsId := v_receivedBillingDetailsId,
					  		actionCode := ActionCode_adjust_
					  	}
					}}
				);                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TC);					              		

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i],mw_aduDsrcBillingDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		

						// Step 2: Send Ack within time constraints
						f_wait(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_02
						
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_03: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=revoke
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A.36/15 = revoke
                */
 
   				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc
                                  
                // Step 1: Trigger IUT with DSRC.BILLINGDETAILS_TR_TC_1_REVOKE to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send and revoke the same BillingDetailsId in a second step
                
                f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_ADJUST);

				// receive the BillingDetailsADU

				var template InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut(
					{billingDetailsADUs:={modifies mw_aduDsrcBillingDetails:= {actionCode := ActionCode_send_ }}}
				);                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						f_checkMinimumTStep(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TC);	
					}
				}

				// capture the billingDetailsId for validation in step 2
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[0].billingDetailsId;

				// Step 2: Send NAck within time constraints
				f_wait(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
				v_apduForSending:=m_apduDefaultAckTester(v_apduReceived);
				f_sendAndLogApdu(v_apduForSending);

                // Step 3: Wait for IUT to send adjusted BillingDetailsADU
                // with actionCode = revoke
                // with billingDetailsId as already received billingDetailsId
                
				v_apduToBeReceived := mw_apduNoAuthRespIut(
					v_apduForSending,
					{billingDetailsADUs:={modifies mw_aduDsrcBillingDetails:= {
						billingDetailsId := v_receivedBillingDetailsId,
						actionCode := ActionCode_revoke_
					}}}
				); 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TC);					              		

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[v_i],mw_aduDsrcBillingDetails))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		

						// Step 2: Send Ack within time constraints
						f_wait(IS_DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_03
		} // End Valid_Behaviour
		
		group Invalid_Behaviour {

               /**
                 * @remark  No TPs have been defined
                 */			
			
		} // End Invalid_Behaviour
		
	} // End DSRC_BILLINGDETAILS


	group DSRC_CONTRACTISSUERLIST {
		group Valid_Behaviour {		
			testcase TP_TC_DSRC_CONTRACTISSUERLIST_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BV_01: Verify that the TC correctly performs
                 *			a DSRC.CONTRACTISSUERLIST transaction with three ContractIssuerListADUs  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.2/1 AND Table A.26/1
                 */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc
                                		              
                // Step 1:
                // Prepare and send Initiating_Apdu containing three ContractIssuerListADUs with differing manufacturerID values
				v_apduForSending := m_apduNoAuthInitTester({contractIssuerListADUs:={
					  	TD_CONTRACT_ISSUER_DATA_VALID_1,
					  	TD_CONTRACT_ISSUER_DATA_VALID_2,
					  	TD_CONTRACT_ISSUER_DATA_VALID_3
					  	}});                 
				f_sendAndLogApdu(v_apduForSending);                     
                
                // Start timer
                t_step.start(IS_DSRC_CONTRACTISSUERLIST_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time DSRC.CONTRACTISSUERLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
				} 
				f_closeDownMtc();                	
              } // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BV_01              
		} // End group Valid_Behaviour
					
		group Invalid_Behaviour {	
			testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BI_01: Verify that the TC correctly responds to
                 *			a ContractIssuerListADUs with three different semantically faulty parameters  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.2/1 AND Table A.26/1
                 */

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                        		
                 
                // Step 1:
                // Send Initiating_Apdu containing three ContractIssuerListADUs each one with exactly
                // one incorrect parameter value from the set [uniquePartOfPan, acCrKeyReference, authKeyReference]

				v_apduForSending := m_apduNoAuthInitTester({contractIssuerListADUs:={
					  	TD_CONTRACT_ISSUER_DATA_INVALID_1,
					  	TD_CONTRACT_ISSUER_DATA_INVALID_2,
					  	TD_CONTRACT_ISSUER_DATA_INVALID_3
					}});                 
				f_sendAndLogApdu(v_apduForSending); 
                
                // Start timer
                t_step.start(IS_DSRC_CONTRACTISSUERLIST_TIME1_MAX_TC);   

              	// Wait for NAck_Apdu within time DSRC.CONTRACTISSUERLIST.TIME1
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for ADU#1, #2 and #3
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}

					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {
						m_nackParams(1, AduReasonCode_semanticError_),
						m_nackParams(2, AduReasonCode_semanticError_),
						m_nackParams(3, AduReasonCode_semanticError_)})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}										
				}
				f_closeDownMtc();				            	          				
			} // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_01			

			testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BI_02: Verify that the TC correctly responds to a RequestADU
                 *			sent earlier than allowed  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.2/1 AND Table A.26/1
                 */

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc                        		

                // Step 0: Send Initiating_Apdu containing one ContractIssuerListADU
                // Prepare and send one Initiating_Apdu containing exactly one ContractIssuerListADU
                v_apduForSending := m_apduNoAuthInitTester({contractIssuerListADUs:={TD_CONTRACT_ISSUER_DATA_VALID_1}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                                                
                // Step 1: Send second Initiating_Apdu containing one ContractIssuerListADU
                // before DSRC.CONTRACTISSUERLIST.TIMEA_MIN has passed
				f_wait(0.0);

				v_apduForSending := m_apduNoAuthInitTester({contractIssuerListADUs:={TD_CONTRACT_ISSUER_DATA_VALID_1}});                 
				f_sendAndLogApdu(v_apduForSending); 
                
                // Start timer
                t_step.start(IS_DSRC_CONTRACTISSUERLIST_TIME1_MAX_TC);   

				// Step 2: Wait for NAck_Apdu with issueCode=NAck_requestSentTooOften(10)
            	// within the time DSRC.CONTRACTISSUERLIST.TIME1  
              	// if other Ack or not received set test failure --> is done in altstep            	

				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				            	
			} // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_02
		} // End group Invalid_Behaviour
	} // End DSRC_CONTRACTISSUERLIST 

	group DSRC_REPORTABNORMALOBE {
		group Valid_Behaviour {
			testcase TP_TC_DSRC_REPORTABNORMALOBE_BV_01() runs on MainTestComponent system TestAdapter {							
               /**
                * @desc    TP_TC_DSRC_REPORTABNORMALOBE_BV_01: Verify that the TC correctly performs a DSRC.REPORTABNORMALOBE transaction
                * @remark  [16986:2016], Clause 7.4 and Table A.1/1 AND Table A.2/1 AND Table A.26/4
                */

  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc
                 
                // Step 1: Trigger IUT with DSRC.REPORTABNORMALOBE_TR_TC_1 to send valid Initiating_APDU containing
                // one or more ADUs of type ReportAbnormalOBEADU containing different combinations of valid
                // and IUT declared values in the following data elements
				//		- userID = at least one element shall be present (ensured in the template);
				//		- dateAndTime = present and valid;
				//		- efcContextMark = present and valid;
				//		- abnormalOBEReason code = present and valid                
				f_sendAndLogTrigger(DSRC_REPORTABNORMALOBE_TR_TC_1);

				//  Wait for DSRC.REPORTABNORMALOBE ADU
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_adusReportAbnormalObe)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					

						for (var integer v_i:=0; v_i<lengthof(v_apduReceived.infoExchangeContent.adus.reportAbnormalOBEADUs);v_i:=v_i+1){
							if (not (match(v_apduReceived.infoExchangeContent.adus.reportAbnormalOBEADUs[v_i],mw_aduReportAbnormalObe))){
								f_addLogEntry("One of the ADUs does not match the ADU restrictions");
								setverdict(fail);
								f_closeDownMtc();   						           				
								stop;
							}
						}					               		
						// Step 2: Send Ack within time constraints
						f_wait(IS_DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();   						           
			} // End testcase TP_TC_DSRC_REPORTABNORMALOBE_BV_01	
		} // End Valid_Behaviour

		group Invalid_Behaviour {
               /**
                 * @remark  No TPs have been defined
                 */			
		} // End Invalid_Behaviour		
	} // End DSRC_REPORTABNORMALOBE

	group DSRC_EFCCONTEXTDATA {
		group Valid_Behaviour {
			testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_01: Verify that the TC correctly performs a DSRC.EFCCONTEXTDATA transaction
                 *			for a domain type = dsrcContext  
                 * @remark  [16986:2016], Clause 7.2 and Table A.1/1 AND Table A.2/1 AND Table A.26/2 AND Table A.30/2 = dsrcContext
                 */
 
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_2_implementedDSRCEFCCONTEXTDATA and ICS_A30_2_implementedDSRCCONTEXT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc
                                  					
                // Step 1: Tigger IUT with DSRC.EFCCONTEXTDATA_TR_TC_1_A to send valid Initiating_Apdu
                // containing a EFCContextDataADU as the only ADU, with
                //		- domainType = dsrcContext;
                //		- the values of all fields in EFCContextDataADU being within the range specified by the IUT
				f_sendAndLogTrigger(DSRC_EFCCONTEXTDATA_TR_TC_1_DSRC_OPEN);

                // Wait for above specified Initiating_Apdu within time constraints
                // if not received or received outside specification set test fail (done in altstep)

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({efcContextDataADUs:={mw_aduDsrcEfcContextData}})) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					              		
						// Step 2: Send Ack within time constraints
						f_wait(IS_DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_01	
			
			testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_02: Verify that the TC correctly performs a DSRC.EFCCONTEXTDATA transaction
                 *			for a domain type = dsrcClosedContext  
                 * @remark  [16986:2016], Clause 7.2 and Table A.1/1 AND Table A.2/1 AND Table A.26.2 AND Table A.30/2 = dsrcContext
                 */
 			
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_2_implementedDSRCEFCCONTEXTDATA and ICS_A30_2_implementedDSRCCONTEXT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc
                                  
				// Step 1: Tigger IUT with DSRC.EFCCONTEXTDATA_TR_TC_1_B to send valid Initiating_Apdu
                // containing a EFCContextDataADU as the only ADU, with
                //		- domainType = dsrcClosedContext;
                //		- the values of all fields in EFCContextDataADU being within the range specified by the IUT
				f_sendAndLogTrigger(DSRC_EFCCONTEXTDATA_TR_TC_1_DSRC_CLOSED);

                // Wait for above specified Initiating_Apdu within time constraints
                // if not received or received outside specification set test fail (done in altstep)

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({efcContextDataADUs:={mw_aduDsrcClosedContextEfcContextData}})) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					              		
						// Step 2: Send Ack within time constraints
						f_wait(IS_DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_02							
		} // End Valid_Behaviour

		group Invalid_Behaviour {
               /**
                 * @remark  No TPs have been defined
                 */			
		} // End Invalid_Behaviour		
	} // End DSRC_EFCCONTEXTDATA

	group GNSS_TOLLDECLARATION {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_TOLLDECLARATION_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_01: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = send
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
								
                // Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send

                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = send                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for discounted user list

				v_apduForSending := m_apduTollDeclarationsTen(ActionCode_send_);
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
                
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
                
				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass)												
					}
				}	
				f_closeDownMtc();						 
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_01

			testcase TP_TC_GNSS_TOLLDECLARATION_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_02: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = revoke
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
				
                // Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 

                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = send

				v_apduForSending := m_apduTollDeclarationsTen(ActionCode_send_);
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail 

				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
											
                // Step 2:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations with tollDeclarationId = same value as already received toll declarations and
                // containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = revoke
                             
                // Send second Initiating_Apdu containing ten valid TollDeclarationADUs with actionCode = revoke
                // after IS_GNSS_TOLLDECLARATIONS_TIMEA_MIN_TC has passed
                // i.e. the tester respects time limits declared by the IuT 
				f_waitTimeA(IS_GNSS_TOLLDECLARATIONS_TIMEA_MIN_TC);

                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = revoke
                // Note that it is required to send again with same TollDeclarationId,
                // same TollDeclarations and same Charge Report Id
				v_apduForSending := m_apduTollDeclarationsTen(ActionCode_revoke_);
				                
                // Step 3:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
						//Set verdict
						setverdict(pass)												
					}					
				}
				f_closeDownMtc();				
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_02

			testcase TP_TC_GNSS_TOLLDECLARATION_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_03: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = adjust
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
				
				// Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				//		- all toll declaration IDs have the same charge report counter ids to motivate negative Ack from IuT

				// Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = send
				
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs := {
						m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_1,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_2,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_3,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_4,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_5,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_6,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_7,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_8,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_9,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_10,
						1,
						ActionCode_send_)
					}
				});				
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
								
                // Wait for NAck_Apdu within GNSS.TOLLDECLARATION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

                // Prepare parameters to be expected in the NAck-APDU of any adu reason
				var template RoNackParams v_nAckParams_1 := {
					m_nackParams(0, AduReasonCode_invalidADU_)
				};
				var template RoNackParams v_nAckParams_2 := {
					m_nackParams(1, AduReasonCode_invalidADU_),
					m_nackParams(2, AduReasonCode_invalidADU_),
					m_nackParams(3, AduReasonCode_invalidADU_),
					m_nackParams(4, AduReasonCode_invalidADU_),
					m_nackParams(5, AduReasonCode_invalidADU_),
					m_nackParams(6, AduReasonCode_invalidADU_),
					m_nackParams(7, AduReasonCode_invalidADU_),
					m_nackParams(8, AduReasonCode_invalidADU_),
					m_nackParams(9, AduReasonCode_invalidADU_),
					m_nackParams(10, AduReasonCode_invalidADU_)
				};
				
				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}

				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
								
                // Step 2:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations with tollDeclarationId = same value as already received toll declarations and
                // containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = adjust

                // Send second Initiating_Apdu containing ten valid TollDeclarationADUs with actionCode = revoke
                // after IS_GNSS_TOLLDECLARATIONS_TIMEA_MIN_TC has passed
                // i.e. the tester respects time limits declared by the IuT 
				f_waitTimeA(IS_GNSS_TOLLDECLARATIONS_TIMEA_MIN_TC);
				
                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = adjust
                // Note that it is required to send again with same TollDeclarationId,
                                // but "corrected" TollDeclarations and a new Charge Report Id
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_11,
						11,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						c_usageStatement_12,
						12,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3},
						c_usageStatement_13,
						13,
						ActionCode_adjust_),							
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4},
						c_usageStatement_14,
						14,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5},
						c_usageStatement_15,
						15,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 6},
						c_usageStatement_16,
						16,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 7},
						c_usageStatement_17,
						17,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 8},
						c_usageStatement_18,
						18,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 9},
						c_usageStatement_19,
						19,
						ActionCode_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 10},
						c_usageStatement_20,
						20,
						ActionCode_adjust_)
				}});
				
                // Step 3:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
						//Set verdict
						setverdict(pass)												
					}
				}
				f_closeDownMtc();				
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_03
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_01: Verify that the TC correctly responds to an APDU containing
                *			a number of TollDeclarationADUs which exceeds PARAM1_MAX
                *			that are not the same as the original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
								
                // Step 1:
                // Send Initiating_Apdu containing TollDeclarationADUs
                // with valid and IUT declared values but exceeding GNSS.TOLLDECLARATION.PARAM1_MAX

				// Prepare and send an Initiating_Apdu with PARAM1_MAX + 1 TollDeclarationADUs with actionCode = send
				 
				var Adus v_adusToBeSent; //List of ADUs to be sent 
				var UsageStatement v_usageStatementToBeSent;

				for (var integer v_loop := 0; v_loop < IS_GNSS_TOLLDECLARATIONS_PARAM1_MAX_TC; v_loop := v_loop + 1) {	
 					v_usageStatementToBeSent := {
						usageStatementId := v_loop,
						tollContext := PX_TOLL_CONTEXT_ID_IUT,
						aggregatedSingleTariffClassSession := TD_SINGLE_TARIFF_CLASS_SESSION_1, //TODO Jan, this used to be TD_SINGLE_TARIFF_CLASS_SESSION without the "_1". I assumed that the first of the two values was OK to use. Btw, should it not be a PX? Corrected a few below 
						listOfChargeObjects:=PX_LIST_OF_CHARGE_OBJECTS,
						listOfRawUsageData := PX_LIST_OF_RAW_USAGE_DATA,
						additionalUsageInformation := omit
					};
 					v_adusToBeSent.tollDeclarationADUs[v_loop] := m_aduTollDeclarationToSendOneObe(
							{TD_IDENTIFIER, v_loop},
							v_usageStatementToBeSent,
							v_loop,
							ActionCode_send_);
				}		
 					
				v_apduForSending := m_apduNoAuthInitTester(v_adusToBeSent);
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
                
                // Step 2:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({n,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
                
                // Prepare parameters to be expected in the NAck-APDU
				var RoNackParams v_nAckParams_1 := m_roNackParamsSingle(0, AduReasonCode_semanticError_);
				var RoNackParams v_nAckParams_2 := m_roNackParamsSingle(IS_GNSS_TOLLDECLARATIONS_PARAM1_MAX_TC, AduReasonCode_semanticError_);

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_01
		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_02: Verify that the TC correctly responds to an APDU containing
                * 			valid TollDeclarationADUs with actionCode = revoke but tollDeclarationIds
                *			that are not the same as the original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // gnssTollDeclarations containing valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = send

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_1,
						1,
						ActionCode_send_)
					}});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
								
                // Step 2:
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // a gnssTollDeclaration with tollDeclarationId /= the value as already received toll declaration and
				// containing valid and IUT declared values for
				// 		- chargeReport,
				//		- chargeReportUsageStatementList and
				//		- usageStatement; and
				//		- actionCode = revoke

                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = revoke
                // same TollDeclarations and same Charge Report Id
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						c_usageStatement_2,
						2,
						ActionCode_revoke_)
					}});
                
                // Send Initiating_Apdu containing TollDeclarationADUs with actionCode = revoke
                // after IS_GNSS_TOLLDECLARATIONS_TIMEA_MIN_TC has passed
                // i.e. the tester respects time limits declared by the IuT 
				f_waitTimeA(IS_GNSS_TOLLDECLARATIONS_TIMEA_MIN_TC);

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               				

                // Step 3:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var RoNackParams v_nAckParams_1 := m_roNackParamsSingle(0, AduReasonCode_semanticError_);
				var RoNackParams v_nAckParams_2 := m_roNackParamsSingle(1, AduReasonCode_semanticError_);

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_02

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_03: Verify that the TC correctly responds to an APDU containing
                *			valid TollDeclarationADUs with actionCode = adjust but tollDeclarationIds
                *			that are not the same the as original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // gnssTollDeclarations containing valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = send

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_1,
						1,
						ActionCode_send_)
					}});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

				alt {
					[] mtcPort.receive(m_apduDefaultAckTester(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
								
                // Step 2:
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // a gnssTollDeclaration with tollDeclarationId /= the value as already received toll declaration and
				// containing valid and IUT declared values for
				// 		- chargeReport,
				//		- chargeReportUsageStatementList and
				//		- usageStatement; and
				//		- actionCode = adjust

                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = revoke
                // same TollDeclarations and same Charge Report Id
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						c_usageStatement_2,
						2,
						ActionCode_adjust_)
					}});

                // Send Initiating_Apdu containing TollDeclarationADUs with actionCode = adjust
                // after IS_GNSS_TOLLDECLARATIONS_TIMEA_MIN_TC has passed
                // i.e. the tester respects time limits declared by the IuT 
				f_waitTimeA(IS_GNSS_TOLLDECLARATIONS_TIMEA_MIN_TC);

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               				
                
                // Step 3:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var RoNackParams v_nAckParams_1 := m_roNackParamsSingle(0, AduReasonCode_semanticError_);
				var RoNackParams v_nAckParams_2 := m_roNackParamsSingle(1, AduReasonCode_semanticError_);

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_03

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_04: Verify that the TC correctly responds to an APDU
                *			containing valid TollDeclarationADUs with tollDeclarationIds being not unique
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing two TollDeclarationADU containing
				//		- tollDeclarationId = same values in the two toll declarations, and
				//		- gnssTollDeclarations with valid and IUT declared values, and
				//		- actionCode = send
				
                // Prepare and send one Initiating_Apdu containing exactly two TollDeclarationADUs with actionCode = send

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_1,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_1,
						2,
						ActionCode_send_)
					}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with apduAckCode = apduNotOK (3)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

                // Prepare parameters to be expected in the NAck-APDU
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_04
               		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_05: Verify that the TC correctly responds to an APDU containing
                *			valid TollDeclarationADUs with gnssTollDeclaration of Choice AuthenticatedChargeReport
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing
				//		- gnssTollDeclaration of Choice AuthenticatedChargeReport, and
				//		- actionCode = send
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclaratioN
                // of Choice AuthenticatedChargeReport with actionCode = send

				var TollDeclarationADU v_aduTollDeclarationAuthenticatedChargeReport := {
					tollDeclarationId := {TD_IDENTIFIER, 1}, 
					gnssTollDeclaration := {{
						authenticatedChargeReport := TD_AUTHENTICATED_CHARGE_REPORT
					}},
					actionCode:= ActionCode_send_
				};
				
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={v_aduTollDeclarationAuthenticatedChargeReport}});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with apduAckCode = apduNotOK (3)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

 				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                								
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_05

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_06: Verify that the TC correctly responds to an APDU containing
                *			a number of chargeReports which exceeds GNSS.TOLLDECLARATION.PARAM2_MAX
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
								
                // Step 1:
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- more than GNSS.TOLLDECLARATION.PARAM2_MAX chargeReports containing valid and IUT declared values;
				//		- actionCode = send

				// Prepare and send an Initiating_Apdu with PARAM2_MAX + 1 chargeReports with actionCode = send
				 
				var Adus v_adusToBeSent;
				var UsageStatement v_usageStatementToBeSent;
				var RoChargeReportChoice v_roChargeReportChoice;
				
				for (var integer v_loop := 0; v_loop < IS_GNSS_TOLLDECLARATIONS_PARAM2_MAX_TC; v_loop := v_loop + 1) {	
 					v_usageStatementToBeSent := {
						usageStatementId := v_loop,
						tollContext := PX_TOLL_CONTEXT_ID_IUT,
						aggregatedSingleTariffClassSession := TD_SINGLE_TARIFF_CLASS_SESSION_1, //TODO Jan, see comment above
						listOfChargeObjects := PX_LIST_OF_CHARGE_OBJECTS,
						listOfRawUsageData := PX_LIST_OF_RAW_USAGE_DATA,
						additionalUsageInformation := omit
					};

					v_roChargeReportChoice[v_loop]:={
						chargeReport := {
							protocolVersion := AidIdentifier_iso17575_1_2016_,
							obeId := TD_OBE_ID_1,
							vehicleLPNr := TD_LPN_1,
							paymentMeans := TD_PAYMENT_MEANS_1,
							serviceProviderContract := TD_EFC_CONTEXT_MARK,
							tollContext:= PX_TOLL_CONTEXT_ID_IUT,
							usageStatementList := {
								{usageStatement := v_usageStatementToBeSent}
							},
							chargeReportCounter := v_loop
						}
					}
					
				};
										
 				v_adusToBeSent.tollDeclarationADUs[0] := {
 					tollDeclarationId := {TD_IDENTIFIER, 1},
					gnssTollDeclaration:=v_roChargeReportChoice,
					actionCode := ActionCode_send_						
				};
				v_apduForSending := m_apduNoAuthInitTester(v_adusToBeSent);
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
                
                // Step 2:
                // Wait for NAck_Apdu with (with issues= NULL)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
                
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                								
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_06

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_07() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_07: Verify that the TC correctly responds to an APDU containing
                *			a TollDeclarationADU in which the actionCode is not present
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- with valid and IUT declared values, and
                //		- actionCode = NULL
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclaration
                // with actionCode = NULL

				var TollDeclarationADU v_aduTollDeclarationToSendOneObeOtherActionCodes:=m_aduTollDeclarationToSendOneObe(
					{TD_IDENTIFIER, 1},
					c_usageStatement_1,
					1,
					ActionCode_send_ //action code is deleted in next step
				); 	
				v_aduTollDeclarationToSendOneObeOtherActionCodes.actionCode:=omit; 

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					v_aduTollDeclarationToSendOneObeOtherActionCodes
				}});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var RoNackParams v_nAckParams_1 := m_roNackParamsSingle(0, AduReasonCode_semanticError_);
				var RoNackParams v_nAckParams_2 := m_roNackParamsSingle(1, AduReasonCode_semanticError_);

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_07
	                		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_08() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_08: Verify that the TC correctly responds to an APDU containing
                *			a TollDeclarationADU in which the actionCode is neither send, revoke nor adjust
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- with valid and IUT declared values, and
                //		- actionCode /= {send, revoke, adjust}
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclaration
                // with actionCode = 4

				var TollDeclarationADU v_adu:=m_aduTollDeclarationToSendOneObe(
					{TD_IDENTIFIER, 1},
					c_usageStatement_1,
					1,
					ActionCode_resend_ //this is an action code that provokes an error
				); 	

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={v_adu}});

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with
                //		- ({0,actionCodeNotSupported(3010)}) OR
                //		- ({1,actionCodeNotSupported(3010)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var RoNackParams v_nAckParams_1 := m_roNackParamsSingle(0, AduReasonCode_actionCodeNotSupported_);
				var RoNackParams v_nAckParams_2 := m_roNackParamsSingle(1, AduReasonCode_actionCodeNotSupported_);

				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_08

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_09() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_09: Verify that the TC correctly responds to an APDU containing
                *			more than one TollDeclarationADUs with actionCode send of which
                *			one or more fields in the toll declarations and/or underlying data elements are invalid
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
				 								
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
				
                // Step 1:
                // Send Initiating_Apdu containing
                //		- one TollDeclarationADU with valid and IUT declared values; and
                //		- one TollDeclarationADU with values not declared as IUT implemented
                //		- actionCode = send
                				
                // Prepare the above defined Apdu
                
                var TollDeclarationADU v_tollDeclarationAduNotIutDeclared;

				v_tollDeclarationAduNotIutDeclared:={
					 tollDeclarationId:={TD_IDENTIFIER, 2},
					 gnssTollDeclaration:={
					 	{
					 		chargeReport:={
					 			protocolVersion:=7, // version not supported by the IuT
					 			obeId:=TD_OBE_ID_5,
					 			vehicleLPNr:=TD_LPN_7,
					 			paymentMeans:=TD_PAYMENT_MEANS_1,
					 			serviceProviderContract:=TD_EFC_CONTEXT_MARK,
					 			tollContext:=PX_TOLL_CONTEXT_ID_NOT_EXISTING, // Toll Context not managed by the IuT
					 			chargeReportFinalRecipient:=omit, // shall not be used according to IAP
					 			timeOfReport:=fx_getUtc(0), // shall not be used according to IAP
					 				// and therefore deemed not declared and supported by the IuT
					 			reportPeriod:=omit, // optional
					 			versionInfo:=omit, // optional
					 			usageStatementList:={
					 				{
					 					usageStatement:=c_usageStatement_5 
					 				}
					 			},
					 			sumVatForThisSession:=omit, // shall not be used according to IAP
					 			accountStatus:=AccountStatus_low_, // shall not be used according to IAP
					 				// and therefore deemed not declared and supported by the IuT
					 			chargeReportCounter:=2,
					 			mileage:={  // shall not be used according to IAP
					 				// and therefore deemed not declared and supported by the IuT
					 				dist:=2374, // distance = 2374 units
					 				disUnit:= DisUnit_metres_ // units are defined as meters
					 			},
					 			listOfCccAttributes:=omit  // shall not be used according to IAP
					 		}
					 	}
					 },
					 actionCode:= ActionCode_send_
				};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_1,
						1,
						ActionCode_send_),
					v_tollDeclarationAduNotIutDeclared
					}});
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Step 2:
                // Wait for Ack_Apdu with
                //		- ({2,semanticError(3000)})
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdus
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var RoNackParams v_nAckParams_1 := m_roNackParamsSingle(2, AduReasonCode_semanticError_);

                // Prepare parameters to be expected in the NAck-APDU
				alt {
					[] mtcPort.receive(m_apduNAckIndividualIssuesTester(v_apduForSending, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_09
			
		} // End Invalid_Behaviour
		
	} // End GNSS_TOLLDECLARATION

	group GNSS_BILLINGDETAILS_TSP {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when a TSP provides a single BillingDetailsADU
                *			with no optional fields except includedDiscounts and actionCode=send
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56.6
                */
 								                 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_6_implementedIncludedDiscounts;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with two(2) tollDeclarations
				// receive positive Ack
				
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};
				 	
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

				// Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- includedDiscounts is present; and
				//		- actionCode=send

				// prepare this adu below
							
				const BillingDetailsADU c_aduGnssBillingDetailsWithDiscounts := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1,
					TD_PERIOD_1,
					{m_sectionedRoadGnssUsageList},
					TD_BILLINGDETAILS_AMOUNT_1,
					{c_refTollDeclaration1}, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);
																
				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={c_aduGnssBillingDetailsWithDiscounts}});	

                // No wait time for sending the Initiating_Apdu containing one valid BillingDetailsADU

				// Note: No wait, as there is no minimum time beteween TollDeclaration and corresponding BillingDetails defined				
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides
                *			a single BillingDetailsADU with no optional fields, actionCode = send
                *			and having selected forSectionedRoads
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/1
                */
 								                 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_1_implementedSectionedRoads;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send
		
				// prepare this adu below
				var UsageList v_usageListSectionedRoads := m_sectionedRoadGnssUsageList; 
				v_usageListSectionedRoads.includedDiscounts:=omit;
				
				var BillingDetailsADU v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1,
					TD_PERIOD_1,
					{v_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{c_refTollDeclaration1}, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsSectionedRoads}});	

                // No wait time for sending the Initiating_Apdu containing one valid BillingDetailsADU

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forTravellingInArea
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_2_implementedTravellingInArea;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for TravellingInArea, and
				//		- the value of entranceChargeObjectName in forCordonCrossing being a correct UTF8String, and
				//		- actionCode=send
			
				const BillingDetailsADU c_aduGnssBillingDetailsTravellingInArea := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1,
					TD_PERIOD_1,
					{m_travellingInAreaGnssUsageList},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{c_refTollDeclaration1}, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={c_aduGnssBillingDetailsTravellingInArea}});	

                // No wait time for sending the Initiating_Apdu containing one valid BillingDetailsADU

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forStayingInArea
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/3
                */
 								
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_3_implementedStayingInArea;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack

				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for StayingInArea, and
				//		- actionCode=send
			
				const BillingDetailsADU c_aduGnssBillingDetailsStayingInArea := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1,
					TD_PERIOD_1,
					{m_stayingInAreaGnssUsageList },
					TD_BILLINGDETAILS_AMOUNT_1, // no toll discount
					{c_refTollDeclaration1}, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={c_aduGnssBillingDetailsStayingInArea}});	

                // No wait time for sending the Initiating_Apdu containing one valid BillingDetailsADU

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forCordonCrossings
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/4
                */
                  
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_4_implementedCordonCrossing;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed because only one ADU

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack

				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for CordonCrossing, and
				//		- actionCode=send

				const BillingDetailsADU c_aduGnssBillingDetailsCordonCrossing := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1,
					TD_PERIOD_1,
					{m_cordonCrossingGnssUsageList},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{c_refTollDeclaration1}, // same toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={c_aduGnssBillingDetailsCordonCrossing}});	

                // No wait time for sending the Initiating_Apdu containing one valid BillingDetailsADU

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05
 
			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06: Verify that the TC correctly performs
                *			a GNSS_BILLINGDETAILS_TSP transaction when the TSP provides multiple BillingDetailsADUs
                *			with no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_4_implementedCordonCrossing;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with GNSS.BILLINGDETAILS.TSP.PARAM1_MAX tollDeclaration adus
				// receive positive Ack

				// create APDU with GNSS.BILLINGDETAILS.TSP.PARAM1_MAX toll declaration adus				   
				 
				var Adus v_adusToBeSent; //List of ADUs to be sent 
				var UsageStatement v_usageStatementToBeSent;
				var ListOfTollDeclarationIds v_listOfTollDeclarationIds;				

				for (var integer v_loop := 0; v_loop < IS_GNSS_BILLINGDETAILS_TSP_PARAM1_MAX_TC; v_loop := v_loop + 1) {	
 					v_usageStatementToBeSent := {
						usageStatementId := v_loop,
						tollContext := PX_TOLL_CONTEXT_ID_IUT,
						aggregatedSingleTariffClassSession := TD_SINGLE_TARIFF_CLASS_SESSION, //TODO Jan see comment above
						listOfChargeObjects:=PX_LIST_OF_CHARGE_OBJECTS,
						listOfRawUsageData := PX_LIST_OF_RAW_USAGE_DATA,
						additionalUsageInformation := omit
					};
 					v_listOfTollDeclarationIds[v_loop] := {TD_IDENTIFIER, v_loop}; 
 					v_adusToBeSent.tollDeclarationADUs[v_loop] := m_aduTollDeclarationToSendOneObe(
							v_listOfTollDeclarationIds[v_loop],
							v_usageStatementToBeSent,
							v_loop,
							ActionCode_send_);
				}					   

				v_apduForSending := m_apduNoAuthInitTester(v_adusToBeSent);	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a GNSS.BILLINGDETAILS.TSP.PARAM1_MAX valid BillingDetailsADUs with
                //		- actionCode = send and no optional fields
 				 
				var RoBillingDetailsId v_listOfBillingDetailsIds;
				
				for (var integer v_loop:= 0; v_loop < IS_GNSS_BILLINGDETAILS_TSP_PARAM1_MAX_TC; v_loop := v_loop + 1) {	
				v_adusToBeSent.billingDetailsADUs[v_loop] := m_aduGnssBillingDetails (
					v_listOfBillingDetailsIds[v_loop].billingDetailsNum,
					TD_USERID_1,
					TD_PERIOD_1,
					{m_sectionedRoadGnssUsageList},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{v_listOfTollDeclarationIds[v_loop]}, // same array of toll decalartion Id as in Toll Declaration in step 0
					ActionCode_send_
					);
				}
				v_apduForSending := m_apduNoAuthInitTester(v_adusToBeSent);	

                // No wait time for sending the Initiating_Apdu containing one valid BillingDetailsADU

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP sends a single BillingDetailsADU
                *			with actionCode = adjust and no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */

				// Initialitastion 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_1_implementedSectionedRoads;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send invalid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send
				//		- Toll Declaration reference which does not correspond to the last Toll Declaration

				// prepare this adu below
				var UsageList v_usageListSectionedRoads :=m_sectionedRoadGnssUsageList;
				v_usageListSectionedRoads.includedDiscounts:=omit;
				
				var BillingDetailsADU v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_2, // user ID does not match the user Id in the corresponding toll declaratiuon
					TD_PERIOD_1,
					{v_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_1,
					{c_refTollDeclaration1},
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsSectionedRoads}});	

                // No wait time for sending the Initiating_Apdu containing one valid BillingDetailsADU

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for negative Ack_Apdu with AduReason code
                //		- NAck_Apdu with aduReasonCode = billingDetailsUserIdRejected (704) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = billingDetailsUserIdRejected (704) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep
                // within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_billingDetailsUserIdRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_billingDetailsUserIdRejected_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}										
				}	

                // Step 3:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = adjust, and
				//		- no optional fields, and
				//		- billingDetailsNum referencing the previously received BillingDetailsADU
                  
				// prepare this adu below
				
				var BillingDetailsADU v_aduGnssBillingDetailsCordonCrossing := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1, // now with correct user ID
					TD_PERIOD_1,
					{m_cordonCrossingGnssUsageList},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{c_refTollDeclaration1},
					ActionCode_adjust_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsCordonCrossing}});	

                // Send Initiating_Apdu containing BillingDetailsADU
                // after IS_GNSS_BILLINGDETAILS_TIMEA_MIN_TC has passed
                // i.e. the tester respects time limits declared by the IuT 
				f_waitTimeA(IS_GNSS_BILLINGDETAILS_TIMEA_MIN_TC);

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				

                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
  				// Initialisation

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08: VVerify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP sends a single BillingDetailsADU
                *			with actionCode =revoke and no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */

				// Initialitastion 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_1_implementedSectionedRoads;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send invalid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send

				// prepare this adu below
				var UsageList v_usageListSectionedRoads := m_sectionedRoadGnssUsageList; 
				v_usageListSectionedRoads.includedDiscounts:=omit;
				
				var BillingDetailsADU v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1,
					TD_PERIOD_1,
					{v_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{c_refTollDeclaration1},
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsSectionedRoads}});	

                // No wait time for sending the Initiating_Apdu containing one valid BillingDetailsADU

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	

                // Step 3:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = revoke, and
				//		- no optional fields, and
				//		- billingDetailsNum referencing the previously received BillingDetailsADU
                  
				// prepare this adu below
				v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1, // now with correct user ID
					TD_PERIOD_1,
					{v_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{c_refTollDeclaration1},
					ActionCode_revoke_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsSectionedRoads}});	

                // Send Initiating_Apdu containing BillingDetailsADU
                // after IS_GNSS_BILLINGDETAILS_TIMEA_MIN_TC has passed
                // i.e. the tester respects time limits declared by the IuT 
				f_waitTimeA(IS_GNSS_BILLINGDETAILS_TIMEA_MIN_TC);

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				

                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
  				// Initialisation

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						// Set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08
			
		} // End Valid_Behaviour

		group Invalid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01: Verify that the TC correctly responds
                *			when receiving multiple BillingDetailsADUs with no optional fields present
                *			with each BillingDetailsADU having one field with an incorrect value
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
				// Initialitastion 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_1_implementedSectionedRoads;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	
                 
                // Step 1:
                // Send valid Initiating_Apdu containing 10 BillingDetailsADUs with
                //		- all mandatory fields, and
                //		- no optional fields,
                //		- where the following fields have an incorrect value
                //			(a) billingDetailsId.issuerId
                //			(b) tollContext
                //			(c)	userId
                //			(d) billingDetailsAmount
                //			(e) usageDetails.contextName
                //			(f) usageDetails.appliedUserClass
                //			(g) usageDetails.perDeclaredVehicleClasses
                //			(h)	usageDetails.appliedTimeClass
                //			(i) usageDetails.entranceTime
                //			(j) usageList.ListofSections.chargeObjectId
                 
 				var Adus v_adus;
				
				//TODO extract magic numbers into Tester Data (possibly as constants)
				v_adus.billingDetailsADUs[0]:= m_aduGnssBillingDetailsSpecialised(1,TD_USERID_1, c_refTollDeclaration1);
				v_adus.billingDetailsADUs[0].billingDetailsId.issuerId:=TD_INVALID_APDU_ORIGINATOR_TESTER; //billingDetailsIssuerIdRejected


				v_adus.billingDetailsADUs[1]:=m_aduGnssBillingDetailsSpecialised(2,	TD_USERID_1, c_refTollDeclaration1);
				v_adus.billingDetailsADUs[1].tollContext:= TD_INVALID_APDU_ORIGINATOR_TESTER; ///billingDetailsContextIdRejected
				//TODO Consider renaming TD_INVALID_APDU_ORIGINATOR_TESTER to TD_PROVIDER_NON_EXISTING

				v_adus.billingDetailsADUs[2]:=m_aduGnssBillingDetailsSpecialised(3,	{}, c_refTollDeclaration1); //billingDetailsUserIdRejected 							

				v_adus.billingDetailsADUs[3]:=m_aduGnssBillingDetailsSpecialised(4,	TD_USERID_1, c_refTollDeclaration1);
				v_adus.billingDetailsADUs[3].billingDetailsAmount.paymentFeeUnit:='0999'O; //this corresponds to ISO 4217 "No currency", shall provoke billingDetailsAmountRejected
							
				v_adus.billingDetailsADUs[4]:=m_aduGnssBillingDetailsSpecialised(5,	TD_USERID_1, c_refTollDeclaration1);
				v_adus.billingDetailsADUs[4].usageDetails.contextName:="AREA 51, NEVADA"; //billingDetailsContextNameRejected
							
				v_adus.billingDetailsADUs[5]:=m_aduGnssBillingDetailsSpecialised(6,	TD_USERID_1, c_refTollDeclaration1);
				v_adus.billingDetailsADUs[5].usageDetails.appliedUserClass:="NON-EXISTING USER CLASS"; //billingDetailsAppliedUserClassRejected
			
				v_adus.billingDetailsADUs[6]:=m_aduGnssBillingDetailsSpecialised(7, TD_USERID_1, c_refTollDeclaration1);
				v_adus.billingDetailsADUs[6].usageDetails.perDeclaredVehicleClasses[0].declaredVehicleClass:="NON-EXISTING VEHICLE CLASS"; //billingDetailsDeclaredVehicleClassRejected 
				
				v_adus.billingDetailsADUs[7]:=m_aduGnssBillingDetailsSpecialised(8, TD_USERID_1, c_refTollDeclaration1);
				v_adus.billingDetailsADUs[7].usageDetails.perDeclaredVehicleClasses[0].perUsedTimeClasses[0].appliedTimeClass:="NON-EXISTING TIME CLASS";//billingDetailsAppliedTimeClassRejected 
				
				v_adus.billingDetailsADUs[8]:=m_aduGnssBillingDetails(
					9,
					TD_USERID_1,
					TD_PERIOD_1,
					{{usageListEntry:={forStayingInArea := {
						areaDisplayName:="The area display name",
						qualifier:= {entranceTime:=fx_getUtc(86400)},//set to 24 hours in the future - billingDetailsEntranceTimeRejected
						stayedDuration:=1000,
						chargeUnit:={time:={dur:=100,durUnit:=DurUnit_seconds_}}
					}}}},
					PX_MAX_ACCEPTED_BILLINGDETAILS_AMOUNT,
					{c_refTollDeclaration1},
					ActionCode_send_
				);			
			
				v_adus.billingDetailsADUs[9]:=m_aduGnssBillingDetails(
					10,
					TD_USERID_1,
					TD_PERIOD_1,
					{{usageListEntry:={forSectionedRoads := {
						howManyTimes:=1,
						listOfSections:={{
							chargeObjectId:={
								chargeObjectDesignation:=PX_CHARGE_OBJECT_DESIGNATION_NON_EXISTING //billingDetailsIntermediateSectionRejected
							}
						}}
					}}}},
					PX_MAX_ACCEPTED_BILLINGDETAILS_AMOUNT,
					{c_refTollDeclaration1},
					ActionCode_send_
				);			

				v_apduForSending := m_apduNoAuthInitTester(v_adus);                 

                // No wait time for sending the Initiating_Apdu

				f_sendAndLogApdu(v_apduForSending);						
               	
                 // Step 2: Wait for negative Ack within IS_GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP with issue list present and the following issue codes:
                 	// billingDetailsIssuerIdRejected, billingDetailsContextIdRejected, billingDetailsUserIdRejected, billingDetailsPeriodRejected, billingDetailsAmountRejected, billingDetailsContextNameRejected, billingDetailsAppliedUserClassRejected, billingDetailsDeclaredVehicleClassRejected, billingDetailsAppliedTimeClassRejected, billingDetailsEntranceTimeRejected, billingDetailsIntermediateSectionRejected, billingDetailsExitChargeObjectRejected, billingDetailsExitTimeRejected
				// Set timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);                 
  				
				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {
							m_nackParams(1,AduReasonCode_billingDetailsIssuerIdRejected_),
							m_nackParams(2,AduReasonCode_billingDetailsContextIdRejected_),
							m_nackParams(3,AduReasonCode_billingDetailsUserIdRejected_), 
							m_nackParams(4,AduReasonCode_billingDetailsAmountRejected_), 
							m_nackParams(5,AduReasonCode_billingDetailsContextNameRejected_), 
							m_nackParams(6,AduReasonCode_billingDetailsAppliedUserClassRejected_), 
							m_nackParams(7,AduReasonCode_billingDetailsDeclaredVehicleClassRejected_), 
							m_nackParams(8,AduReasonCode_billingDetailsAppliedTimeClassRejected_), 
							m_nackParams(9,AduReasonCode_billingDetailsEntranceTimeRejected_), 
							m_nackParams(10,AduReasonCode_billingDetailsIntermediateSectionRejected_) 					  
						})) -> value v_apduReceived {
							// Log what we received, check minimum time and stop time
							f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
							setverdict(pass);
					}
				} // End of Alt statement
				f_closeDownMtc();  			                               
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02: Verify that the TC correctly responds
                * 			when the TSP provides a single BillingDetailsADU with only mandatory fields,
                *			then issues a second BillingDetailsADU too early
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and IS_GNSS_BILLINGDETAILS_TSP_TIMEA_MIN_TC > 0.0;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
                
				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};
				var TollDeclarationId c_refTollDeclaration2 := {TD_IDENTIFIER, 2};
				 	
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration2,
						c_usageStatement_2,
						2,
						ActionCode_send_)
					}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send valid Initiating_Apdu containing exactly one BillingDetailsADUs with
                //		- all mandatory fields, and
                //		- no optional fields,
                //		- one tollDeclaration reference to first toll declaration in previouse TollDeclarationADU

				// prepare this adu below
				var UsageList v_usageListSectionedRoads :=m_sectionedRoadGnssUsageList;
				v_usageListSectionedRoads.includedDiscounts:=omit;
				
				var BillingDetailsADU v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1,
					TD_PERIOD_1,
					{v_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_1,
					{c_refTollDeclaration1},
					ActionCode_send_
					);
																
				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsSectionedRoads}});	

                // No wait time for sending the Initiating_Apdu

				f_sendAndLogApdu(v_apduForSending);                	 	 	
								
                // Step 2:
                // Send valid Initiating_Apdu containing exactly one BillingDetailsADUs with
                //		- all mandatory fields, and
                //		- no optional fields,
                //		- one tollDeclaration reference to first toll declaration in previouse TollDeclarationADU

				// prepare this adu below
				v_usageListSectionedRoads :=m_sectionedRoadGnssUsageList;
				v_usageListSectionedRoads.includedDiscounts:=omit;
				
				v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1,
					TD_PERIOD_1,
					{v_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_2,
					{c_refTollDeclaration2},
					ActionCode_send_
					);
																
				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsSectionedRoads}});	

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2:
                // Wait for NAck_requestSentTooOften(10) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck_requestSentTooOften(10)
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}
				}
				f_closeDownMtc();              	               
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03: Verify that the TC correctly responds
                *			when the TSP sends too many BillingDetailsADUs
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
				//Declaration
				var Adus v_adusTollDeclaration, v_adusBillingDetails;
				 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 
                
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	

				// Step 1:
				// Perform one GNSS_TOLLDECLARATION transaction
				// with 1+IS_GNSS_BILLINGDETAILS_TSP_PARAM1_MAX_TC TollDeclaration ADUs with positive Ack

                // Prepare APDU with 1+IS_GNSS_BILLINGDETAILS_TSP_PARAM1_MAX_TC TollDeclaration ADUs                
                 
                for (var integer v_i := 1; v_i == 1+IS_GNSS_BILLINGDETAILS_TSP_PARAM1_MAX_TC; v_i := v_i + 1) {
					v_adusTollDeclaration.tollDeclarationADUs[v_i]:=m_aduTollDeclarationToSendOneObe(
                    	{TD_IDENTIFIER, v_i}, //tollDeclarationId
                    	c_usageStatement_1, // usageStatement (always the same)
                    	v_i, // chargeReportCounter
                    	ActionCode_send_ // actionCode
					);
                }
                
                v_apduForSending:=m_apduNoAuthInitTester(v_adusTollDeclaration);

                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
    
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
                    }
                }	

                // Step 3:
                // Send valid Initiating_Apdu containing 1+IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC BillingDetailsADU, with
                //		- the values corresponding the previous TollDeclarationADUs; and
                //		- actionCode=send
    
               	// Prepare APDU with 1+IS_GNSS_TOLLDECLARATIONS_PARAM1_MAX_TC BillingDetails ADUs 
           	
               	for (var integer v_i := 1; v_i == 1+IS_GNSS_TOLLDECLARATIONS_PARAM1_MAX_TC; v_i := v_i + 1) {
					v_adusBillingDetails.billingDetailsADUs[v_i]:=m_aduGnssBillingDetails (
                        v_i,
                        TD_USERID_1,
                        TD_PERIOD_1,
                        {m_sectionedRoadGnssUsageList},
                        TD_BILLINGDETAILS_AMOUNT_1,
                        {{TD_IDENTIFIER, v_i}},
                        ActionCode_send_
                    );	
               	};	
				v_apduForSending := m_apduNoAuthInitTester(v_adusBillingDetails);
				                   
                // respect time restriction TIMEA_MIN set by the IuT
                f_waitTimeA(IS_GNSS_BILLINGDETAILS_TSP_TIMEA_MIN_TC);
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
                    
                // Step 4:
                // Wait for NAck containing issueCode = NAck_Apdu with APDU ReasonCode apduNotOK(3)
                // within GNSS.BILLINGDETAILS.TSP.TIME1
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
                    }
                }	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04: Verify that the TC correctly reponds
                *			when the TSP adjusts billing details that do not exist at IUT side
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */

				// Initialitastion 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_1_implementedSectionedRoads;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send invalid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send
				//		- Toll Declaration reference which does not correspond to the last Toll Declaration

				// prepare this adu below
				var UsageList v_usageListSectionedRoads :=m_sectionedRoadGnssUsageList;
				v_usageListSectionedRoads.includedDiscounts:=omit;
				
				var BillingDetailsADU v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_2, // user ID does not match the user Id in the corresponding toll declaratiuon
					TD_PERIOD_1,
					{v_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_1,
					{c_refTollDeclaration1},
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsSectionedRoads}});	

                // No wait time for sending the Initiating_Apdu

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2: Wait for negative Ack_Apdu with AduReason code
                //		- NAck_Apdu with aduReasonCode = billingDetailsUserIdRejected (704) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = billingDetailsUserIdRejected (704) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep
                // within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_billingDetailsUserIdRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_billingDetailsUserIdRejected_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}										
				}	

                // Step 3:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = adjust, and
				//		- no optional fields, and
                //		- billingDetailsNum referencing a billing details that does not exist at the IUT side
                  
				// prepare this adu below
				
				var BillingDetailsADU v_aduGnssBillingDetailsCordonCrossing := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_2,
					TD_USERID_1,
					TD_PERIOD_1,
					{m_cordonCrossingGnssUsageList},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{c_refTollDeclaration1},
					ActionCode_adjust_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsCordonCrossing}});	

                // Send Initiating_Apdu containing BillingDetailsADU
                // after IS_GNSS_BILLINGDETAILS_TIMEA_MIN_TC has passed
                // i.e. the tester respects time limits declared by the IuT 
				f_waitTimeA(IS_GNSS_BILLINGDETAILS_TIMEA_MIN_TC);

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				

                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_semanticError_))) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}								
				}			 
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05: Verify that the TC correctly reponds
                *			when the TSP tries to revoke billing details that do not exist at TC side
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */

				// Initialitastion 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A56_1_implementedSectionedRoads;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
				var TollDeclarationId c_refTollDeclaration1 := {TD_IDENTIFIER, 1};

				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						c_refTollDeclaration1,
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 1:
                // Send invalid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send

				// prepare this adu below
				var UsageList v_usageListSectionedRoads := m_sectionedRoadGnssUsageList; 
				v_usageListSectionedRoads.includedDiscounts:=omit;
				
				var BillingDetailsADU v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_1,
					TD_USERID_1,
					TD_PERIOD_1,
					{v_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{c_refTollDeclaration1},
					ActionCode_send_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsSectionedRoads}});	

                // No wait time for sending the Initiating_Apdu

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	

                // Step 3:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = revoke, and
				//		- no optional fields, and
				//		- billingDetailsNum that does not exist in the previously received BillingDetailsADU
                  
				// prepare this adu below
				v_aduGnssBillingDetailsSectionedRoads := m_aduGnssBillingDetails (
					TD_BILLING_DETAILS_NUM_2,
					TD_USERID_1, // now with correct user ID
					TD_PERIOD_1,
					{v_usageListSectionedRoads},
					TD_BILLINGDETAILS_AMOUNT_1, 
					{c_refTollDeclaration1},
					ActionCode_revoke_
					);

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={v_aduGnssBillingDetailsSectionedRoads}});	

                // Send Initiating_Apdu containing BillingDetailsADU
                // after IS_GNSS_BILLINGDETAILS_TIMEA_MIN_TC has passed
                // i.e. the tester respects time limits declared by the IuT 
				f_waitTimeA(IS_GNSS_BILLINGDETAILS_TIMEA_MIN_TC);

				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				

                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_semanticError_))) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}								
				}			 
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05

		} // End Invalid_Behaviour
		
	} // End GNSS_BILLINGDETAILS_TSP

	group GNSS_BILLINGDETAILS_TC {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_01: Verify that the TC correctly performs a GNSS.BILLINGDETAILS.TC transaction
                *			with BillingDetailsADUs containing all permutations of present and
                *			not present optional fields that vary in the IUT implementation, all with actionCode=send
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_2_implementedGNSSBILLINGDETAILSTC;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed

				// Step 1:
				// Perform a full GNSS.TOLLDECLARATION transaction with five(5) tollDeclarations
				// receive positive Ack
				// wait respective time constraints until next transaction 	
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_1,
						1,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						c_usageStatement_2,
						2,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3},
						c_usageStatement_3,
						3,
						ActionCode_send_),							
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4},
						c_usageStatement_4,
						4,
						ActionCode_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5},
						c_usageStatement_5,
						5,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	
								
                // Step 2:
                // Trigger IUT with GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND to send BillingDetailsADUs containing
                //		- all valid permutations of present and not present optional fields and choices that are used in the IUT implementation
                //		- and correspond to the toll declarations sent by the Tester

				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);
				
				var template InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut(
					{billingDetailsADUs:={modifies mw_aduGnssBillingDetails:= {
				  		refTollDeclaration := {
				  			{TD_IDENTIFIER, 1},
				  			{TD_IDENTIFIER, 2},
				  			{TD_IDENTIFIER, 3},
				  			{TD_IDENTIFIER, 4},
				  			{TD_IDENTIFIER, 5}
				  		},
				  		actionCode := ActionCode_send_
				  	}}}
				);                 
				
                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					              		
						// Step 3: Send Ack within time constraints
						f_wait(IS_GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_02: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TC transaction when it sends a single BillingDetailsADU
                *			with actionCode = adjust and no optional fields
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_2_implementedGNSSBILLINGDETAILSTC;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed

				// Step 1:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				// wait respective time constraints until next transaction 	
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 2: Trigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_SEND to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send
                
                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);

				var template InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut({billingDetailsADUs:={
					modifies mw_aduGnssBillingDetails:= {
				  		refTollDeclaration := {{TD_IDENTIFIER, 1}},
				  		actionCode := ActionCode_send_
					}
				}});                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no time check
						f_logApduReceivedAndTStep();					              		
					}
				}

				// capture the billingDetailsId for validation in step 3
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[0].billingDetailsId;

				// Step 3: Send NAck (except of issueCode "acceptedWithWarning") within time constraints
				f_wait(IS_GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
				f_sendAndLogApdu(m_apduNAckIndividualIssuesTester(v_apduReceived, m_roNackParamsSingle(1, AduReasonCode_semanticError_)));

                // Step 4: Tigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_ADJUST to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = adjust the same BillingDetailsId from Step 2

                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_ADJUST);

                // Wait for IUT to send adjusted BillingDetailsADU
                // with actionCode = adjust
                // with same billingDetailsId as already received billingDetailsId
				v_apduToBeReceived := mw_apduNoAuthInitIut(
					{billingDetailsADUs:={modifies mw_aduGnssBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_adjust_
				  	}}}
				);                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);					              		
						// Send Ack within time constraints
						f_wait(IS_GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_03: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TC transaction when it sends a single BillingDetailsADU
                *			with actionCode = revoke and no optional fields
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_2_implementedGNSSBILLINGDETAILSTC;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed

				// Step 1:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				// wait respective time constraints until next transaction 	
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						c_usageStatement_1,
						1,
						ActionCode_send_)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 2: Tigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_SEND to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send
                
                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);

				var template InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut({billingDetailsADUs:={
					modifies mw_aduGnssBillingDetails:= {
				  		refTollDeclaration := {{TD_IDENTIFIER, 1}},
				  		actionCode := ActionCode_send_
					}
				}});                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no time check
						f_logApduReceivedAndTStep();					              		
					}
				}

				// capture the billingDetailsId for validation in step 3
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs[0].billingDetailsId;

				// Step 3: Send Ack within time constraints
				f_wait(IS_GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
				f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));

                // Step 4: Tigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_REVKE to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = revoke the same BillingDetailsId from Step 2

                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_ADJUST);

                // Wait for IUT to revke BillingDetailsADU
                // with actionCode = revoke
                // with same billingDetailsId as already received billingDetailsId
				v_apduToBeReceived := mw_apduNoAuthInitIut({billingDetailsADUs:={modifies mw_aduGnssBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_revoke_
				  	}
				  }});                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, no time check
						f_logApduReceivedAndTStep();					              		
						// Send Ack within time constraints
						f_wait(IS_GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_03			
		} // End Valid_Behaviour

		group Invalid_Behaviour {

               /**
                 * @remark  No TPs have been defined
                 */			
			
		} // End group Invalid_Behaviour		
		
	} // End group GNSS_BILLINGDETAILS_TC
	
	group GNSS_PAYMENTANNOUNCEMENT {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01: Verify that the TC correctly performs
                *			a GNSS.PAYMENTANNOUNCEMENT transaction
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with five(5) tollDeclarations
				
				// Prepare APDU with five(5) TollDeclaration ADUs 
				
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1}, //tollDeclarationId
						c_usageStatement_1, // usageStatement
						1, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2}, //tollDeclarationId
						c_usageStatement_2, // usageStatement
						2, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3}, //tollDeclarationId
						c_usageStatement_3, // usageStatement
						3, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4}, //tollDeclarationId
						c_usageStatement_4, // usageStatement
						4, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5}, //tollDeclarationId
						c_usageStatement_5, // usageStatement
						5, // chargeReportCounter
						ActionCode_send_ // actionCode
					)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

				// Step 3:
                // Send valid Initiating_Apdu containing five(5) BillingDetailsADU, with
				//		- the values corresponding the previous TollDeclarationADUs; and
				//		- actionCode=send

				v_apduForSending := m_apduNoAuthInitTester(
					{billingDetailsADUs:={
					  	m_aduGnssBillingDetails (
					  		1,
					  		TD_USERID_1,
					  		TD_PERIOD_1,
					  		{m_sectionedRoadGnssUsageList},
					  		TD_BILLINGDETAILS_AMOUNT_1,
					  		{{TD_IDENTIFIER, 1}},
					  		ActionCode_send_
					  	),
					  	m_aduGnssBillingDetails (
					  		2,
					  		TD_USERID_2,
					  		TD_PERIOD_1,
					  		{m_sectionedRoadGnssUsageList},
					  		TD_BILLINGDETAILS_AMOUNT_2,
					  		{{TD_IDENTIFIER, 2}},
					  		ActionCode_send_
					  	),
					  	m_aduGnssBillingDetails (
					  		3,
					  		TD_USERID_3,
					  		TD_PERIOD_1,
					  		{m_sectionedRoadGnssUsageList},
					  		TD_BILLINGDETAILS_AMOUNT_3,
							{{TD_IDENTIFIER, 3}},
					  		ActionCode_send_
					  	),
					  	m_aduGnssBillingDetails (
					  		4,
					  		TD_USERID_4,
					  		TD_PERIOD_1,
					  		{m_sectionedRoadGnssUsageList},
					  		TD_BILLINGDETAILS_AMOUNT_4,
							{{TD_IDENTIFIER, 4}},
					  		ActionCode_send_
					  	),
					  	m_aduGnssBillingDetails (
					  		5,
					  		TD_USERID_5,
					  		TD_PERIOD_1,
					  		{m_sectionedRoadGnssUsageList},
					  		TD_BILLINGDETAILS_AMOUNT_5,
							{{TD_IDENTIFIER, 5}},
					  		ActionCode_send_
					  	)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_BILLINGDETAILS_TSP_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	

				// Step 5:
                // Send valid Initiating_Apdu containing three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous five(5) BillingDetailsADUs; and
				//		- actionCode=send

				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 21}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 2},{TD_IDENTIFIER, 3},{TD_IDENTIFIER, 4}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_3,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						{{TD_IDENTIFIER, 5}},
						ActionCode_send_
					)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for Default_Ack_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_02: Verify that the TC correctly performs
                *			a GNSS.PAYMENTANNOUNCEMENT transaction with actionCode=adjust
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with five(5) tollDeclarations
				
				// Prepare APDU with five(5) TollDeclaration ADUs 
				
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1}, //tollDeclarationId
						c_usageStatement_1, // usageStatement
						1, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2}, //tollDeclarationId
						c_usageStatement_2, // usageStatement
						2, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3}, //tollDeclarationId
						c_usageStatement_3, // usageStatement
						3, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4}, //tollDeclarationId
						c_usageStatement_4, // usageStatement
						4, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5}, //tollDeclarationId
						c_usageStatement_5, // usageStatement
						5, // chargeReportCounter
						ActionCode_send_ // actionCode
					)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

				// Step 3:
                // Send valid Initiating_Apdu containing five(5) BillingDetailsADU, with
				//		- the values corresponding the previous TollDeclarationADUs; and
				//		- actionCode=send

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={
				  	m_aduGnssBillingDetails (
				  		1,
				  		TD_USERID_1,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_1,
				  		{{TD_IDENTIFIER, 1}},
				  		ActionCode_send_
				  	),
				  	m_aduGnssBillingDetails (
				  		2,
				  		TD_USERID_2,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_2,
				  		{{TD_IDENTIFIER, 2}},
				  		ActionCode_send_
				  	),
				  	m_aduGnssBillingDetails (
				  		3,
				  		TD_USERID_3,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_3,
				  		{{TD_IDENTIFIER, 3}},
				  		ActionCode_send_
				  	),
				  	m_aduGnssBillingDetails (
				  		4,
				  		TD_USERID_4,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_4,
				  		{{TD_IDENTIFIER, 4}},
				  		ActionCode_send_
				  	),
				  	m_aduGnssBillingDetails (
				  		5,
				  		TD_USERID_5,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_5,
				  		{{TD_IDENTIFIER, 5}},
				  		ActionCode_send_
				  	)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_BILLINGDETAILS_TSP_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	

				// Step 5:
                // Send valid Initiating_Apdu containing three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous five(5) BillingDetailsADUs; and
				//		- actionCode=send
				// 		- which shall be negatively acknowledge by the IuT
				//		This is achieved by referencing to billingDetailsIDs not reported to the IuT  

				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 21}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 22},{TD_IDENTIFIER, 23},{TD_IDENTIFIER, 24}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_3,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						{{TD_IDENTIFIER, 25}},
						ActionCode_send_
					)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for Negative_Ack_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {
						m_nackParams(1, AduReasonCode_semanticError_),
						m_nackParams(2, AduReasonCode_semanticError_),
						m_nackParams(3, AduReasonCode_semanticError_)})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
				}

				// Step 7:
                // Adjust the previously send three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous three(3) PaymentAnnoucments; and
				//		- actionCode=adjust

				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 1}},
						ActionCode_adjust_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 2},{TD_IDENTIFIER, 3},{TD_IDENTIFIER, 4}},
						ActionCode_adjust_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_3,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						{{TD_IDENTIFIER, 5}},
						ActionCode_adjust_
					)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 8: Wait for Default_Ack_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_02


			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_03: Verify that the TC correctly performs
                *			a GNSS.PAYMENTANNOUNCEMENT transaction with actionCode=revoke
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 0:
				// Perform a full GNSS.TOLLDECLARATION transaction with five(5) tollDeclarations
				
				// Prepare APDU with five(5) TollDeclaration ADUs 
				
				v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1}, //tollDeclarationId
						c_usageStatement_1, // usageStatement
						1, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2}, //tollDeclarationId
						c_usageStatement_2, // usageStatement
						2, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3}, //tollDeclarationId
						c_usageStatement_3, // usageStatement
						3, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4}, //tollDeclarationId
						c_usageStatement_4, // usageStatement
						4, // chargeReportCounter
						ActionCode_send_ // actionCode
					),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5}, //tollDeclarationId
						c_usageStatement_5, // usageStatement
						5, // chargeReportCounter
						ActionCode_send_ // actionCode
					)
				}});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

				// Step 3:
                // Send valid Initiating_Apdu containing five(5) BillingDetailsADU, with
				//		- the values corresponding the previous TollDeclarationADUs; and
				//		- actionCode=send

				v_apduForSending := m_apduNoAuthInitTester({billingDetailsADUs:={
				  	m_aduGnssBillingDetails (
				  		1,
				  		TD_USERID_1,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_1,
				  		{{TD_IDENTIFIER, 1}},
				  		ActionCode_send_
				  	),
				  	m_aduGnssBillingDetails (
				  		2,
				  		TD_USERID_2,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_2,
				  		{{TD_IDENTIFIER, 2}},
				  		ActionCode_send_
				  	),
				  	m_aduGnssBillingDetails (
				  		3,
				  		TD_USERID_3,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_3,
				  		{{TD_IDENTIFIER, 3}},
				  		ActionCode_send_
				  	),
				  	m_aduGnssBillingDetails (
				  		4,
				  		TD_USERID_4,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_4,
				  		{{TD_IDENTIFIER, 4}},
				  		ActionCode_send_
				  	),
				  	m_aduGnssBillingDetails (
				  		5,
				  		TD_USERID_5,
				  		TD_PERIOD_1,
				  		{m_sectionedRoadGnssUsageList},
				  		TD_BILLINGDETAILS_AMOUNT_5,
				  		{{TD_IDENTIFIER, 5}},
				  		ActionCode_send_
				  	)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_BILLINGDETAILS_TSP_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
				
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
					}
				}	

				// Step 5:
                // Send valid Initiating_Apdu containing three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous five(5) BillingDetailsADUs; and
				//		- actionCode=send

				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 21}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 2},{TD_IDENTIFIER, 3},{TD_IDENTIFIER, 4}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_3,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						{{TD_IDENTIFIER, 5}},
						ActionCode_send_
					)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for DefaultAck_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
				}

				// Step 7:
                // Revoke the previously send three(3) PaymentAnnouncementADUs, with
				//		- the values referencing the previous three(3) PaymentAnnoucments; and
				//		- actionCode=revoke

				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 21}},
						ActionCode_revoke_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 2},{TD_IDENTIFIER, 3},{TD_IDENTIFIER, 4}},
						ActionCode_revoke_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_3,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_3,
						{{TD_IDENTIFIER, 5}},
						ActionCode_revoke_
					)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 8: Wait for Default_Ack_Apdu within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set test result
						setverdict(pass);
					}
				}	
				f_closeDownMtc();              	                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_03
			
		} // End Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU with an incorrect actionCode
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Perform one GNSS_TOLLDECLARATION transaction with two TollDeclaration ADUs with positive Ack
				// and perform one GNSS_BILLINGDETAILS transaction with two BillingDetails ADUs
				// and actionCode = send and with positive Ack	
				f_sendTwoTollDeclarationAdusAndTwoBillingDetailsAdus ();
				
				// Perform one PaymentAnnouncement transaction with two PaymentAnnouncemnet ADUs
				// with actionCode = send and with positive Ack
				f_sendTwoPaymentAnnouncementAdus();
				
                // Step 5:
                // Send Initiating_Apdu containing 
				//		- exactly one PaymentAnnouncementADU with actionCode=credit, and
				//		- exactly one PaymentAnnouncementADU with actionCode=resend
				//		- both referencing to paymentAnnouncementIds previousely sent
 
				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 1}},
						ActionCode_credit_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 2}},
						ActionCode_resend_
					)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_actionCodeNotSupported_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(
						v_apduForSending, 
						m_roNackParamsDouble(1, AduReasonCode_actionCodeNotSupported_,2, AduReasonCode_actionCodeNotSupported_)
					)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU with incorrect paymentAnnouncementID 
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Perform one GNSS_TOLLDECLARATION transaction with two TollDeclaration ADUs with positive Ack
				// and perform one GNSS_BILLINGDETAILS transaction with two BillingDetails ADUs
				// and actionCode = send and with positive Ack	
				f_sendTwoTollDeclarationAdusAndTwoBillingDetailsAdus ();
				
				// Perform one PaymentAnnouncement transaction with two PaymentAnnouncemnet ADUs
				// with actionCode = send and with positive Ack
				f_sendTwoPaymentAnnouncementAdus();
				
                // Step 5:
                // Send Initiating_Apdu containing 
				// 		- exactly one PaymentAnnouncementADU with actionCode=send containing
				//			paymentAnnouncementId = value that has previously been used, and
				//		- exactly one PaymentAnnouncementADU with actionCode=revoke containing
				//			paymentAnnouncementId = value that has not previously been used

				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 1}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_NON_EXISTING,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 2}},
						ActionCode_revoke_
					)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) for the entire APDU
                // or invalidADU (0) for ADU#2 only,
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(
						v_apduForSending, m_roNackParamsSingle(2, AduReasonCode_invalidADU_)
					)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02


			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03: Verify that the TC correctly responds
                *			to PaymentAnnouncementADUs where details from referenceDetailsList are not present
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Perform one GNSS_TOLLDECLARATION transaction with two TollDeclaration ADUs with positive Ack
				// and perform one GNSS_BILLINGDETAILS transaction with two BillingDetails ADUs
				// and actionCode = send and with positive Ack	
				f_sendTwoTollDeclarationAdusAndTwoBillingDetailsAdus ();
				
				// Perform one PaymentAnnouncement transaction with two PaymentAnnouncemnet ADUs
				// with actionCode = send and with positive Ack
				f_sendTwoPaymentAnnouncementAdus();
				
                // Step 5:
                // Send Initiating_Apdu containing
                //		- exactly one valid PaymentAnnouncementADU, and
                //		- exactly one PaymentAnnouncementADU with actionCode=send containing
				//			- referenceDetailsList of the choice billingDetailsList containing
				//				- exactly one BillingDetailsId that does not make reference
				//					to the BillingDetailsADU of the previously performed BILLINGDETAILS transaction
 
				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 1}},
						ActionCode_send_
					),
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 31}},
						ActionCode_send_
					)
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) for ADU#2,
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(2, AduReasonCode_invalidADU_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03
								

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU where the length of the referenceDetailsList is too long
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
 				// Initialisation
				var Adus v_adusTollDeclaration;
 				var Adus v_adusBillingDetails;
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 1:
				// Perform one GNSS_TOLLDECLARATION transaction
				// with 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX TollDeclaration ADUs with positive Ack

                // Prepare APDU with 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX TollDeclaration ADUs                
                 
                for (var integer v_i := 1; v_i == 2+IS_GNSS_PAYMENTANNOUNCEMENT_PARAM2_MAX_TC; v_i := v_i + 1) {
					v_adusTollDeclaration.tollDeclarationADUs[v_i]:=m_aduTollDeclarationToSendOneObe(
                    	{TD_IDENTIFIER, v_i}, //tollDeclarationId
                    	c_usageStatement_1, // usageStatement (always the same)
                    	v_i, // chargeReportCounter
                    	ActionCode_send_ // actionCode
					);
                }
                
                v_apduForSending:=m_apduNoAuthInitTester(v_adusTollDeclaration);
                                                                                                                                                                            
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
    
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
                    }
                }	
    
                // Step 3:
                // Send valid Initiating_Apdu containing 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX BillingDetailsADU, with
                //		- the values corresponding the previous TollDeclarationADUs; and
                //		- actionCode=send
    
    
               	// Prepare APDU with 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX BillingDetails ADUs 
           	
               	for (var integer v_i := 1; v_i == 2+IS_GNSS_PAYMENTANNOUNCEMENT_PARAM2_MAX_TC; v_i := v_i + 1) {
					v_adusBillingDetails.billingDetailsADUs[v_i]:=m_aduGnssBillingDetails (
                        v_i,
                        TD_USERID_1,
                        TD_PERIOD_1,
                        {m_sectionedRoadGnssUsageList},
                        TD_BILLINGDETAILS_AMOUNT_1,
                        {{TD_IDENTIFIER, v_i}},
                        ActionCode_send_
                    );	
               	};	
				v_apduForSending := m_apduNoAuthInitTester(v_adusBillingDetails);
				                   
                // respect time restriction TIMEA_MIN set by the IuT
                f_waitTimeA(IS_GNSS_BILLINGDETAILS_TSP_TIMEA_MIN_TC);
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
                    
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
                    }
                }	
								
                // Step 5:
                // Send Initiating_Apdu containing
                //		- one valid PaymentAnnouncementADU with a reference to exactly one(1) BillingDetailsId, and
                //		- one PaymentAnnouncementADU with actionCode=send containing
                //			- referenceDetailsList of the choice billingDetailsList containing
                //				- exactly (1+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX) BillingDetailsId that makes reference to
                //					the BillingDetailsADUs of the previously performed BILLINGDETAILS transaction                  
 
				// Prepare ReferenceDetailsList with total of 2+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX references
				// for both ADUs
               	var ReferenceDetailsList v_referenceDetailsList;

				for (var integer v_i := 1; v_i == 2+IS_GNSS_PAYMENTANNOUNCEMENT_PARAM2_MAX_TC; v_i := v_i + 1) {
					v_referenceDetailsList[v_i] := {
						referenceDetail:={billingDetailsList := {{TD_IDENTIFIER, v_i}}},
						amount := TD_BILLINGDETAILS_AMOUNT_1, 
						paymentMeansType := omit,
						valueDate := omit,
						interestAmount := omit
					};
				};
               	
				var PaymentAnnouncementADU v_aduPaymentAnnouncementInvalid:= m_aduPaymentAnnouncement(
					TD_PAYMENTANNOUNCEMENT_ID_2,
					TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
					{v_referenceDetailsList[0].referenceDetail.billingDetailsList[0]}, //dummy value, to be reset below
					ActionCode_send_
				);
				
				v_aduPaymentAnnouncementInvalid.numberOfItems := 1+IS_GNSS_PAYMENTANNOUNCEMENT_PARAM2_MAX_TC;
				v_aduPaymentAnnouncementInvalid.referenceDetailsList:=v_referenceDetailsList[2 .. (2+IS_GNSS_PAYMENTANNOUNCEMENT_PARAM2_MAX_TC)];
				
				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{v_referenceDetailsList[0].referenceDetail.billingDetailsList[0]},
						ActionCode_send_
					),
					v_aduPaymentAnnouncementInvalid
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) for ADU#2,
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail (in altstep)

				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(2, AduReasonCode_invalidADU_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}                               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU where the attachement is too big
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Perform one GNSS_TOLLDECLARATION transaction with two TollDeclaration ADUs with positive Ack
				// and perform one GNSS_BILLINGDETAILS transaction with two BillingDetails ADUs
				// and actionCode = send and with positive Ack	
				f_sendTwoTollDeclarationAdusAndTwoBillingDetailsAdus ();
				
				// Perform one PaymentAnnouncement transaction with two PaymentAnnouncemnet ADUs
				// with actionCode = send and with positive Ack
				f_sendTwoPaymentAnnouncementAdus();
				
                // Step 5:
                // Send Initiating_Apdu containing
                //		- one valid PaymentAnnouncementADU, and
                //		- one PaymentAnnouncementADU with actionCode=send containing an attachment larger than (2^31)-1 kbytes
 
 				var octetstring v_attachment;//length 2^31
 				
 				for (var integer v_i:=0; v_i <= 268435456; v_i := v_i + 1) {
 					v_attachment := v_attachment & '0123456789ABCDEF'O;
 				}

				v_apduForSending := m_apduNoAuthInitTester({paymentAnnouncementADUs:={
					m_aduPaymentAnnouncement(
						TD_PAYMENTANNOUNCEMENT_ID_1,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, 1}},
						ActionCode_send_
					),
					mw_aduPaymentAnnouncementWAttachment(				  	
						TD_PAYMENTANNOUNCEMENT_ID_2,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_2,
						{{TD_IDENTIFIER, 2}},
						ActionCode_send_,
						v_attachment
					)					
				}});
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
				
                // Step 6: Wait for NAck_Apdu with ADUReasonCode invalidADU (0) for ADU#2,
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(2, AduReasonCode_invalidADU_))) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05

								
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06: Verify that the TC correctly responds to
                *			an APDU containing too many PaymentAnnouncementADUs
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.52/4
                */
 
 				//Declaration
 				var Adus v_adus;
 				
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP
 					and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase shall run, activate altsteps on ports, etc 

				// Step 1:
				// Perform one GNSS_TOLLDECLARATION transaction
				// with 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX TollDeclaration ADUs with positive Ack

                // Prepare APDU with 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX TollDeclaration ADUs                
                 
                
                for (var integer v_i := 1; v_i == 1+IS_GNSS_PAYMENTANNOUNCEMENT_PARAM1_MAX_TC; v_i := v_i + 1) {
                	v_apduForSending := m_apduNoAuthInitTester({tollDeclarationADUs:={
                    	m_aduTollDeclarationToSendOneObe(
                        	{TD_IDENTIFIER, v_i}, //tollDeclarationId
                        	c_usageStatement_1, // usageStatement (always the same)
                        	v_i, // chargeReportCounter
                        	ActionCode_send_ // actionCode
						)
                	}});
                }
                                                                                                                                                                            
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
    
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(IS_GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
                    }
                }	
    
                // Step 3:
                // Send valid Initiating_Apdu containing 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX BillingDetailsADU, with
                //		- the values corresponding the previous TollDeclarationADUs; and
                //		- actionCode=send
    
               	// Prepare APDU with 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX BillingDetails ADUs              	
                                 	
               	for (var integer v_i := 1; v_i == 1+IS_GNSS_PAYMENTANNOUNCEMENT_PARAM1_MAX_TC; v_i := v_i + 1) {
                	v_adus.billingDetailsADUs[v_i]:=m_aduGnssBillingDetails(
                        v_i,
                        TD_USERID_1,
                        TD_PERIOD_1,
                        {m_sectionedRoadGnssUsageList},
                        TD_BILLINGDETAILS_AMOUNT_1,
                        {{TD_IDENTIFIER, v_i}},
                        ActionCode_send_
                    );
                };		
                
				v_apduForSending := m_apduNoAuthInitTester(v_adus);
                
                // respect time restriction TIMEA_MIN set by the IuT
                f_waitTimeA(IS_GNSS_BILLINGDETAILS_TSP_TIMEA_MIN_TC);
                f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MAX_TC);   				
                    
                // Step 4:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS_TSP.TIME1             
                // if not received or received outside specification or time constraints set test fail
    
                alt {				
                    [] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
                        // Log what we received, check minimum time and stop time
                        f_logReceivedThenCheckAndStopTime(IS_GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TC);
                    }
                }	
								
                // Step 5:
                // Send Initiating_Apdu containing
                //		- 1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX valid PaymentAnnouncementADU
				                	
               	for (var integer v_i := 1; v_i == 1+IS_GNSS_PAYMENTANNOUNCEMENT_PARAM1_MAX_TC; v_i := v_i + 1) {               		              	             					  
					v_adus.paymentAnnouncementADUs[v_i]:=m_aduPaymentAnnouncement(
						v_i,
						TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_1,
						{{TD_IDENTIFIER, v_i}},
						ActionCode_send_
					);
				};
				
				v_apduForSending := m_apduNoAuthInitTester(v_adus);
				
				// respect time restriction TIMEA_MIN set by the IuT
				f_waitTimeA(IS_GNSS_PAYMENTANNOUNCEMENT_TIMEA_MIN_TC);
				f_sendAndLogApdu(v_apduForSending);                	 	 	
                // Start timer
                t_step.start(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TC);   				
 				
                // Step 6: Wait for NAck_Apdu with APDU ReasonCode apduNotOK(3),
                // within GNSS.PAYMENTANNOUNCEMENT.TIME1             
                // if not received or received outside specification or time constraints set test fail (in altstep)
 
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(IS_GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TC);
						// set result
						setverdict(pass);
					}
				}                               
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06			
		} // End group Invalid_Behaviour
		
	} // End group GNSS_PAYMENTANNOUNCEMENT	
	                		
} // End of module EfcInfoExchange_TestCasesTc

