 /**
 * @author  PT0140 
 * @desc    This module provides test cases for TPs specified in Annex A of CEN/TC 17154-1 (i.e. Toll Charger system is IUT)
 * @see     [17154-1:2017]: Test suite structure and test purpose
 * @see     [17154-1:2017], Clause 5.3.2 for TP namimg conventions
 * @version $id$
 */
 
 
 /**
 * work in progress Status overview
 *
 *	Transaction type			!	BV					! BI			! Comments
 * 	----------------------------!-----------------------!---------------!--------------------------------
 *	Base						! open					! open			! in progress
 *	Userdetails					! open					! open			! available but to be reworked
 *	ListOfUsers					! open					! open			! in progress
 *	ExceptionList				! done					! done			! revised and ready for compile
 *	TrustObjects				! done					! done			! revised and ready for compile
 *	PaymentClaim				! open					! n.a.			! in progress
 *	DSRC.ContractIssuerList		! done					! done			! revised and ready for compile
 *	DSRC.EFCContextData			! done					! n.a.			! revised and ready for compile 
 *	DSRC.BillingDetails			! done					! n.a.			! revised and ready for compile
 *	DSRC.ReportAbnormalOBE		! done					! n.a.			! revised and ready for compile
 *	GNSS.TollDeclaration		! open					! open			! done but need to revise List of ChargeReports in template
 *	GNSS.BillingDetails.TSP		! open					! open			! in progress
 *	GNSS.BillingDetails.TC		! done					! n.a.			! ready for compile
 *	GNSS.PaymentAnnouncement	! open					! open			! in progress
 */
 
module EfcInfoExchange_TestCasesTc {
	import from EfcInfoExchange_ParameterisedAsn1Data all;

    /**
     * @desc    [12855:2015]: 
     * @see     Annex A (normative)  data type specifications
     * @remark	TODO PT140 to be updated / completed
     */ 
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     * @remark	Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
     */
    import from LibEfc_Common_Parameterised_Asn1_Data all;
    import from EfcInfoExchange_Interfaces all;
    import from EfcInfoExchange_Functions all;
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Ics all;
    import from EfcInfoExchange_Templates all;
	import from EfcInfoExchange_InteroperabilityStatement all;
	import from EfcInfoExchange_TesterData all;
	import from EfcInfoExchangeProfile all;
		
     /**
      * @desc    These test cases apply to Toll Charger claiming conformance to [16986:2016]
      * and applying Test Purposes as from CEN/TS17154-1:xxxx Annex A
      * @remark  nn TCs
      */
 
	group Base {
	/**
	 * @desc test cases for validating correct general behaviour which is required for any transaction types
	 * @remark TODO PT140: These TCs shall be completed after the transaction TCs are finalized
	 */
		testcase TP_TC_Base_BV_01() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_01() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_02() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_03() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_04() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_05() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_06() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_07() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_08() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_09() runs on MainTestComponent system TestAdapter {}
		testcase TP_TC_Base_BI_10() runs on MainTestComponent system TestAdapter {}
	} //End group Base TPs

	group USERDETAILS {
         group Valid_Behaviour {
              
         	testcase TP_TC_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TC_USERDETAILS_BV_01: Verify that the TC correctly sends an APDU containing valid RequestADUs
				 * and provides valid ProvideUserDetailsADUs 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noReqAdusReceived;
				var RecordOfUserParameterRequest v_listOfParametersRequested;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived {
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noReqAdusReceived := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						
						
						for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {	
							var RequestADU v_receivedRequestAdu:=v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1];
 							if ( match(v_receivedRequestAdu, mw_aduRequestProvideUserDetails)) {
								v_listOfParametersRequested := v_receivedRequestAdu.userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
									if (not (match(v_listOfParametersRequested[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement
				
				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);

				//All ADUs will be put in the array v_adus
				var Adus v_adus[v_noReqAdusReceived];
				
				//Build v_adus by looping through it
				for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {
					var ProvideUserDetailsADU v_theAdu;
					v_theAdu.originaluserIdRequest := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId;
					v_theAdu.userId := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userId; //TODO this simply copies the ID of the original request. Is that enough?
					v_theAdu.statusFlag := UserStatus_standardCommercialUserContract_;
					for (var integer v_loop2 :=0; v_loop2<sizeof(v_listOfParametersRequested);v_loop2:=v_loop2+1) {
						v_theAdu.listOfUserParameters[v_loop2].requestedUserParameter:=omit;   //TODO is this necessary. I think that if we do not set it then it is omitted 
						v_theAdu.listOfUserParameters[v_loop2].userParameterResponse:= UserParameterResponseDetails_TESTER_VALUES[v_listOfParametersRequested[v_loop2]];					
						v_theAdu.listOfUserParameters[v_loop2].userParameterStatus:= UserParameterStatus_userParameterAvailable_;					
						v_theAdu.listOfUserParameters[v_loop2].userInfoValidityPeriod:=omit; //TODO is this necessary. I think that if we do not set it then it is omitted
					}
					v_adus[v_loop1]:=v_theAdu;
				}								                   
				
				var InfoExchange v_apduProvideUserDetailsSend:=m_apduNoSecOld( m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduProvideUserDetailsSend);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduProvideUserDetailsSend)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BV_01
		} //end group valid behaviour         
         
		group Invalid_Behaviour { 	
			testcase TP_TC_USERDETAILS_BI_01() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_01: Verify that the TC correctly responds to an incorrect ProvideUserDetailsADUs 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noReqAdusReceived ;
				var RecordOfUserParameterRequest listOfParametersRequested;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noReqAdusReceived := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParametersRequested);v_loop2:=v_loop2+1) {
									if (not (match(listOfParametersRequested[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noReqAdusReceived];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU not corresponding to requested parameters, that is v_adus is NEVER SET								                   
				
				var InfoExchange v_apduToSend:=m_apduNoSecOld(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduToSend);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and semantic error (3000)
				var NAckParams v_nAckParams1 :=m_nAckParamsSingle(0, AduReasonCode_semanticError_);
				// TODO PT140 prepare second alternative for providing semantic error
				
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToSend, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_01				
				
			testcase TP_TC_USERDETAILS_BI_02() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_02: Verify that the TC correctly responds to a provideUserDetailsADU
				 * 			with no statusFlag being present 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noReqAdusReceived ;
				var RecordOfUserParameterRequest listOfParametersRequested;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noReqAdusReceived := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParametersRequested);v_loop2:=v_loop2+1) {
									if (not (match(listOfParametersRequested[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noReqAdusReceived];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU with no Status Flag being present								                   
				
				var InfoExchange v_apduForSending:=m_apduNoSecOld(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduForSending);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and invaldAdu error (0)
				var NAckParams v_nAckParams1 :=m_nAckParamsSingle(0, AduReasonCode_invalidADU_);
						
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduForSending, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_02				
				
			testcase TP_TC_USERDETAILS_BI_03() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_03: Verify that the TC correctly responds to a ProvideUserDetailsADU
				 *			with statusFlag ranging from 1 to 5 and no listOfUserParameters being present
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noReqAdusReceived;
				var RecordOfUserParameterRequest listOfParametersRequested;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noReqAdusReceived := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParametersRequested);v_loop2:=v_loop2+1) {
									if (not (match(listOfParametersRequested[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noReqAdusReceived];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU with Status Flag = 1..5 and no listOfUserParameters begin present								                   
				
				var InfoExchange v_apduForSending:=m_apduNoSecOld(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduForSending);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and invaldAdu error (0)
				var NAckParams v_nAckParams1 :=m_nAckParamsSingle(0, AduReasonCode_invalidADU_);
						
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduForSending, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_03				

			testcase TP_TC_USERDETAILS_BI_04() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_04: Verify that the TC correctly responds to a provideUserDetailsADU with statusFlag value
				 *			not included in the interval from 1 to 5 and listOfUserParameters being present
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noReqAdusReceived;
				var RecordOfUserParameterRequest listOfParametersRequested;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noReqAdusReceived := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParametersRequested);v_loop2:=v_loop2+1) {
									if (not (match(listOfParametersRequested[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noReqAdusReceived];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU with Status Flag /= 1..5 and listOfUserParameters begin present								                   
				
				var InfoExchange v_apduForSending:=m_apduNoSecOld(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduForSending);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and invaldAdu error (0)
				var NAckParams v_nAckParams1 :=m_nAckParamsSingle(0, AduReasonCode_invalidADU_);
						
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduForSending, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_04				

			testcase TP_TC_USERDETAILS_BI_05() runs on MainTestComponent system TestAdapter {             
/**
				 * @desc    TP_TC_USERDETAILS_BI_05: Verify that the TC correctly responds to a provideUserDetailsADU
				 *			with invalid parameters in the UserParameterResponse field
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				//Step 1: wait for user details request
				mtcAccessPort.send(USERDETAILS_TR_TC_1);

				var integer v_noReqAdusReceived;
				var RecordOfUserParameterRequest listOfParametersRequested;
				alt {
					[] mtcPort.receive(mw_apduRequest) -> value v_apduReceived{
                		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						//TODO PT140 this needs to be checked against USERDETAILS_TIMEA f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
						t_step.stop;
						
						//Set default verdict
						setverdict(pass);

						v_noReqAdusReceived := sizeof(v_apduReceived.infoExchangeContent.adus.requestAdus);
						//Set verdict to fail in case it fails
						
						for (var integer v_loop1 :=0; v_loop1<v_noReqAdusReceived;v_loop1:=v_loop1+1) {	
 							if ( match(v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1], mw_aduRequestProvideUserDetails)) {
								listOfParametersRequested := v_apduReceived.infoExchangeContent.adus.requestAdus[v_loop1].userDetailsRequest.listOfParametersRequested;
								for (var integer v_loop2 :=0; v_loop2<sizeof(listOfParametersRequested);v_loop2:=v_loop2+1) {
									if (not (match(listOfParametersRequested[v_loop2], mw_userDetailsSupportedListOfParameters ))) {
										setverdict(fail);
										stop;
									}
								}
 							} else {
 								setverdict(fail);
 								stop;
 							}						
						}								                   
					}
				} // End of alt statement

				//Step 2 send ProvideUserDetails within TIME1
				f_wait(USERDETAILS_TIME1_MIN_TC);
				var Adus v_adus[v_noReqAdusReceived];
				
				// TODO PT140: prepare in v_adus provideUserDetailsADU with invalid parameters in UserParameterResponse field								                   
				
				var InfoExchange v_apduForSending:=m_apduNoSecOld(m_apciSendResponse(v_apduReceived), v_adus);
				f_sendAndLogApdu(v_apduForSending);

				//Set timer
				t_step.start(USERDETAILS_TIME2_MAX_TC);
				
				//step 3 wait for AckADU with NAckApdu and invaldAdu error (0)
				var NAckParams v_nAckParams1 :=m_nAckParamsSingle(0, AduReasonCode_invalidADU_);
						
				alt {
					[] mtcPort.receive(m_apduNAck(v_apduForSending, v_nAckParams1)) -> value v_apduReceived{
             		                    		
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME2_MIN_TC); //t_step is an implicit argument and what we will compare against
						t_step.stop;
					}
				} // End of alt statement
				
				f_closeDownMtc();  
			
			} // End of TP_TC_USERDETAILS_BI_05				

         } // End group Invalid_Behaviour

    } // End goup USERDETAILS

	group DSRC_REPORTABNORMALOBE {
		group Valid_Behaviour {
			testcase TP_TC_DSRC_REPORTABNORMALOBE_BV_01() runs on MainTestComponent system TestAdapter {							
               /**
                * @desc    TP_TC_DSRC_REPORTABNORMALOBE_BV_01: Verify that the TC correctly performs a DSRC.REPORTABNORMALOBE transaction
                * @remark  [16986:2016], Clause 7.4 and Table A.1/1 AND Table A.2/1 AND Table A.26/4
                */

  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
                // Step 1: Trigger IUT with DSRC.REPORTABNORMALOBE_TR_TC_1 to send valid Initiating_APDU containing
                // one or more ADUs of type ReportAbnormalOBEADU containing different combinations of valid
                // and IUT declared values in the following data elements
				//		- userID = at least one element shall be present (ensured in the template);
				//		- dateAndTime = present and valid;
				//		- efcContextMark = present and valid;
				//		- abnormalOBEReason code = present and valid                
				f_sendAndLogTrigger(DSRC_REPORTABNORMALOBE_TR_TC_1);

				//  Wait for DSRC.REPORTABNORMALOBE ADU
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({mw_aduDsrcReportAbnormalObe})) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
					               		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();   						           
			} // End testcase TP_TC_DSRC_REPORTABNORMALOBE_BV_01	
		} // End Valid_Behaviour

		group Invalid_Bahaviour {
               /**
                 * @remark  No TPs have been defined
                 */			
		} // End Invalid_Behaviour		
	} // End DSRC_REPORTABNORMALOBE

	group DSRC_EFCCONTEXTDATA {
		group Valid_Behaviour {
			testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_01: Verify that the TC correctly performs a DSRC.EFCCONTEXTDATA transaction
                 *			for a domain type = dsrcContext  
                 * @remark  [16986:2016], Clause 7.2 and Table A.1/1 AND Table A.2/1 AND Table A.26/2 AND Table A.30/2 = dsrcContext
                 */
 
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_2_implementedDSRCEFCCONTEXTDATA and ICS_A30_2_implementedDSRCCONTEXT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  					
                // Step 1: Tigger IUT with DSRC.EFCCONTEXTDATA_TR_TC_1_A to send valid Initiating_Apdu
                // containing a EFCContextDataADU as the only ADU, with
                //		- domainType = dsrcContext;
                //		- the values of all fields in EFCContextDataADU being within the range specified by the IUT
				f_sendAndLogTrigger(DSRC_EFCCONTEXTDATA_TR_TC_1_DSRC_OPEN);

                // Wait for above specified Initiating_Apdu within time constraints
                // if not received or received outside specification set test fail (done in altstep)

				// PT140 TODO : mw_aduDsrcEfcContextData template exiszting but details yet to be defined

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_aduDsrcEfcContextData)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_01	
			
			testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_02: Verify that the TC correctly performs a DSRC.EFCCONTEXTDATA transaction
                 *			for a domain type = dsrcClosedContext  
                 * @remark  [16986:2016], Clause 7.2 and Table A.1/1 AND Table A.2/1 AND Table A.26.2 AND Table A.30/2 = dsrcContext
                 */
 			
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_2_implementedDSRCEFCCONTEXTDATA and ICS_A30_2_implementedDSRCCONTEXT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  
				// Step 1: Tigger IUT with DSRC.EFCCONTEXTDATA_TR_TC_1_B to send valid Initiating_Apdu
                // containing a EFCContextDataADU as the only ADU, with
                //		- domainType = dsrcClosedContext;
                //		- the values of all fields in EFCContextDataADU being within the range specified by the IUT
				f_sendAndLogTrigger(DSRC_EFCCONTEXTDATA_TR_TC_1_DSRC_CLOSED);

                // Wait for above specified Initiating_Apdu within time constraints
                // if not received or received outside specification set test fail (done in altstep)

				// PT140 TODO : aduDsrcClosedContextEfcContextData template exsisting but details yet to be defined

				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_aduDsrcClosedContextEfcContextData)) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_DSRC_EFCCONTEXTDATA_BV_02							
		} // End Valid_Behaviour

		group Invalid_Behaviour {
               /**
                 * @remark  No TPs have been defined
                 */			
		} // End Invalid_Behaviour		
	} // End DSRC_EFCCONTEXTDATA


	group DSRC_BILLINGDETAILS {
		group Valid_Behaviour {
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_01: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=send
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A26.3
                */
				
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  
                // Step 1: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1_SEND to send valid Initiating_Apdu containing BillingDetailsADUs
                // containing all valid permutations of present and not present optional fields and choices that are used
                // in the IUT implementation, all with actionCode = send

				f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_SEND);

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduDsrcBillingDetails:= {actionCode := ActionCode_send_ }}}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time	
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TC);					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_01
			
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_02: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=adjust
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A.36/15 = adjust
                */
 
  				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  
                // Step 0: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1_ADJUST to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send and adjust the same BillingDetailsId in a second step
                
                f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_ADJUST);

				// receive the BillingDetailsADU

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_aduDsrcBillingDetails:= {actionCode := ActionCode_send_ }}}) 
           		};                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						f_checkMinimumTStep(DSRC_BILLINGDETAILS_TIME1_MIN_TC);	
					}
				}

				// capture the billingDetailsId for validation in step 2
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs.billingDetailsId;

				// Step 2: Send NAck within time constraints
				f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);				

				// send a negative Ack (except of issueCode "acceptedWithWarning")
				f_sendAndLogApdu(m_apduNAckIndividualIssuesTester(v_apduReceived, {1, AduReasonCode_semanticError_}));

                // Step 2: Wait for IUT to send adjusted BillingDetailsADU
                // with actionCode = adjust
                // with same billingDetailsId as already received billingDetailsId
                
				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthRespIut({{mw_aduDsrcBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_adjust_
				  	}
				  }}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TC);					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_02
						
			testcase TP_TC_DSRC_BILLINGDETAILS_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_DSRC_EFCCONTEXTDATA_BV_03: Verify that the TC correctly performs a DSRC.BILLINGDETAILS transaction
                *			with actionCode=revoke
                * @remark  [16986:2016], Clause 7.3 and Table A.1/1 AND Table A.2/1 AND Table A.36/15 = revoke
                */
 
   				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                  
                // Step 1: Tigger IUT with DSRC.BILLINGDETAILS_TR_TC_1_REVOKE to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send and revoke the same BillingDetailsId in a second step
                
                f_sendAndLogTrigger(DSRC_BILLINGDETAILS_TR_TC_1_ADJUST);

				// receive the BillingDetailsADU

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthInitIut({{mw_adusDsrcBillingDetails:= {actionCode := ActionCode_send_ }}}) 
           		};                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						f_checkMinimumTStep(DSRC_BILLINGDETAILS_TIME1_MIN_TC);	
					}
				}

				// capture the billingDetailsId for validation in step 2
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs.billingDetailsId;

				// Step 2: Send NAck within time constraints
				f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
				f_sendAndLogApdu(m_apduDefaultAckIut(v_apduReceived));

                // Step 3: Wait for IUT to send adjusted BillingDetailsADU
                // with actionCode = revoke
                // with billingDetailsId as already received billingDetailsId
                
				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoAuthRespIut({{mw_aduDsrcBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_revoke_
				  	}
				  }}) 
           		}; 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TC);					              		
						// Step 2: Send Ack within time constraints
						f_wait(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_DSRC_BILLINGDETAILS_BV_03
		} // End Valid_Behaviour
		
		group Invalid_Behaviour {

               /**
                 * @remark  No TPs have been defined
                 */			
			
		} // End Invalid_Behaviour
		
	} // End DSRC_BILLINGDETAILS


	group DSRC_CONTRACTISSUERLIST {
		group Valid_Behaviour {		
			testcase TP_TC_DSRC_CONTRACTISSUERLIST_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BV_01: Verify that the TC correctly performs
                 *			a DSRC.CONTRACTISSUERLIST transaction with three ContractIssuerListADUs  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.2/1 AND Table A.26/1
                 */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                                		              
                // Step 1:
                // Prepare and send Initiating_Apdu containing three ContractIssuerListADUs with differing manufacturerID values
				var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({
					  	TD_CONTRACT_ISSUER_DATA_VALID_1,
					  	TD_CONTRACT_ISSUER_DATA_VALID_2,
					  	TD_CONTRACT_ISSUER_DATA_VALID_3
					  	});                 
				f_sendAndLogApdu(v_apduToBeSent);                     
                
                // Start timer
                t_step.start(DSRC_CONTRACTISSUERLIST_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time DSRC.CONTRACTISSUERLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToBeSent)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
				} 
				f_closeDownMtc();                	
              } // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BV_01              
		} // End group Valid_Behaviour
					
		group Invalid_Behaviour {	
			testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BI_01: Verify that the TC correctly responds to
                 *			a ContractIssuerListADUs with three different semantically faulty parameters  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.2/1 AND Table A.26/1
                 */

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                        		
                 
                // Step 1:
                // Send Initiating_Apdu containing three ContractIssuerListADUs each one with exactly
                // one incorrect parameter value from the set [uniquePartOfPan, acCrKeyReference, authKeyReference]

				var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({
					  	TD_CONTRACT_ISSUER_DATA_INVALID_1,
					  	TD_CONTRACT_ISSUER_DATA_INVALID_2,
					  	TD_CONTRACT_ISSUER_DATA_INVALID_3
					});                 
				f_sendAndLogApdu(v_apduToBeSent); 
                
                // Start timer
                t_step.start(DSRC_CONTRACTISSUERLIST_TIME1_MAX_TC);   

              	// Wait for NAck_Apdu within time DSRC.CONTRACTISSUERLIST.TIME1
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError (3000) for ADU#1, #2 and #3
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduToBeSent, AduReasonCode_semanticError_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}

					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduToBeSent, {
						{1, AduReasonCode_semanticError_},
						{2, AduReasonCode_semanticError_},
						{3, AduReasonCode_semanticError_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(DSRC_CONTRACTISSUERLIST_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}										
				}
				f_closeDownMtc();				            	          				
			} // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_01			

			testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_DSRC_CONTRACTISSUERLIST_BI_02: Verify that the TC correctly responds to a RequestADU
                 *			sent earlier than allowed  
                 * @remark  [16986:2016], Clause 7.1 and Table A.1/1 AND Table A.2/1 AND Table A.26/1
                 */

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_1_isDsrc and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                        		

                // Step 0: Send Initiating_Apdu containing one ContractIssuerListADU
                // Prepare and send one Initiating_Apdu containing exactly one ContractIssuerListADU
                var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_CONTRACT_ISSUER_DATA_VALID_1});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                                                
                // Step 1: Send second Initiating_Apdu containing one ContractIssuerListADU
                // before DSRC.CONTRACTISSUERLIST.TIMEA_MIN has passed
				f_wait(DSRC_CONTRACTISSUERLIST_TIMEA_MIN_TC / 2);

				var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_CONTRACT_ISSUER_DATA_VALID_1});                 
				f_sendAndLogApdu(v_apduToBeSent); 
                
                // Start timer
                t_step.start(DSRC_CONTRACTISSUERLIST_TIME1_MAX_TC);   

				// Step 2: Wait for NAck_Apdu with issueCode=NAck_requestSentTooOften(10)
            	// within the time DSRC.CONTRACTISSUERLIST.TIME1  
              	// if other Ack or not received set test failure --> is done in altstep            	

				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduToBeSent)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						// set verdict
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				            	
			} // End testcase TP_TC_DSRC_CONTRACTISSUERLIST_BI_02
		} // End group Invalid_Behaviour
	} // End DSRC_CONTRACTISSUERLIST 


	group LISTOFUSERS {
	
		group Valid_Behaviour {
		
			testcase TP_TC_LISTOFUSERS_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_01: Verify that the TC correctly performs a LISTOFUSERS transaction 
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                  
                // Initialisation
                  
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1 to send valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data

				// Waint for requestADU(s), validate and check time constraints							

                // Step 2: Send valid ProvideUserIdListADU following request from IUT within time constraint LISTOFUSERS.TIME1
                
                // Step 3: Wait for Default_Ack_Apdu within LISTOFUSERS.TIME2			
			
			} // End of TP_TC_LISTOFUSERS_BV_01
			
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase TP_TC_LISTOFUSERS_BI_01() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_01: Verify that the TC correctly responds to a ProvideUserIdListADU with originalUserId not present
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                  
                // Initialisation
                  
                // Step 1: Trigger IUT with LISTOFUSERS_TR_TC_1 to send one valid RequestADU of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data

				// Waint for requestADU, validate and check time constraints							

                // Step 2: Send ProvideUserIdListADU not containing an originalUserId field
                
                // Step 3: Wait for NAck_Apdu within LISTOFUSERS.TIME2 with aduReasonCode = semanticError (3000D)			
			
			} // End of TP_TC_LISTOFUSERS_BI_01

			testcase TP_TC_LISTOFUSERS_BI_02() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_02: Verify that the TC correctly responds to a ProvideUserIdListADU with userIds
                 *			which have not be requested in the requestADU
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                  
                // Initialisation
                  
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1 to send valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data

				// Waint for requestADU(s), validate and check time constraints							

                // Step 2: Send ProvideUserIdListADU(s) with userIds which have not been requested
                
                // Step 3: Wait for NAck_Apdu with ({0, semanticError (3000)})
                // or NAck_Apdu with ({1, semanticError (3000)}, , {n, semanticError (3000)})
                // where n is the number of ProvideUserIdListADUs
                // within LISTOFUSERS.TIME2 
			
			} // End of TP_TC_LISTOFUSERS_BI_02
			
			testcase TP_TC_LISTOFUSERS_BI_03() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_LISTOFUSERS_BI_03: Verify that the TC correctly responds to a ProvideUserIdListADU
                 *			with invalid userId data
                 * @remark  [16986:2016], Clause 6.5 and Table A.1/1 AND Table A.7/2
                 */
                  
                // Initialisation
                  
                // Step 1: Tigger IUT with LISTOFUSERS_TR_TC_1 to send valid RequestADU(s) of type userListRequest with
                //		- userIdRequestType = 0,
                //		- userId = at least one of {pan, licensePlateNumber, obeId, contractSerialNumber},
                //		- userIdRequestTime; and
                //		- requesting IUT declared user data

				// Waint for requestADU(s), validate and check time constraints							

                // Step 2: Send ProvideUserIdListADU(s) within LISTOFUSERS.TIME1
                // containing UserIds in the userIdList with all fields empty
                
                // Step 3: Wait for NAck_Apdu with ({0, invalidADU(0)})
                // or NAck_Apdu with ({1, InvalidADU(0)}, , {n, invalidADU(0)})
                // where n is the number of ProvideUserIdListADUs
                // within LISTOFUSERS.TIME2 
			
			} // End of TP_TC_LISTOFUSERS_BI_03

		} // End of Invalid_Behaviour
		
	} // End of group LISTOFUSERS
	
	group EXCEPTIONLIST {
		
		group Valid_Behaviour {
		
			testcase TP_TC_EXCEPTIONLIST_BV_01() runs on MainTestComponent system TestAdapter {
										
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BV_01: 1)	Verify that the TC correctly responds to an ExceptionListADU
                 *			for blacklist and whitelist
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */
			
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				// Start by setting test success
				
				// Loop (first intertation [LIST_TYPE] = black; second iteration [LIST_TYPE] = white)
							
                // Step 1 / loop 1 for black list:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for black list
                var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_BLACK_VALID});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToBeSent)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
					}
				}
				
				// Note: Step 2 may start immediately as no TIMEA is defined for EXCEPTIONLIST
				
				// Step 2 / loop 2 for white list:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for white list
                v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_WHITE_VALID});
				f_sendAndLogApdu(v_apduToBeSent);                	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToBeSent)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_WHITE_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
				} 				 
				f_closeDownMtc();              
			} // End of TP_TC_EXCEPTIONLIST_BV_01                              

			testcase TP_TC_EXCEPTIONLIST_BV_02() runs on MainTestComponent system TestAdapter {
										
                /**
                 * @desc    TP_TC_EXCEPTIONLIST_BV_02: Verify that the TC correctly responds to an ExceptionListADU
                 *			for discounted user list
                 * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
                 */

 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
				// Start by setting test success
							
                // Step 1:
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for discounted user list
                var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_DISCOUNTED_VALID});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_DISCOUNT_TIME1_MAX_TC);               
                // Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
                //		- Default_Ack, or
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = semanticError(3000) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduToBeSent, AduReasonCode_semanticError_)) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduToBeSent, {{1, AduReasonCode_semanticError_}})) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}								
				}			 
				f_closeDownMtc();
			}            
		} // End of group Valid_Behaviour
			
		group Invalid_Behaviour {
		
			testcase TP_TC_EXCEPTIONLIST_BI_01() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_01: Verify that the TC correctly responds to an ExceptionListADU for blacklist containing
            *			exceptionValidityEnd field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */
		
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
							
            	// Prepare Initiating_Apdu containing
            	//		- exactly one valid ExceptionListADU indicating list type BLACK; AND
				//		- exactly one ExceptionListADU indicating list type BLACK and containing exceptionValidityEnd of any value
	  	
                var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_BLACK_INVALID_1});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
            	
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               

              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = exceptionListsDateAndTimeRejected(405) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsDateAndTimeRejected(405) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduToBeSent, AduReasonCode_exceptionListsDateAndTimeRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduToBeSent, {{1, AduReasonCode_exceptionListsDateAndTimeRejected_}})) -> value v_apduReceived {				  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass);												
					}								
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_01

			testcase TP_TC_EXCEPTIONLIST_BI_02() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_02: Verify that the TC correctly responds to an ExceptionListADU for blacklist
            *			containing the efcContextMark field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 
          
            	// Step 1: Send Initiating_Apdu containing exactly one ExceptionListADU indicating list type BLACK containing
            	//		- efcContextMark of any value
               var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_BLACK_INVALID_2});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	

                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);     
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = invalidAdu(0) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduToBeSent, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduToBeSent, {{1, AduReasonCode_invalidADU_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_02

			testcase TP_TC_EXCEPTIONLIST_BI_03() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_03: Verify that the TC correctly responds to one APDU
            *			containing more than one ExceptionListADU
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */ 				

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 

            	// Step 1: Send Initiating_Apdu containing more than one ExceptionListADU indicating list type BLACK
               	var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({TD_EXCEPTIONLIST_ADU_BLACK_VALID, TD_EXCEPTIONLIST_ADU_BLACK_VALID});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
		
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with apduNotOk(3)
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduToBeSent, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_03

			testcase TP_TC_EXCEPTIONLIST_BI_04() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_04: Verify that the TC correctly responds to an ExceptionListADU
            *			bearing an incorrect value for exceptionListVersion field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */
		
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 

           		// Step 1: Send Initiating_Apdu containing one ExceptionListADU indicating list type BLACK
            	//		- with exceptionListVersion </= 0
               	var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_BLACK_INVALID_3});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
		
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = exceptionListsVersionRejected(400) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsVersionRejected(400) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduToBeSent, AduReasonCode_exceptionListsVersionRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduToBeSent, {{1, AduReasonCode_exceptionListsVersionRejected_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();	
			} // End of TP_TC_EXCEPTIONLIST_BI_04

			testcase TP_TC_EXCEPTIONLIST_BI_05() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_05: Verify that the TC correctly responds to an ExceptionListADU
			*			bearing an incorrect value for exceptionListType field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */   				

				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 

             	// Step 1: Send Initiating_Apdu containing one ExceptionListADU indicating exceptionListType = 4
               	var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_TYPE4_VALID});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
		
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);            
            	
              	// Wait for Ack_Apdu within time TIME_DEFAULT
                //		- NAck_Apdu with aduReasonCode = exceptionListsTypeRejected(401) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsTypeRejected(401) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduToBeSent, AduReasonCode_exceptionListsTypeRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(TIME_DEFAULT);
						setverdict(pass);
					}					

					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduToBeSent, {{1, AduReasonCode_exceptionListsTypeRejected_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(TIME_DEFAULT);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();	
			} // End of TP_TC_EXCEPTIONLIST_BI_05

			testcase TP_TC_EXCEPTIONLIST_BI_06() runs on MainTestComponent system TestAdapter {
													
            /**
            * @desc    TP_TC_EXCEPTIONLIST_BI_06: Verify that the TC correctly responds to an ExceptionListADU
            *			bearing an incorrect value for userId field
            * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
            */
  				
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc                 

	            // Step 1: Send Initiating_Apdu containing one ExceptionListADU of list type BLACK
    	        // and userId = contractSerialNumber present
               	var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_BLACK_INVALID_4});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
		
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);           
            	
              	// Wait for Ack_Apdu within time EXCEPTIONLIST.BLACK_TIME1
                //		- NAck_Apdu with aduReasonCode = exceptionListsUserIdRejected(402) for all ADUs, or
                //		- NAck_Apdu with aduReasonCode = exceptionListsUserIdRejected(402) for ADU#1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduToBeSent, AduReasonCode_exceptionListsUserIdRejected_)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}					
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduToBeSent, {{1, AduReasonCode_exceptionListsUserIdRejected_}})) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}										
				}
				f_closeDownMtc();	
			} // End of TP_TC_EXCEPTIONLIST_BI_06

			testcase TP_TC_EXCEPTIONLIST_BI_07() runs on MainTestComponent system TestAdapter {
													
            /**
             * @desc    TP_TC_EXCEPTIONLIST_BI_07: Verify that the TC responds correctly
             *			to a RequestADU sent earlier than allowed
             * @remark  [16986:2016], Clause 6.6 and Table A.1/1 AND Table A.7/3
             */  				

				// Initialisation
				//check if the testcase should be run, activate altsteps on ports, etc 
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_3_implementedEXCEPTIONLIST and (EXCEPTIONLIST_BLACK_TIME0_MIN_TC > 0);
				f_intialiseMtc(v_runOrNot);                 
							
                // Transaction 1
            	// Step 1: Send Initiating_Apdu containing one valid ExceptionListADU of list type BLACK
            
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for black list
                var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_BLACK_VALID});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               

                // Transaction 1 / Step 2:	
              	// Wait for Default_Ack_Apdu within time EXCEPTIONLIST.TIME1
              	// if negative Ack or not received set test failure --> is done in altstep

				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToBeSent)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
					}
				}
								
				// Transaction 2
            	// Step 1: Send second Initiating_Apdu containing one valid ExceptionListADU of list type BLACK
            	// before TIME0 MIN has passed = immediately after the Ack in Transaction 1 
            	
                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for black list
                v_apduToBeSent := m_apduNoAuthInitTester({TD_EXCEPTIONLIST_ADU_BLACK_VALID});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
  	
                // Start timer
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TC);               

				// Step 2: Wait for NAck_Apdu with issueCode=NAck_requestSentTooOften(10)
            	// within the time EXCEPTIONLIST.BLACK_TIME1 
              	// if negative Ack or not received set test failure --> is done in altstep            	

				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduToBeSent)) -> value v_apduReceived {
						// Log what we received, check minimum time and stop time		
						f_logReceivedThenCheckAndStopTime(EXCEPTIONLIST_BLACK_TIME1_MIN_TC);
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				
			} // End of TP_TC_EXCEPTIONLIST_BI_07
		} // End of group Invalid_Behaviour 	
	} // End of group EXCEPTIONLIST		
			
	group TRUSTOBJECTS {
         
		group Valid_Behaviour {
           
			testcase TP_TC_TRUSTOBJECTS_BV_01() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BV_01: Verify that the TC correctly provides a TrustObjectADU without TSP request
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_01
                 */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				var boolean isCertificateOrPublicKey:=false;
				var boolean isDsrcKeyRef := false;
				var boolean isMacMasterKey := false;
				var boolean isDsrcMasterKey := false;
				var boolean isCertificateRevocationList := false;
				var boolean isDsrcKey:=false;
				
				var integer objectsReceived := 0;
				// Step 1: Trigger IUT with TRUSTOBJECTS_TR_2
				f_sendAndLogTrigger(TRUSTOBJECTS_TR_2);

				//  Wait for TRUSTOBJECTS
				// We expect to receive as many APDUs containing TRUSTOBJECTS ADUs as the number of declared supported trust objects
				// PT140 TODO: No timeout set, so risk to wait indifinetely to receive all APDUs. Alternative is to set a PIXIT timeout parameter

				alt {
					[] mtcPort.receive(mw_apduTrustObject) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();	
						//send Ack whichever object received
						f_logReceivedWaitAndAcknowledge(v_apduReceived); 							
						// Look at the type of Trust Object received and set the related variable 				
						if (match(v_apduReceived, mw_apduTrustObjectCertificate)) 
							{isCertificateOrPublicKey:=true;}
						if (match(v_apduReceived, mw_apduTrustObjectPublicKey)) 
							{isCertificateOrPublicKey:=true;}
						if (match(v_apduReceived, mw_apduTrustObjectGeneric))
							{isCertificateRevocationList := true;}
						if (match(v_apduReceived ,mw_apduTrustObjectDsrcKeyRef)) 
							{isDsrcKeyRef:=true;}
						if (match(v_apduReceived ,mw_apduTrustObjectMacKey)) 
							{isMacMasterKey:=true;}
						if (match(v_apduReceived, mw_apduTrustObjectDsrcKey)) 
							{isDsrcKey:=true;}
	
						objectsReceived := objectsReceived + 1; // Count the number of trust objects received
						if (objectsReceived == sizeof(SENT_TRUST_OBJECTS_SUPPORTED)) {
						  	goto ReceivedAll;
						}
						repeat;
					}										
				} // End of alt statement
				// Exiting the alt means that the expected number of Trust Objects have been received
				label ReceivedAll;
				if (ICS_A2_1_isDsrc and isCertificateOrPublicKey and isDsrcKeyRef and isMacMasterKey and isDsrcMasterKey) {
					setverdict(pass);
				}			 				
				if (ICS_A2_2_isGnss and isCertificateOrPublicKey and isDsrcKeyRef){
					setverdict(pass);
				}			 				
				f_closeDownMtc();              
			} // End of TP_TC_TRUSTOBJECTS_BV_01

			testcase TP_TC_TRUSTOBJECTS_BV_02() runs on MainTestComponent system TestAdapter {
						
            /**
            * @desc    TP_TC_TRUSTOBJECTS_BV_02: Verify that the TC correctly responds to a Trust Object received
            *			from a TSP without having issued a request
            * @remark  [16986:2016], Clause 6.7 and Table A.1/1
            * @remark	same as TP_TSP_TRUSTOBJECT_BV_02
            */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
            	// Step 1: Send one valid APDU containing the a valid TrustObjectADU with the only mandatorily supported type in both profiles, for all possible purposes
				var InfoExchange v_apduRespondedTo := m_apduNoSecInit(m_aduTrustObject
				({TrustObjectPurposes_dSRCCharging_,TrustObjectPurposes_dSRCAC_,TrustObjectPurposes_oBEInterrogation_,TrustObjectPurposes_oBEInterrogationAC_}, dsrcKeyRefObjectTESTER_VALUE));                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
            	// Step 2: Wait for positive Ack within TRUSTOBJECTS.TIME2
				// Set timer
            	t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                 
			
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduRespondedTo)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME2_MIN_TC);
						setverdict(pass);
					} 
				} // End of Alt statement 
				f_closeDownMtc();                   
			} // End of TP_TC_TRUSTOBJECTS_BV_02

			testcase TP_TC_TRUSTOBJECTS_BV_03() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BV_03: Verify that the TC correctly provides a TrustObjectADU
                 *			following a TSP request
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_03
                 */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Loop in all available types of trustobject supported by the IUT as specified by the length of SENT_TRUST_OBJECTS_SUPPORTED Pixit record

				var integer v_trustObjectsToBeSent := sizeof(SENT_TRUST_OBJECTS_SUPPORTED);
				for (var integer v_trustObjectsReceived :=1; v_trustObjectsReceived<v_trustObjectsToBeSent;v_trustObjectsReceived:=v_trustObjectsReceived+1)
					{
						// Prepare a request of a Trust Object by taking allowed type and purpose from the RECEIVED_TRUST_OBJECTS_SUPPORTED Pixit value
						
						var integer v_requestedTrustObjectType := SENT_TRUST_OBJECTS_SUPPORTED[v_trustObjectsReceived].trustObjectType;
						var TrustObjectPurposes v_requestedTrustObjectPurposes := SENT_TRUST_OBJECTS_SUPPORTED[v_trustObjectsReceived].trustObjectPurpose
						
						var InfoExchange v_apduRequestForTrustObject := m_apduNoAuth(
							m_apciInitTester, Adus:{
								requestAdus:= {
									requestedADUType:= 3,
									requestedTrustObject:={
										trustObjectSpec:={
											typeOfTrustObject := v_requestedTrustObjectType,
					    					purposesOfTrustObject := v_requestedTrustObjectPurposes
					    				}
									}
								}
							}
						);
						f_sendAndLogApdu(v_apduRequestForTrustObject);
			
						// Set timer
                		 t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TC);
						// Step #2: Wait for TrustObjects ADU
						// Either we receive an APDU containing  TrustObject or the timeout expires
                 		alt {
                      		[] mtcPort.receive(mw_apduTrustObject) -> value v_apduReceived {
								f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TC);  

                        		// Step #3: Send DefaultACK with correct identifier
								f_logReceivedWaitAndAcknowledge(TRUSTOBJECTS_TYPE1_TIME2_MIN_TC);
                      			}
                    		} // End of alt statement
						}; // end of for statement
				//Set verdict
				setverdict(pass);
				f_closeDownMtc(); 				 

			} // End of TP_TC_TRUSTOBJECTS_BV_03

			testcase TP_TC_TRUSTOBJECTS_BV_04() runs on MainTestComponent system TestAdapter {
						
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BV_04: Verify that the TC correctly requests and responds to a TrustObjectADU
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BV_04
                 */
  
				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Step 1: Trigger IUT with TRUSTOBJECTS_TR_1
				f_sendAndLogTrigger(TRUSTOBJECTS_TR_1);
				//  Wait for request for TRUSTOBJECTS
				// Loop in all available types of trustobject requested supported by the IUT by repeating receive
				var integer v_expectedTrustObjectRequests := sizeof(SENT_TRUST_OBJECTS_SUPPORTED);
				var integer v_receivedTrustObjects := 0;
				// Set timer
                t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TC);                 
				alt {
					[] mtcPort.receive(mw_apduRequestTrustObjects) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();
						t_step.stop;
						v_receivedTrustObjects := v_receivedTrustObjects + 1;
                		// Step 1: Send one valid APDU containing one valid TrustObjectADU

						// Analysis of what requested and what to be sent						
						if (ispresent(v_apduReceived.infoExchangeContent.adus.requestAdus.trustObjectRequest.requestedTrustObject.trustObjectId)) {
							f_addLogEntry("Received a request for a specific TrustObjectId, this is not supported according to CEN/TS 16986:2016");
							setverdict(fail);
							break;					
							}
						var TrustObjectSpec v_requestedTrustObjectSpec := v_apduReceived.infoExchangeContent.adus.requestAdus.trustObjectRequest.requestedTrustObject.trustObjectSpec;
						var TrustObjectTypes v_requestedTrustObjectType := v_requestedTrustObjectSpec.typeOfTrustObject;
						var RecOfTrustObjectPurposes v_requestedTrustObjectPurposesRecords := v_requestedTrustObjectSpec.purposesOfTrustObject;
						var InfoExchange v_apduToSend; 
						                												
						//TODO this is not complete! THere are other possibilities as well that can be requested
						if (v_requestedTrustObjectType == TrustObjectTypes_certificate_){
							v_apduToSend := m_apduTrustObjectResponse(
								v_apduReceived, 
								v_requestedTrustObjectPurposesRecords,
								TD_CERTIFICATE_OBJECT			
								);
							};
						if (v_requestedTrustObjectType == TrustObjectTypes_publicKey_){
							v_apduToSend := m_apduTrustObjectResponse(
								v_apduReceived, 
								v_requestedTrustObjectPurposesRecords,
								TD_PUBLICKEY_OBJECT
								);                 												
							};
						if (v_requestedTrustObjectType == TrustObjectTypes_symmetricKey_){
							v_apduToSend := m_apduTrustObjectResponse(
								v_apduReceived, 
								v_requestedTrustObjectPurposesRecords,
								TD_DSRCKEY_OBJECT
								);                 												
							};
						f_sendAndLogApdu(v_apduToSend);                 
                
                		// Step 2: Wait for positive Ack within TRUSTOBJECTS.TIME2
						// Set timer
                 		t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                 
						alt {
							[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToSend)) -> value v_apduReceived {
								// Log what we received
								f_logApduReceivedAndTStep();
								t_step.stop;
							}
						} // End of second alt 
					
						if (v_receivedTrustObjects == v_expectedTrustObjectRequests) {
							setverdict(pass);
							break;  
						};
	                	t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TC);  // Restart timer               
						repeat;
					}	
				} // End of first alt 					
				f_closeDownMtc();                  

			} // End of TP_TC_TRUSTOBJECTS_BV_04
		} // End group Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase TP_TC_TRUSTOBJECTS_BI_01() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_01: Verify that the TC correctly responds to a TrustObjectADU received
                 *			without having issued a request and containing incorrect ADU parameters
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_01
                 */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester(m_aduTrustObjectInvalidStatus);                 
				f_sendAndLogApdu(v_apduToBeSent);                 
                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
				// Set timer
                t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                		

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduRespondedTo, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAck_IndividualAdus(v_apduRespondedTo, {{1, AduReasonCode_invalidADU_},{2,AduReasonCode_invalidADU_}})) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                   
                          
			} // End of TP_TC_TRUSTOBJECTS_BI_01 
 
 			testcase TP_TC_TRUSTOBJECTS_BI_02() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_02: Verify that the TC correctly responds to more than one correct TrustObjectADU
                 *			in the same APDU without having issued a request
                 *			without having issued a request and containing incorrect ADU parameters
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_02
                 */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Set two different TrustObject adus by varying the type of trust object 
				var InfoExchange v_apduToBeSent := m_apduNoAuthInitTester(
					{
					 m_aduTrustObject(
						{TrustObjectPurposes_dSRCCharging_,TrustObjectPurposes_dSRCAC_,TrustObjectPurposes_oBEInterrogation_,TrustObjectPurposes_oBEInterrogationAC_},
						dsrcKeyRefObjectTESTER_VALUE),
					 m_aduTrustObject(
					 	{TrustObjectPurposes_dSRCCharging_},
					 	certificateTESTER_OBJECT) }
					);                 
				f_sendAndLogApdu(v_apduToBeSent);                 
                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
				// Set timer
                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                		
				//Create parameters for the m_apduNAck			

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduRespondedTo, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAck_IndividualAdus(v_apduRespondedTo, {{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}})) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                   

			} // End of TP_TC_TRUSTOBJECTS_BI_02 
 
			testcase TP_TC_TRUSTOBJECTS_BI_03() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_03: Verify that the TC correctly responds to a request
                 *			for a not supported Trust Object
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_03
                 */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Prepare an invalid certificate (not supported by the profile)
				var InfoExchange v_apduRespondedTo := m_apduNoAuthInitTester(TrustObjectADU({TrustObjectPurposes_certIssuing_},invalidTESTERGenericObject));                 
				f_sendAndLogApdu(v_apduRespondedTo);                 
                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
				// Set timer
                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);                		
				//Create parameters for the m_apduNAck			

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduRespondedTo, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAck_IndividualAdus(v_apduRespondedTo, {{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}})) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(0.0); // No need to check minimum wait time in response
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                   

           } // End of TP_TC_TRUSTOBJECTS_BI_03 
 
			testcase TP_TC_TRUSTOBJECTS_BI_04() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_04: Verify that the TC correctly responds to a RequestADU sent earlier than allowed
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_04
                 */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Step1: send RequestADU by specifying the type of trustobject
				// Prepare a request of a Trust Object by taking allowed type and purpose from the SENT_TRUST_OBJECTS_SUPPORTED Pixit value
				var RequestADU requestAdu :={
					requestedADUType := 3,
					requestedTrustObject:={
						trustObjectSpec := {
							typeOfTrustObject := SENT_TRUST_OBJECTS_SUPPORTED[1].trustObjectType,
							purposesOfTrustObject := SENT_TRUST_OBJECTS_SUPPORTED[1].trustObjectPurpose}
						}
				}

				var Adus requestAduInWrapper:= {requestAdus:={requestAdu}};
				
				var InfoExchange v_firstApduRequest:=m_apduNoAuthInitTester(requestAduInWrapper); 
				var InfoExchange v_secondApduReqest:=m_apduNoAuthInitTester(requestAduInWrapper); 
				
				
				// Now send the first apdu
				f_sendAndLogApdu(v_firstApduRequest);
				
       			//Immediately send same ADU with different APDUid				
				f_sendAndLogApdu(v_secondApduRequest);
                              
				//Set timer
				t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TC);
                
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduRespondedTo)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME2_MIN_TC);  
						setverdict(pass);
						}
					} // End of Alt statement 
				f_closeDownMtc();              

           } // End of TP_TC_TRUSTOBJECTS_BI_04 
 
			testcase TP_TC_TRUSTOBJECTS_BI_05() runs on MainTestComponent system TestAdapter {   
 		
                /**
                 * @desc    TP_TC_TRUSTOBJECTS_BI_05: Verify that the TC correctly responds to a TrustObjectADU sent earlier than allowed
                 * @remark  [16986:2016], Clause 6.7 and Table A.1/1
                 * @remark	same as TP_TSP_TRUSTOBJECT_BI_05
                 */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Step1: prepare TrustObjectADU by specifying KeyRef as type of trustobject
				var TrustObjectADU v_trustObjectAdu := m_aduTrustObject(
						{TrustObjectPurposes_dSRCCharging_,TrustObjectPurposes_dSRCAC_,TrustObjectPurposes_oBEInterrogation_,TrustObjectPurposes_oBEInterrogationAC_},
						TrustObjectCode:{dsrcKeyRef := dsrcKeyRefObjectTESTER_VALUE}
				);                 
				
				var InfoExchange v_firstApduToBeSent := m_apduNoAuthInitTester(v_trustObjectAdu);
				var InfoExchange v_secondApduToBeSent := m_apduNoAuthInitTester(v_trustObjectAdu);

				// Send the first apdu
				f_sendAndLogApdu(v_firstApduToBeSent);
				// Send second apdu immediately
				f_sendAndLogApdu(v_secondApduToBeSent);				

				//Set timer
				t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TC);
                
				// Step #2: Wait for Nack ADU				 					
				// Either we receive an APDU containing  Nack or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[] mtcPort.receive(m_apduNAckRequestSentTooOften(v_apduRespondedTo)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TC);  
						setverdict(pass);
						}
					} 
				f_closeDownMtc();            
             
           } // End of TP_TC_TRUSTOBJECTS_BI_05   
 		} // End group Invalid_Behaviour
	} // End of group TRUSTOBJECTS		

	group PAYMENTCLAIM {
	
		group Valid_Behaviour {
		
			testcase TP_TC_PAYMENTCLAIM_BV_01() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_01: Verify that the TC correctly performs the PAYMENTCLAIM transaction with
                 *			actionCode=send 
                 * @remark  [16986:2016], Clause 6.8 and Table A.1/1 AND Table A.7/5
                 */
                  
                // Initialisation
                  
                // Let IUT perform one BILLINGDETAILS complete and sucessful transaction
                  
                // Step 1: Tigger IUT with PAYMENTCLAIM_TR_TC_1_SEND to send valid Initiating_Apdu containing
                //		- exactly one PaymentClaimADU with actionCode=send

				// Waint for requestADU(s), validate and check time constraints
				
				// Step 2: Send AckADU to conclude the transaction							
		
			} // End of TP_TC_LISTOFUSERS_BV_01
					
			testcase TP_TC_PAYMENTCLAIM_BV_02() runs on MainTestComponent system TestAdapter {
							
                /**
                 * @desc    TP_TC_LISTOFUSERS_BV_02: Verify that the TC correctly performs the PAYMENTCLAIM transaction with
                 *			actionCode=revoke or adjust  
                 * @remark  [16986:2016], Clause 6.8 and Table A.1/1 AND Table A.7/5
                 */
                  
                // Initialisation
                
                // Loop: Repeate with
                //		- first iteration: ACTION_CODE=revoke;
                //		- second iteration: ACTION_CODE=adjust
                  
                	// Let IUT perform one BILLINGDETAILS complete and sucessful transaction
                	// Trigger IUT with PAYMENTCLAIM_TR_TC_1_REVOKE to send valid Initiating_Apdu containing
                	// exactly one PaymentClaimADU with actionCode=arevoke;
                	// Send AckADU to colclude the transaction
                  
                	// Step 1: Tigger IUT with PAYMENTCLAIM_TR_TC_1_REVOKE to send valid Initiating_Apdu containing
                	//		- exactly one PaymentClaimADU, with
                	//		- with actionCode=[ACTION_CODE], and
                	//		- paymentClaimId = same value as a previously sent PaymentClaimId
    
					// Waint for requestADU(s), validate and check time constraints
				
					// Step 2: Send AckADU to conclude the transaction							
		
			} // End of TP_TC_LISTOFUSERS_BV_02
			
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {
		
               /**
                 * @remark  No TPs have been defined
                 */
 		
 		} // End Invalid_Behaviour
 		
 	} // End PAYMENTCLAIM	

	group GNSS_TOLLDECLARATION {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_TOLLDECLARATION_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_01: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = send
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
								
                // Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send

                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = send                // Prepare and send one Initiating_Apdu containing exactly one ExceptionListADU for discounted user list
                // TODO Jan: Define tester data required inside the module TesterData               

				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						TD_USAGE_STATEMENT_VALID_2,
						2,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3},
						TD_USAGE_STATEMENT_VALID_3,
						3,
						Action_Code_send_),							
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4},
						TD_USAGE_STATEMENT_VALID_4,
						4,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5},
						TD_USAGE_STATEMENT_VALID_5,
						5,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 6},
						TD_USAGE_STATEMENT_VALID_6
						6,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 7},
						TD_USAGE_STATEMENT_VALID_7,
						7,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 8},
						TD_USAGE_STATEMENT_VALID_8,
						8,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 9},
						TD_USAGE_STATEMENT_VALID_9,
						9,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 10},
						TD_USAGE_STATEMENT_VALID_10,
						10,
						Action_Code_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
                
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
						//Set verdict
						setverdict(pass)												
					}
				}	
				f_closeDownMtc();						 
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_01

			testcase TP_TC_GNSS_TOLLDECLARATION_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_02: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = revoke
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 

                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = send

				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						TD_USAGE_STATEMENT_VALID_2,
						2,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3},
						TD_USAGE_STATEMENT_VALID_3,
						3,
						Action_Code_send_),							
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4},
						TD_USAGE_STATEMENT_VALID_4,
						4,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5},
						TD_USAGE_STATEMENT_VALID_5,
						5,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 6},
						TD_USAGE_STATEMENT_VALID_6
						6,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 7},
						TD_USAGE_STATEMENT_VALID_7,
						7,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 8},
						TD_USAGE_STATEMENT_VALID_8,
						8,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 9},
						TD_USAGE_STATEMENT_VALID_9,
						9,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 10},
						TD_USAGE_STATEMENT_VALID_10,
						10,
						Action_Code_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail 

				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
											
                // Step 2:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations with tollDeclarationId = same value as already received toll declarations and
                // containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = revoke
                             
                // Send second Initiating_Apdu containing ten valid TollDeclarationADUs with actionCode = revoke
                // before GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP has passed
				f_wait(GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP / 2);

                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = revoke
                // Note that it is required to send again with same TollDeclarationId,
                // same TollDeclarations and same Charge Report Id
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_revoke_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						TD_USAGE_STATEMENT_VALID_2,
						2,
						Action_Code_revoke_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3},
						TD_USAGE_STATEMENT_VALID_3,
						3,
						Action_Code_revoke_),							
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4},
						TD_USAGE_STATEMENT_VALID_4,
						4,
						Action_Code_revoke_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5},
						TD_USAGE_STATEMENT_VALID_5,
						5,
						Action_Code_revoke_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 6},
						TD_USAGE_STATEMENT_VALID_6
						6,
						Action_Code_revoke_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 7},
						TD_USAGE_STATEMENT_VALID_7,
						7,
						Action_Code_revoke_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 8},
						TD_USAGE_STATEMENT_VALID_8,
						8,
						Action_Code_revoke_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 9},
						TD_USAGE_STATEMENT_VALID_9,
						9,
						Action_Code_revoke_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 10},
						TD_USAGE_STATEMENT_VALID_10,
						10,
						Action_Code_revoke_)
				});
				                
                // Step 3:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
						//Set verdict
						setverdict(pass)												
					}					
				}
				f_closeDownMtc();				
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_02

			testcase TP_TC_GNSS_TOLLDECLARATION_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BV_03: Verify that the TC correctly performs a GNSS.TOLLDECLARATION transaction
                *			with actionCode = adjust
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */

  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
				// Step 1:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 

               // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = send

				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						TD_USAGE_STATEMENT_VALID_2,
						2,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3},
						TD_USAGE_STATEMENT_VALID_3,
						3,
						Action_Code_send_),							
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4},
						TD_USAGE_STATEMENT_VALID_4,
						4,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5},
						TD_USAGE_STATEMENT_VALID_5,
						5,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 6},
						TD_USAGE_STATEMENT_VALID_6
						6,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 7},
						TD_USAGE_STATEMENT_VALID_7,
						7,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 8},
						TD_USAGE_STATEMENT_VALID_8,
						8,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 9},
						TD_USAGE_STATEMENT_VALID_9,
						9,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 10},
						TD_USAGE_STATEMENT_VALID_10,
						10,
						Action_Code_send_)
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
								
                // Wait for NAck_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 
				// TODO JAN / PT140: below Ack to be preplaced by a negative ack according to the specifications of is16986
				// for this case of adjusting TollDeclarationADUs
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
								
                // Step 2:
                // Send valid Initiating_Apdu containing 10 ADUs of type TollDeclarationADU containing
                // gnssTollDeclarations with tollDeclarationId = same value as already received toll declarations and
                // containing different combinations of valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = adjust

                // Send second Initiating_Apdu containing ten valid TollDeclarationADUs with actionCode = adjust
                // before GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP has passed
				f_wait(GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP / 2);
				
                // Prepare and send one Initiating_Apdu containing exactly ten TollDeclarationADUs with actionCode = adjust
                // Note that it is required to send again with same TollDeclarationId,
                // but "corrected" TollDeclarations and a new Charge Report Id
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 1},
						TESTER_USAGE_STATEMENT_VALID_11,
						11,
						Action_Code_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 2},
						TESTER_USAGE_STATEMENT_VALID_12,
						12,
						Action_Code_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 3},
						TESTER_USAGE_STATEMENT_VALID_13,
						13,
						Action_Code_adjust_),							
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 4},
						TESTER_USAGE_STATEMENT_VALID_14,
						14,
						Action_Code_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 5},
						TESTER_USAGE_STATEMENT_VALID_15,
						15,
						Action_Code_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 6},
						TESTER_USAGE_STATEMENT_VALID_16
						16,
						Action_Code_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 7},
						TESTER_USAGE_STATEMENT_VALID_17,
						17,
						Action_Code_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 8},
						TESTER_USAGE_STATEMENT_VALID_18,
						18,
						Action_Code_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 9},
						TESTER_USAGE_STATEMENT_VALID_19,
						19,
						Action_Code_adjust_),
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 10},
						TESTER_USAGE_STATEMENT_VALID_20,
						20,
						Action_Code_adjust_)
				});
				
                // Step 3:
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
						//Set verdict
						setverdict(pass)												
					}
				}
				f_closeDownMtc();				
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BV_03
		} // End of Valid_Behaviour
		
		group Invalid_Behaviour {

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_01: Verify that the TC correctly responds to an APDU containing
                *			a number of TollDeclarationADUs which exceeds PARAM1_MAX
                *			that are not the same as the original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
								
                // Step 1:
                // Send Initiating_Apdu containing TollDeclarationADUs
                // with valid and IUT declared values but exceeding GNSS.TOLLDECLARATION.PARAM1_MAX

               // Prepare and send an Initiating_Apdu with PARAM1_MAX + 1 TollDeclarationADUs with actionCode = send

				var InfoExchange v_apduToBeSent;
				var Adus v_adusToBeSent; //List of ADUs to be sent 
				var UsageStatement v_usageStatementToBeSent;

				for (var integer v_loop := 0; v_loop = GNSS_TOLLDECLARATIONS_PARAM1_MAX_TC; v_loop := loop + 1) {	
 					v_usageStatementToBeSent := {
						usageStatementId := v_loop,
						tollContext := TESTER_TOLL_CONTEXT,
						aggregatedSingleTariffClassSession := TESTER_SINGLE_TARIFF_CLASS_SESSION,
						listOfChargeObjects TESTER_LIST_OF_CHARGE_OBJECTS,
						listOfRawUsageData := TESTER_LIST_OF_RAW_USAGE_DATA,
						additionalUsageInformation := omit
					};
 					v_adusToBeSent[v_loop] := m_aduTollDeclarationToSendOneObe(
							{TESTER_IDENTIFIER, v_loop},
							v_usageStatementToBeSent,
							v_loop,
							Action_Code_send_);
				};		
 					
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester(v_adusToBeSent);
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
                
                // Step 2:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({n,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
                
                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams_2 := {{GNSS_TOLLDECLARATIONS_PARAM1_MAX_TC, AduReasonCode_semanticError_}};

				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_01
		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_02: Verify that the TC correctly responds to an APDU containing
                * 			valid TollDeclarationADUs with actionCode = revoke but tollDeclarationIds
                *			that are not the same as the original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // gnssTollDeclarations containing valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = send

				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 1},
						TESTER_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_send_)
					});

				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
								
                // Step 2:
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // a gnssTollDeclaration with tollDeclarationId /= the value as already received toll declaration and
				// containing valid and IUT declared values for
				// 		- chargeReport,
				//		- chargeReportUsageStatementList and
				//		- usageStatement; and
				//		- actionCode = revoke

                // Send second Initiating_Apdu containing one valid TollDeclarationADUs with actionCode = revoke
                // before GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP has passed
				f_wait(GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP / 2);

                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = revoke
                // same TollDeclarations and same Charge Report Id
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 2},
						TESTER_USAGE_STATEMENT_VALID_2,
						2,
						Action_Code_revoke_)
					});
                
                // Step 3:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams_2 := {{1, AduReasonCode_semanticError_}};

				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_02

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_03: Verify that the TC correctly responds to an APDU containing
                *			valid TollDeclarationADUs with actionCode = adjust but tollDeclarationIds
                *			that are not the same the as original tollDeclarationIds
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // gnssTollDeclarations containing valid and IUT declared values within
				//		- valid chargeReport fields; and
				//		- valid chargeReportUsageStatementList fields; and
				//		- valid usageStatement fields, and
				//		- actionCode = send 
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = send

				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 1},
						TESTER_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_send_)
					});

				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

				alt {
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);												
					}
				}
								
                // Step 2:
                // Send valid Initiating_Apdu containing exactly one ADU of type TollDeclarationADU containing
                // a gnssTollDeclaration with tollDeclarationId /= the value as already received toll declaration and
				// containing valid and IUT declared values for
				// 		- chargeReport,
				//		- chargeReportUsageStatementList and
				//		- usageStatement; and
				//		- actionCode = adjust

                // Send second Initiating_Apdu containing one valid TollDeclarationADUs with actionCode = revoke
                // before GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP has passed
				f_wait(GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP / 2);

                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = revoke
                // same TollDeclarations and same Charge Report Id
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 2},
						TESTER_USAGE_STATEMENT_VALID_2,
						2,
						Action_Code_adjust_)
					});
                
                // Step 3:
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams_2 := {{1, AduReasonCode_semanticError_}};

				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_03

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_04: Verify that the TC correctly responds to an APDU
                *			containing valid TollDeclarationADUs with tollDeclarationIds being not unique
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing two TollDeclarationADU containing
				//		- tollDeclarationId = same values in the two toll declarations, and
				//		- gnssTollDeclarations with valid and IUT declared values, and
				//		- actionCode = send
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclarationADUs with actionCode = send

				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 1},
						TESTER_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TESTER_IDENTIFIER, 1},
						TESTER_USAGE_STATEMENT_VALID_1,
						2,
						Action_Code_send_),
					});
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with apduAckCode = apduNotOK (3)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail 

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams := {{0, ApduReasonCode_apduNotOK_}};

				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_04
               		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_05: Verify that the TC correctly responds to an APDU containing
                *			valid TollDeclarationADUs with gnssTollDeclaration of Choice AuthenticatedChargeReport
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing
				//		- gnssTollDeclaration of Choice AuthenticatedChargeReport, and
				//		- actionCode = send
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclaratioN
                // of Choice AuthenticatedChargeReport with actionCode = send
                // TODO define TESTER_AUTHENTICATED_CHARGE_REPORT in module TesterData

				var TollDeclarationADU v_aduTollDeclarationAuthenticatedChargeReport := {
					tollDeclarationId := {TESTER_IDENTIFIER, 1}, 
					gnssTollDeclaration := {
						authenticatedChargeReport := TESTER_AUTHENTICATED_CHARGE_REPORT
					},
				actionCode:= ActionCode_send_
				};
				
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({v_aduTollDeclarationAuthenticatedChargeReportm});

				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with apduAckCode = apduNotOK (3)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams := {{0, ApduReasonCode_apduNotOK_}};

				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                								
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_05

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_06: Verify that the TC correctly responds to an APDU containing
                *			a number of chargeReports which exceeds GNSS.TOLLDECLARATION.PARAM2_MAX
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
								
                // Step 1:
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- more than GNSS.TOLLDECLARATION.PARAM2_MAX chargeReports containing valid and IUT declared values;
				//		- actionCode = send

				// Prepare and send an Initiating_Apdu with PARAM2_MAX + 1 TollDeclarationADUs with actionCode = send

				var InfoExchange v_apduToBeSent;
				var Adus v_adusToBeSent; //List of ADUs to be sent
				// TODO: revise because of only one ADU required 
				var UsageStatement v_usageStatementToBeSent;

				for (var integer v_loop := 0; v_loop = GNSS_TOLLDECLARATIONS_PARAM2_MAX_TC; v_loop := loop + 1) {	
 					v_usageStatementToBeSent := {
						usageStatementId := v_loop,
						tollContext := TESTER_TOLL_CONTEXT,
						aggregatedSingleTariffClassSession := TESTER_SINGLE_TARIFF_CLASS_SESSION,
						listOfChargeObjects TESTER_LIST_OF_CHARGE_OBJECTS,
						listOfRawUsageData := TESTER_LIST_OF_RAW_USAGE_DATA,
						additionalUsageInformation := omit
					};
 					v_adusToBeSent[v_loop] := m_aduTollDeclarationToSendOneObe( 
							{TESTER_IDENTIFIER, v_loop}, // TODO: is the assumption correct that one TD contains one ChargeReport?
							v_usageStatementToBeSent,
							v_loop,
							Action_Code_send_);
				};		
 					
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester(v_adusToBeSent);
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
                
                // Step 2:
                // Wait for NAck_Apdu with (with issues= NULL)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail
                
                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams := {{0, ApduReasonCode_apduNotOK_}};

				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                								
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_06

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_07() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_07: Verify that the TC correctly responds to an APDU containing
                *			a TollDeclarationADU in which the actionCode is not present
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
 				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- with valid and IUT declared values, and
                //		- actionCode = NULL
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclaration
                // with actionCode = NULL

				template (value) TollDeclarationADU m_aduTollDeclarationToSendOneObeOtherActionCodes
					modifies m_aduTollDeclarationToSendOneObe:={actionCode := ?); // to allow any value for actionCode

				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObeOtherActionCodes(
						{TESTER_IDENTIFIER, 1},
						TESTER_USAGE_STATEMENT_VALID_1,
						1,
						null)
					});

				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with
                //		- ({0,semanticError(3000)}) OR
                //		- ({1,semanticError(3000)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_semanticError_}};
				var NAckParams v_nAckParams_2 := {{1, AduReasonCode_semanticError_}};

				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_07
	                		
			testcase TP_TC_GNSS_TOLLDECLARATION_BI_08() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_08: Verify that the TC correctly responds to an APDU containing
                *			a TollDeclarationADU in which the actionCode is neither send, revoke nor adjust
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 
				
                // Step 1: 
                // Send Initiating_Apdu containing exactly one TollDeclarationADU containing with
                //		- with valid and IUT declared values, and
                //		- actionCode /= {send, revoke, adjust}
				
                // Prepare and send one Initiating_Apdu containing exactly one TollDeclaration
                // with actionCode = 4

				template (value) TollDeclarationADU m_aduTollDeclarationToSendOneObeOtherActionCodes
					modifies m_aduTollDeclarationToSendOneObe:={actionCode := ?); // to allow any value for actionCode

				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObeOtherActionCodes(
						{TESTER_IDENTIFIER, 1},
						TESTER_USAGE_STATEMENT_VALID_1,
						1,
						ActionCode_resend_) // other actionCode = 4
					});

				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               
				
                // Wait for NAck_Apdu with
                //		- ({0,actionCodeNotSupported(3010)}) OR
                //		- ({1,actionCodeNotSupported(3010)}) 
                // within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

                // Prepare parameters to be expected in the NAck-APDU
				var NAckParams v_nAckParams_1 := {{0, AduReasonCode_actionCodeNotSupported_}};
				var NAckParams v_nAckParams_2 := {{1, AduReasonCode_actionCodeNotSupported_}};

				alt {
					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_1)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}

					[] mtcPort.receive(m_apduNAck(v_apduToBeSent, v_nAckParams_2)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC); // check for minimum wait time in response
						setverdict(pass);
					}
				}
				f_closeDownMtc();				            	          				                
			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_08

			testcase TP_TC_GNSS_TOLLDECLARATION_BI_09() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_TOLLDECLARATION_BI_09: Verify that the TC correctly responds to an APDU containing
                *			more than one TollDeclarationADUs with actionCode send of which
                *			one or more fields in the toll declarations and/or underlying data elements are invalid
                * @remark  [16986:2016], Clause 8.1 and Table A.1/1 AND Table A.2/2 AND Table A.52/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
								
                // Step 1:
                // Send Initiating_Apdu containing
                //		- one TollDeclarationADU with valid and IUT declared values; and
                //		- one TollDeclarationADU with values not declared as IUT implemented
                //		- actionCode = send
                
                // Step 2:
                // Wait for Ack_Apdu with
                //		- issueADUStruct =2, and
                //		- issueCode = semanticError(3000)
                // within GNSS.TOLLDECLARARTION.TIME1             
                // use template for NAck_Apdus
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_TOLLDECLARATION_BI_09
			
		} // End Invalid_Behaviour
		
	} // End GNSS_TOLLDECLARATION

	group GNSS_BILLINGDETAILS_TSP {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when a TSP provides a single BillingDetailsADU
                *			with no optional fields except includedDiscounts and actionCode=send
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- includedDiscounts is present; and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides
                *			a single BillingDetailsADU with no optional fields, actionCode = send
                *			and having selected forSectionedRoads
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for SectionedRoads; and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forTravellingInArea
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/2
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for TracellingInArea, and
				//		- the value of entranceChargeObjectName in forCordonCrossing being a correct UTF8String, and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_03

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forStayingInArea
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/3
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for StayingInArea, and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_04

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP provides a single BillingDetailsADU
                *			with no optional fields, actionCode = send and having selected forCordonCrossings
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1 AND Table A.56/4
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a BillingDetailsADU as the only ADU, with
				//		- the values of all fields in BillingDetailsADU being within the range specified by the IUT, and
				//		- chioce for CordonCrossing, and
				//		- actionCode=send
                 
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_05

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06: Verify that the TC correctly performs
                *			a GNSS_BILLINGDETAILS_TSP transaction when the TSP provides multiple BillingDetailsADUs
                *			with no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing a GNSS.BILLINGDETAILS.TSP.PARAM1_MAX valid BillingDetailsADUs with
                //		- actionCode = send and no optional fields
                  
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_06

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP sends a single BillingDetailsADU
                *			with actionCode = adjust and no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with negative Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = adjust, and
				//		- no optional fields, and
				//		- billingDetailsNum referencing the previously received BillingDetailsADU
                  
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_07

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08: VVerify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TSP transaction when the TSP sends a single BillingDetailsADU
                *			with actionCode =revoke and no optional fields
                * @remark  [16986:2016], Clauses 8.2.2 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.BILLINGDETAILS transaction with positive Ack
				// wait respective time constraints until next transaction starts
				// Perform a corresponing GNSS.TOLLDECLARATION trasnaction
				// wait respective time constraints until next transaction starts
								
                // Step 1:
                // Send valid Initiating_Apdu containing exactly one valid BillingDetailsADUs with
				//		- all mandatory fields, and
				//		- actionCode = revoke, and
				//		- no optional fields, and
				//		- billingDetailsNum referencing the previously received BillingDetailsADU
                  
                // Step 2:
                // Wait for Default_Ack_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1             
                // use template for Default_Ack_Apdu
                // if not received or received outside specification or time constraints set test fail

			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BV_08
			
		} // End Valid_Behaviour

		group Invalid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01: Verify that the TC correctly responds
                *			when receiving multiple BillingDetailsADUs with no optional fields present
                *			with each BillingDetailsADU having one field with an incorrect value
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                 
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing 10 BillingDetailsADUs with
                //		- all mandatory fields, and
                //		- no optional fields,
                //		- where the following fields have an incorrect value
                //			(a) billingDetailsId.issuerId
                //			(b) tollContext
                //			(c)	userId
                //			(d) billingDetailsAmount
                //			(e) usageDetails.contextName
                //			(f) usageDetails.appliedUserClass
                //			(g) usageDetails.perDeclaredVehicleClasses
                //			(h)	usageDetails.appliedTimeClass
                //			(i) usageDetails.entranceTime
                //			(j) usageList.ListofSections.chargeObjectId
                 
                // Step 2:
                // Wait for NAck_Apdu within GNSS.BILLINGDETAILS.TSP.TIME1
                // with issueCodes corresponding to the incorrect velues above:
                //			(a) billingDetailsIssuerIdRejected
                //			(b) billingDetailsContextIdRejected
                //			(c) billingDetailsUserIdRejected
                //			(d) billingDetailsAmountRejected
                //			(e) billingDetailsContextNameRejected
                //			(f) billingDetailsAppliedUserClassRejected
                //			(g) billingDetailsDeclaredVehicleClassRejected
                //			(h) billingDetailsAppliedTimeClassRejected
                //			(i) billingDetailsEntranceTimeRejected
                //			(j) billingDetailsIntermediateSectionRejected
                             
                // use template(s) for NAck_Apdu
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02: Verify that the TC correctly responds
                * 			when the TSP provides a single BillingDetailsADU with only mandatory fields,
                *			then issues a second BillingDetailsADU too early
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
								
                // Step 1:
                // Before TIMEA_MIN as passed, send valid Initiating_Apdu containing exactly one BillingDetailsADUs with
                //		- all mandatory fields, and
                //		- no optional fields,
                 
                // Step 2:
                // Wait for NAck_requestSentTooOften(10) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck_requestSentTooOften(10)
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03: Verify that the TC correctly responds
                *			when the TSP sends too many BillingDetailsADUs
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing
                // (GNSS.BILLINGDETAILS.TSP. PARAM1_MAX +1) BillingDetailsADUs, with no optional fields
                 
                // Step 2:
                // Wait for NAck containing issueCode = semanticError(3000) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_03

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04: Verify that the TC correctly reponds
                *			when the TSP adjusts billing details that do not exist at IUT side
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing containing exactly one a BillingDetailsADU with
                //		- all mandatory fields, and
                //		- actionCode = adjust, and
                //		- no optional fields, and
                //		- billingDetailsNum referencing a billing details that do not exist at the IUT side
                 
                // Step 2:
                // Wait for NAck containing issueCode = semanticError(3000) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_04

			testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05: Verify that the TC correctly reponds
                *			when the TSP tries to revoke billing details that do not exist at TC side
                * @remark  [16986:2016], Clauses 8.2 and Table A.1/1 AND Table A.2/2 AND Table A.52/1
                */
 
  				// Initialisation
                
				// Start by setting test success
				// Perform a full GNSS.TOLLDECLARATION transaction with positive Ack
				// wait respective time constraints until next transaction 	
								
                // Step 1:
                // Send valid Initiating_Apdu containing containing exactly one a BillingDetailsADU with
                //		- all mandatory fields, and
                //		- actionCode = revoke, and
                //		- no optional fields, and
                //		- billingDetailsNum referencing a billing details that do not exist at the IUT side
                 
                // Step 2:
                // Wait for NAck containing issueCode = semanticError(3000) within GNSS.BILLINGDETAILS.TSP.TIME1
                // use template(s) for NAck
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TSP_BI_05

		} // End Invalid_Behaviour
		
	} // End GNSS_BILLINGDETAILS_TSP

	group GNSS_BILLINGDETAILS_TC {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_01: Verify that the TC correctly performs a GNSS.BILLINGDETAILS.TC transaction
                *			with BillingDetailsADUs containing all permutations of present and
                *			not present optional fields that vary in the IUT implementation, all with actionCode=send
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_2_implementedGNSSBILLINGDETAILSTC;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed

				// Step 1:
				// Perform a full GNSS.TOLLDECLARATION transaction with five(5) tollDeclarations
				// receive positive Ack
				// wait respective time constraints until next transaction 	
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 2},
						TD_USAGE_STATEMENT_VALID_2,
						2,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 3},
						TD_USAGE_STATEMENT_VALID_3,
						3,
						Action_Code_send_),							
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 4},
						TD_USAGE_STATEMENT_VALID_4,
						4,
						Action_Code_send_),
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 5},
						TD_USAGE_STATEMENT_VALID_5,
						5,
						Action_Code_send_),
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	
								
                // Step 2:
                // Trigger IUT with GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND to send BillingDetailsADUs containing
                //		- all valid permutations of present and not present optional fields and choices that are used in the IUT implementation
                //		- and correspond to the toll declarations sent by the Tester

				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_SEND);

				// TODO PT140: make sure the reference to toll declarations is validated
				
				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoSecInitIut({{mw_aduGnssBillingDetails:= {actionCode := ActionCode_send_ }}}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); // check for minimum wait time in response					              		
						// Step 3: Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_01

			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_02: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TC transaction when it sends a single BillingDetailsADU
                *			with actionCode = adjust and no optional fields
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_2_implementedGNSSBILLINGDETAILSTC;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed

				// Step 1:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				// wait respective time constraints until next transaction 	
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_send_),
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 2: Tigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_ADJUST to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send and adjust the same BillingDetailsId in a second step
                
                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_ADJUST);

				// capture the tollDeclarationId for use in step 3
				var TollDeclarationId v_receivedTollDeclarationId;
				v_receivedTollDeclarationId := v_apduReceived.infoExchangeContent.adus.tollDeclarationADUs.tollDeclarationId;

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoSecInitIut({{mw_aduGnssBillingDetails:= {
				  		tollDeclarationId := v_receivedTollDeclarationId,
				  		actionCode := ActionCode_send_
				  	}}}) 
           		};                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); // check for minimum wait time in response					              		
						// Step 3: Send NAck within time constraints
						f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
					}
				}

				// capture the billingDetailsId for validation in step 3
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs.billingDetailsId;
				// send a negative Ack (except of issueCode "acceptedWithWarning")
				// Create parameters for the m_apduNAck			
				var NAckParams v_nAckParams1 :={{1, AduReasonCode_semanticError_}};

				f_sendAndLogApdu(m_apduNAck(v_apduReceived, v_nAckParams1));

                // Step 4: Wait for IUT to send adjusted BillingDetailsADU
                // with actionCode = adjust
                // with same billingDetailsId as already received billingDetailsId
				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoSec({{mw_aduGnssBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_adjust_
				  	}
				  }}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); // check for minimum wait time in response					              		
						// Step 2: Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_02

			testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_BILLINGDETAILS_TC_BV_03: Verify that the TC correctly performs
                *			a GNSS.BILLINGDETAILS.TC transaction when it sends a single BillingDetailsADU
                *			with actionCode = revoke and no optional fields
                * @remark  [16986:2016], Clauses 8.2.3 and 8.2.4 and Table A.1/1 AND Table A.2/2 AND Table A.52/2
                */
 
  				// Initialisation
 				var boolean v_runOrNot := ICS_A1_1_isTc and ICS_A2_2_isGnss and ICS_A52_2_implementedGNSSBILLINGDETAILSTC;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc 

				// Loop: In case GNSS.BILLINGDETAILS.TSP. PARAM1_MAX < the number of needed BilligDetailsADUs then insert iterations
				// Not needed

				// Step 1:
				// Perform a full GNSS.TOLLDECLARATION transaction with one(1) tollDeclarations
				// receive positive Ack
				// wait respective time constraints until next transaction 	
				var InfoExchange v_apduToBeSent := m_apduNoSecInitTester({
					m_aduTollDeclarationToSendOneObe(
						{TD_IDENTIFIER, 1},
						TD_USAGE_STATEMENT_VALID_1,
						1,
						Action_Code_send_),
				});
				                	               	                	                	                	                	                	              	
				f_sendAndLogApdu(v_apduToBeSent);                	 	 	
                // Start timer
                t_step.start(GNSS_TOLLDECLARATIONS_TIME1_MAX_TC);               

                // Wait for Default_Ack_Apdu within GNSS.TOLLDECLARARTION.TIME1             
                // if not received or received outside specification or time constraints set test fail

				alt {				
					[] mtcPort.receive(m_apduDefaultAck(v_apduToBeSent)) -> value v_apduReceived {					  
						// Log what we received, check minimum time and stop time
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIME1_MIN_TC);
					}
				}	

                // Step 2: Tigger IUT with GNSS.BILLINGDETAILS_TC_TR_TC_1_REVOKE to send an Initiating_Apdu containing one BillingDetailsADU
                // with actionCode = send and revoke the same BillingDetailsId in a second step
                
                f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TC_TR_TC_1_REVOKE);

				// capture the tollDeclarationId for use in step 3
				var TollDeclarationId v_receivedTollDeclarationId;
				v_receivedTollDeclarationId := v_apduReceived.infoExchangeContent.adus.tollDeclarationADUs.tollDeclarationId;

				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoSecInitIut({{mw_aduGnssBillingDetails:= {
				  		tollDeclarationId := v_receivedTollDeclarationId,
				  		actionCode := ActionCode_send_
				  	}}}) 
           		};                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); // check for minimum wait time in response					              		
						// Step 3: Send NAck within time constraints
						f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
					}
				}

				// capture the billingDetailsId for validation in step 3
				var BillingDetailsId v_receivedBillingDetailsId;
				v_receivedBillingDetailsId := v_apduReceived.infoExchangeContent.adus.billingDetailsADUs.billingDetailsId;

				// send an Ack
				f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));

                // Step 4: Wait for IUT to revke BillingDetailsADU
                // with actionCode = revoke
                // with same billingDetailsId as already received billingDetailsId
				var InfoExchange v_apduToBeReceived := {
				  	mw_apduNoSec({{mw_aduGnssBillingDetails:= {
				  		billingDetailsId := v_receivedBillingDetailsId,
				  		actionCode := ActionCode_revoke_
				  	}
				  }}) 
           		};                 

                // Wait for above specified APDU within time constraints
                // if not received or received outside specification or time constraints set test fail

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TC); // check for minimum wait time in response					              		
						// Step 2: Send Ack within time constraints
						f_wait(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));
						// Set test success
						setverdict(pass);
					}
				} // End of alt statement
				f_closeDownMtc();              	                   
			} // End testcase TP_TC_GNSS_BILLINGDETAILS_TC_BV_03			
		} // End Valid_Behaviour

		group Invalid_Bahaviour {

               /**
                 * @remark  No TPs have been defined
                 */			
			
		} // End group Invalid_Behaviour		
		
	} // End group GNSS_BILLINGDETAILS_TC
	
	group GNSS_PAYMENTANNOUNCEMENT {
	
		group Valid_Behaviour {
		
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01: Verify that the TC correctly performs
                *			a GNSS.PAYMENTANNOUNCEMENT transaction
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform at least one GNSS_BILLINGDETAILS trasnaction with positive Acknowledgement	
				// Wait until respective time constraints for starting next transaction are passed
                 				
                // Step 1:
                // Send Initiating_Apdu containing only three or more valid PaymentAnnouncementADU with
                //		- actionCode = send
                  
                // Step 2:  
                // Wait for Default_Ack_Apdu within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BV_01
			
		} // End Valid_Behaviour
		
		group Invalid_Behaviour {
		
			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU with an incorrect actionCode
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform one GNSS_BILLINGDETAILS transaction with positive Ack	
				// Wait until respective time constraints for starting next transaction are passed
				// Perform one GNSS_PAYMENTANNOUNCEMENT transaction with actionCode=send with positive Ack 
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing 
				//		- exactly one PaymentAnnouncementADU with actionCode=credit, and
				//		- exactly one PaymentAnnouncementADU with actionCode=resend
				//		- both referencing to paymentAnnouncementIds previousely sent
                  
                // Step 2:  
                // Wait for NAck_Apdu containing one AckADU containing
				//		- {an "issues" SEQUENCE of length two with the issueCode=indicating invalidADU for all and
				//			issueADUStruct indicating 1 and 2 respectively}, or
				//		- {an "issues" SEQUENCE of length one with issueCode=invalidADU and issueADUStruct=0}
                // within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdus
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_01

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU with incorrect paymentAnnouncementID 
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform one GNSS_BILLINGDETAILS transaction with positive Ack	
				// Wait until respective time constraints for starting next transaction are passed
				// Perform one GNSS_PAYMENTANNOUNCEMENT transaction with actionCode=send with positive Ack 
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing 
				// 		- exactly one PaymentAnnouncementADU with actionCode=send containing
				//			paymentAnnouncementId = value that has previously been used, and
				//		- exactly one PaymentAnnouncementADU with actionCode=revoke containing
				//			paymentAnnouncementId = value that has not previously been used
                  
                // Step 2:  
                // Wait for NAck_Apdu containing one AckADU containing
				//		- {an "issues" SEQUENCE of length two with the issueCode=indicating invalidADU for all and
				//			issueADUStruct indicating 1 and 2 respectively}, or
				//		- {an "issues" SEQUENCE of length one with issueCode=invalidADU and issueADUStruct=0}
                // within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdus
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_02

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03: Verify that the TC correctly responds
                *			to PaymentAnnouncementADUs where details from referenceDetailsList are not present
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform one GNSS_BILLINGDETAILS transaction with positive Ack	
				// Wait until respective time constraints for starting next transaction are passed
				// Make sure no GNSS_PAYMENTANNOUNCEMENT transaction is performed
								
                // Step 1:
                // Send Initiating_Apdu containing
                //		- exactly one valid PaymentAnnouncementADU, and
                //		- exactly one PaymentAnnouncementADU with actionCode=send containing
				//			- referenceDetailsList of the choice billingDetailsList containing
				//				- exactly one BillingDetailsId that does not make reference
				//					to the BillingDetailsADU of the previously performed BILLINGDETAILS transaction
                  
                // Step 2:  
                // Wait for NAck_Apdu({2,invalidADU(0)} within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdu
                
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_03

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU where the length of the referenceDetailsList is too long
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform GNSS_BILLINGDETAILS transaction with positive Ack in which the number of billingDetails
				// shall be (1+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX)	
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing
                //		- one valid PaymentAnnouncementADU, and
                //		- one PaymentAnnouncementADU with actionCode=send containing
                //			- referenceDetailsList of the choice billingDetailsList containing
                //				- exactly (1+GNSS.PAYMENTANNOUNCEMENT.PARAM2_MAX) BillingDetailsId that makes reference to
                //					the BillingDetailsADUs of the previously performed BILLINGDETAILS transaction
                  
                // Step 2:  
                // Wait for NAck_Apdu({2,invalidADU(0)} within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdu
                
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_04

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05: Verify that the TC correctly responds to
                *			a PaymentAnnouncementADU where the attachement is too big
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform one GNSS_BILLINGDETAILS transaction with positive Ack	
				// Wait until respective time constraints for starting next transaction are passed
				// Perform one GNSS_PAYMENTANNOUNCEMENT transaction with actionCode=send with positive Ack 
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing
                //		- one valid PaymentAnnouncementADU, and
                //		- one PaymentAnnouncementADU with actionCode=send containing an attachment larger than (2^31)1 bytes
                  
                // Step 2:  
                // Wait for NAck_Apdu({2,invalidADU(0)} within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdu
                
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_05

			testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06() runs on MainTestComponent system TestAdapter {
							
               /**
                * @desc    TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06: Verify that the TC correctly responds to
                *			an APDU containing too many PaymentAnnouncementADUs
                * @remark  [16986:2016], Clauses 8.3 and Table A.1/1 AND Table A.2/2 AND Table A.52/4
                */
 
  				// Initialisation

				// Start by setting test success

				// Perform GNSS_BILLINGDETAILS transaction with positive Ack in which the number of billingDetails
				// shall be (1+GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX)	
				// Wait until respective time constraints for starting next transaction are passed
								
                // Step 1:
                // Send Initiating_Apdu containing exactly (GNSS.PAYMENTANNOUNCEMENT.PARAM1_MAX+1) valid PaymentAnnouncementADUs 
                  
                // Step 2:  
                // Wait for NAck_Apdu with apduReasonCode=apduNotOK(3) within time specified by GNSS.PAYMENTANNOUNCEMENT.TIME1
                // use a template for the NAck_Apdu
                
                // if not received or received outside specification or time constraints set test fail
                
			} // End testcase TP_TC_GNSS_PAYMENTANNOUNCEMENT_BI_06
			
		} // End group Invalid_Behaviour
		
	} // End group GNSS_PAYMENTANNOUNCEMENT	
	                		
} // End of module EfcInfoExchange_TestCasesTc

