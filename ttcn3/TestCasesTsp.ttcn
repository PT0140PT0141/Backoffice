/**
 * @author  PT0140 
 * @desc    This module provides test cases based on TS 16986 TPs
 * @see     [xxxx-1:2017]: Test suite structure and test purpose
 * @see     [xxxx-1:2016], Clause 5.2.1  Namimg conventions
 * @version $id$
 */
  /**
 * work in progress Status overview
 *
 *	Transaction type			!	BV					! BI			! Comments
 * 	----------------------------!-----------------------!---------------!--------------------------------
 *	Base						! done					! done			! to be compiled
 *	Userdetails					! done					! done			! to be compiled
 *	ListOfUsers					! done					! done			! to be compiled
 *	ExceptionList				! done					! done			! to be compiled
 *	TrustObjects				! done    				! done			! to be compiled
 *	PaymentClaim				! done					! done			! to be compiled
 *	DSRC.ContractIssuerList		! done					! done			! to be compiled
 *	DSRC.EFCContextData			! done					! done			! to be compiled
 *	DSRC.BillingDetails			! done					! done			! to be compiled
 *	DSRC.ReportAbnormalOBE		! done					! done			! to be compiled
 *	GNSS.TollDeclaration		! done					! done			! to be compiled
 *	GNSS.BillingDetails.TSP		! done					! done			! to be compiled
 *	GNSS.BillingDetails.TC		! done					! done			! to be compiled
 *	GNSS.PaymentAnnouncement	! done					! done			! to be compiled
 */
 
module EfcInfoExchange_TestCasesTsp {
    /**
     * @desc    [12855:2015]: 
     * @see     Annex A (normative)  data type specifications
     */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    import from EfcInfoExchange language "ASN.1:1997" all;
    
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     *          Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
     */
    import from LibEfc_Common_Parameterised_Asn1_Data all;
	import from EfcInfoExchange_ParameterisedAsn1Data all;
    import from EfcInfoExchange_Interfaces all;
	import from EfcInfoExchange_InteroperabilityStatement all;
    import from EfcInfoExchange_Functions all;	
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Ics all;
    import from EfcInfoExchange_Templates all;
	import from EfcInfoExchange_TesterData all;
    import from EfcInfoExchange_Profile all;
    
    
    /**
     /**
      * @desc    These Test Cases apply to Toll Service Provider claiming conformance to [16986:2016] and applying Test Purposes as from TS xxxxx:2018 Annex B
      * @remark  nn TCs
      */
    group Base {
         /**
          * @desc    Test subgroup objective:
          * - to test IUT with respect to the correctness of base and general functionalities that are required in many or all transaction types;
          */
     	group Valid_Behaviour {
			testcase TP_TSP_BASE_BV_01() runs on MainTestComponent system TestAdapter {
             /**
              * @desc    TP_TSP_BASE_BV_01: Verify that a TC validates correct infoExchanceAuthenticators in received APDUs and generates correct infoExchangeAuthenticators 
              * @remark  [16986:2016], Clause 6.2.2 and Table A.1/2 
              */            
               
               // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS and ICS_A3_3_useAuthenticator;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                              
               // Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
               // and in addition an infoExchangeAuthenticator = value calculated according to clause 7.3 of EN ISO 12855

				// Prepare the APDU 
				v_apduForSending := m_apduAuthInitTester(m_adusRequestUserDetailsRandomParams);
                
				// send RequestADU
				f_sendAndLogApdu(v_apduForSending);                                          
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an authenticated APDU containing Provide User Details ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[]	mtcPort.receive(mw_apduAuthProvideUserDetails(v_apduForSending)) -> value v_apduReceived{    		                    		
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); // No check on minimum wait time to respond
						
						if (fx_checkAuthenticator(v_apduReceived)) {
							setverdict(pass);
							// Step3: Send DefaultAck with correct identifier and set verdict
							f_logReceivedWaitAndAcknowledge(USERDETAILS_TIME2_MIN_TSP); // Wait minimum time to answer
							}
						else {
							setverdict(fail);
							f_addLogEntry("Incorrect authenticator");
							};
						}
					} // End of alt statement
				
				f_closeDownMtc();    
             } // TP_TSP_BASE_BV_01
        } // End of group Valid_Behaviour
         
        group Invalid_Behaviour {
			testcase TP_TSP_BASE_BI_01() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_BASE_BI_01: Verify that the TSP correctly responds to invalid aidIdentifier 
				 * @desc     in the APCI field received inside an APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
				// and in addition containing APCI parameter field containing aidIdentifier and valid RequestADU with requestedADUType=provideUserDetailsADU
				// Just modify the APCI
				template (value) ApciFields m_apciInvalidAid modifies m_apciInitTester:= {aidIdentifier:=0};
				// Then send it together with the request ADU
				v_apduForSending:=m_apduNoAuth(
					m_apciInvalidAid,
					m_adusRequestUserDetailsRandomParams
				);
  				f_sendAndLogApdu(v_apduForSending);
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = protocolVersionError (6)
				// Timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_protocolVersionError_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
			}  // End of Testcase TP_TSP_BASE_BI_01
			
			testcase TP_TSP_BASE_BI_02() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_BASE_BI_02: Verify that the TSP correctly responds to invalid apduOriginator in APCI field received inside an APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
			
				// Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
				// containing apduOriginator different from  value declared in the PIXIT
				// Retrieve and alter apduOriginator value
				var Provider apduWrongOriginator := TD_APDU_ORIGINATOR_FOR_TESTER;
				apduWrongOriginator.providerIdentifier := apduWrongOriginator.providerIdentifier + 1;
				template (value) ApciFields m_apciInvalidOriginator modifies m_apciInitTester:= {apduOriginator := apduWrongOriginator};
				// Then send it together with the request ADU
				v_apduForSending := m_apduNoAuth(
					m_apciInvalidOriginator,
					m_adusRequestUserDetailsRandomParams
				);
  				f_sendAndLogApdu(v_apduForSending);
 				               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = originatorRejected (7)
				// Timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_originatorRejected_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_BASE_BI_02

			testcase TP_TSP_BASE_BI_03() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_BASE_BI_03: Verify that the TSP correctly responds to invalid or unknown informationSenderID in APCI field received inside an APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
				// containing informationSenderID â‰  value declared in the PIXIT
				// Retrieve and alter informationSenderID value
				var Provider apduWrongSender := TD_INFORMATION_SENDER_TESTER;
				apduWrongSender.providerIdentifier := apduWrongSender.providerIdentifier + 1;
				template (value) ApciFields m_apciInvalidSender modifies m_apciInitTester:= {informationSenderID := apduWrongSender};
				// Then send it together with the request ADU
				v_apduForSending := m_apduNoAuth(
					m_apciInvalidSender,
					m_adusRequestUserDetailsRandomParams
				); 
  				f_sendAndLogApdu(v_apduForSending);
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = originatorRejected (7)
				// Timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_originatorRejected_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_BASE_BI_03
			
			testcase TP_TSP_BASE_BI_04() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_BASE_BI_04: Verify that the TSP correctly responds to an informationRecipientID in APCI field which does not address the TSP itself 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Step 1: Send Initiating APDU containing a valid RequestADU with requestedADUType=provideUserDetailsADU
				// containing informationrecipientID  different from  value declared in the PIXIT
				// Retrieve and alter informationrecipientID value
				var Provider apduWrongRecipient := INFORMATION_SENDER_ID_FOR_IUT;
				apduWrongRecipient.providerIdentifier := apduWrongRecipient.providerIdentifier + 1;
				template (value) ApciFields m_apciInvalidIuT modifies m_apciInitTester:= {informationrecipientID := apduWrongRecipient};
				// Then send it together with the request ADU
				v_apduForSending := m_apduNoAuth(
					m_apciInvalidIuT,
					m_adusRequestUserDetailsRandomParams
				); 
  				f_sendAndLogApdu(v_apduForSending);
               
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = recipientUnknown (8)
				// Timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_recipientUnknown_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_BASE_BI_04

			testcase TP_TSP_BASE_BI_05() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_BASE_BI_05: Verify that the TSP correctly responds to invalid apduIdentifier in APCI field received inside an APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// First, get the apdu to be sent in a variable to avoid apduIdentifier to be re-generated, then send the Apdu
				v_apduForSending := m_apduNoAuthInitTester(m_adusRequestUserDetailsRandomParams);
				// send RequestADU
				f_sendAndLogApdu(v_apduForSending);
                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[] mtcPort.receive(mw_apduNoAuthProvideUserDetails(v_apduForSending)) -> value v_apduReceived{
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); 
						
						// Step3: Send DefaultAck with correct identifier
						f_logReceivedWaitAndAcknowledge(USERDETAILS_TIME2_MIN_TSP);
					}
				} // End of alt statement
				
				// Step 1: Send exactly the same APDU sent previously, including the same apduIdentifier
				
				f_sendAndLogApdu(v_apduForSending);			

               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		

			}	//End of 	TP_TSP_BASE_BI_05

			testcase TP_TSP_BASE_BI_06() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_BASE_BI_06: Verify that the TSP correctly responds to an APDU which contains the nextAPDUId field  inside the APCI field 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
		    	var ApciFields v_apciInvalid := { 
		    		aidIdentifier := 1, // 12855 Protocol Version number 
		    		apduOriginator := TD_APDU_ORIGINATOR_FOR_TESTER, // Source of the content of the APDU 
		    		informationSenderID := TD_INFORMATION_SENDER_TESTER, // Sender of this content 
		    		informationrecipientID := INFORMATION_SENDER_ID_FOR_IUT,  
		    		apduIdentifier := float2int(rnd()) * 65535,
		    		previousApduId := omit,
		    		nextApduId := {TD_APDU_ORIGINATOR_FOR_TESTER,1},
		    		inResponseToApduId := omit, 
		    		apduDate :=  fx_getUtc()
		    	};

				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Then send it together with the request ADU
				v_apduForSending := m_apduNoAuth(
					v_apciInvalid,
					m_adusRequestUserDetailsRandomParams
				);
  				f_sendAndLogApdu(v_apduForSending);
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_BASE_BI_06
			
			testcase TP_TSP_BASE_BI_07() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_BASE_BI_07: Verify that the TSP correctly responds to an APDU which contains the inResponseToApduId inside the APCI field but the received APDU is not in response to a previous APDU 
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;

		    	var ApciFields v_apciInvalid := { 
		    		aidIdentifier := 1, // 12855 Protocol Version number 
		    		apduOriginator := TD_APDU_ORIGINATOR_FOR_TESTER, // Source of the content of the APDU 
		    		informationSenderID := TD_INFORMATION_SENDER_TESTER, // Sender of this content 
		    		informationrecipientID := INFORMATION_SENDER_ID_FOR_IUT,  
		    		apduIdentifier := float2int(rnd()) * 65535,
		    		previousApduId := omit,
		    		nextApduId := omit,
		    		inResponseToApduId := {TD_APDU_ORIGINATOR_FOR_TESTER,1}, 
		    		apduDate :=  fx_getUtc()
		    	};
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Step 1: Send Initiating APDU containing a valid RequestADU with APCI parameter field containing inResponseToApduId

				// Then send it together with the request ADU
				v_apduForSending := m_apduNoAuth(
					v_apciInvalid,
					m_adusRequestUserDetailsRandomParams
				);
  				f_sendAndLogApdu(v_apduForSending);
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = sequenceError (4) or apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_sequenceError_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}

				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_BASE_BI_07				

			testcase TP_TSP_BASE_BI_08() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_BASE_BI_08: Verify that the TSP correctly responds to an APDU which 
				 * @desc    contains an invalid inResponseToApduId value inside  the APCI field 
				 * @desc 	with regards to timers this is a TYPE2 transaction (see explanation 2 in CEN/TS 16986:2016 B.6)
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;				
				var boolean isCertificate:=false;
				var boolean isPublicKey:=false;
				var boolean isMacMasterOrDsrcKey := false;
				var boolean isCertificateRevocationList := false;
				var boolean v_encryptedKey;

				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc				
				
				// Send the IUT a  trigger to send one initial APDU with requestedADUType=trustObjectRequestADU and 
				// complete its transaction
				f_sendAndLogTrigger(TRUSTOBJECTS_TR_1);				

				//  Wait for request for TrustObjectAdu
				alt {
					[] mtcPort.receive(mw_apduRequestTrustObject) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();	// Do not wait to send an Ack whichever object received
						
						//Read the trustObjectPurpose received and set corresponding boolean			
						if (match(v_apduReceived, mw_apduRequestTrustObjectCertificate)) {isCertificate:=true;} 
						if (match(v_apduReceived, mw_apduRequestTrustObjectPublicKey)) {isPublicKey:=true;}
						if (match(v_apduReceived, mw_apduRequestTrustObjectGeneric)) {isCertificateRevocationList := true;}
						if (match(v_apduReceived, mw_apduRequestTrustObjectSymmetricKey)) {isMacMasterOrDsrcKey:=true;} //This request allows both MacMasterKey and DsrcKey as an answer, this test implementation will use DsrcKey
					}										
				} // End of alt statement

				// Only allowed combinations according to profile
				if (not (
					(ICS_A2_1_isDsrc and (isCertificate or isPublicKey or isMacMasterOrDsrcKey or isCertificateRevocationList) ) or			 				
					(ICS_A2_2_isGnss and (isCertificate or isPublicKey or isCertificateRevocationList))
				)) {
					setverdict(fail);
					f_addLogEntry("Invalid combination of Trust Object type and Trust Object purpose");  
					stop;
				}			 				
				

				// Get the requested purposes to send back
				var RecOfTrustObjectPurposes v_receivedPurposes := 
				v_apduReceived.infoExchangeContent.adus.requestAdus[0].trustObjectRequest.requestedTrustObject.trustObjectSpec.purposesOfTrustObject;
				
				// Get the received Trust Object type to decide whether to send an encrypted or not encrypted DSRC key
				var integer v_receivedType := 
				v_apduReceived.infoExchangeContent.adus.requestAdus[0].trustObjectRequest.requestedTrustObject.trustObjectSpec.typeOfTrustObject;

				if (v_receivedType == TrustObjectTypes_symmetricKey_) {v_encryptedKey := false;}
				if (v_receivedType == TrustObjectTypes_encryptedSymmetricKey_) {v_encryptedKey := true;}
				
				// Step 1: Send Initiating APDU containing a valid TrustObjectADU with inResponseToApduId not equal to the value of the previously sent APDU
				// Answer with the correct requested Trust Object, but using the incorrect inResponseToApduId in the apci
				var TrustObjectADU v_aduTrustObject;

				if (isCertificate) {
					v_aduTrustObject:= m_aduTrustObject(
						v_receivedPurposes,
						{certificate:={
							certificateType:=CertificateType_certTcHTTPS_,
							certificate:=TD_CERTIFICATE
						}}
					)
				} else if (isPublicKey) {
					v_aduTrustObject:= m_aduTrustObject(
						v_receivedPurposes,
						{publicKey:=TD_PUBLICKEY}
					)
				} else if (isCertificateRevocationList) {
				 	v_aduTrustObject:= m_aduTrustObject(
				 		v_receivedPurposes, 
				 		{otherTrustObject:={
							typeOfTrustObject:=TrustObjectTypes_crl_,
							genericTrustObject:=TD_CERT_REVOKE_LIST
				 		}}
				 	)
				 } if (isMacMasterOrDsrcKey) { 				
					 //According to the current version of the 12855 or 16986, there is no way to request a MAC or DSRC key is to be sent. Using symmetric key provisionally 
		
					if (v_encryptedKey) {
						v_aduTrustObject:= m_aduTrustObject(v_receivedPurposes,{dsrcMasterKeys:=TD_SYMMETRIC_KEY_ENCRYPTED});
					} else { 
						v_aduTrustObject:= m_aduTrustObject(v_receivedPurposes,{dsrcMasterKeys:=TD_SYMMETRIC_KEY});
					}
				} else {
					setverdict(fail);
					f_addLogEntry("None of the expected Trust Objects requested");  
					stop;
				}	
					 							
				//Prepare a faulty inResponseTo-field. The originator is set to the Tester value which CANNOT be correct.
				//TODO Ulrik is it, or is it not allowed to put back a field that has previously been excluded?
				template (value) ApciFields m_apciInvalidInRespTo modifies m_apciInitTester:= {
					inResponseToApduId := {
						TD_IDENTIFIER,
						0
					}
				};
				
				v_apduForSending := m_apduNoAuth(
					m_apciInvalidInRespTo,
					{trustObjectAdus:={v_aduTrustObject}}
				);
				f_sendAndLogApdu(v_apduForSending);
				
               //Set timer
				t_step.start(TRUSTOBJECTS_TYPE2_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = sequenceError (4) or apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_sequenceError_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE2_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE2_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}

				} 
				f_closeDownMtc(); 		
				
			} //End of TP_TSP_BASE_BI_08
			
			testcase TP_TSP_BASE_BI_09() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_BASE_BI_09: Verify that the TSP correctly responds to an invalid apduDate inside the 
				 * @desc	APCI field of a received APDU
				 * @remark  [16986:2016], Clause 6.2.1 and Table A.1/2 
				 */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Step 1: Send an Initiating_Apdu containing APCI parameter field with apduDate = invalid
				// and valid RequestADU with requestedADUType=provideUserDetailsADU

				template (value) ApciFields m_apciInvalidDate modifies m_apciInitTester:= {apduDate := fx_getUtc(-31536000)}; //set date to one year ago
				// Then send it together with the request ADU
				v_apduForSending := m_apduNoAuth(
					m_apciInvalidDate,
					m_adusRequestUserDetailsRandomParams
				);
  				f_sendAndLogApdu(v_apduForSending);

               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
				
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
				} 
				f_closeDownMtc(); 												
			}	//End of 	TP_TSP_BASE_BI_09

			testcase TP_TSP_BASE_BI_10() runs on MainTestComponent system TestAdapter {
             /**
              * @desc    TP_TSP_BASE_BI_10: Verify that the TSP correctly responds to an APDU bearing an incorrect infoExchangeAuthenticator 
              * @remark  [16986:2016], Clause 6.2.2 and 6.3.2 and Table A.1/2 
              */
               // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS and ICS_A3_3_useAuthenticator;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Step 1: Send an Initiating_Apdu containing invalid authenticator
				// and valid RequestADU with requestedADUType=provideUserDetailsADU

				// Set up a correct apdu without authenticator to start with		
				v_apduForSending:= m_apduAuthInitTester(m_adusRequestUserDetailsRandomParams);

				// Get a correctly computed authenticator, then corrupt it				
				var ApduAuthenticator authenticator:= v_apduForSending.infoExchangeAuthenticator;
				// First, get the value to be corrupted from the complex authenticator field
				var octetstring hashedMessageContent := authenticator.authenticatorEfc.tbsAuthenticatorEfc.apduContentDigest.hashedMessageContent;
				// Then add 1
				var integer v_lengthOfHash:=lengthof(hashedMessageContent);
				var octetstring corruptedhashedMessageContent := int2oct(oct2int(hashedMessageContent)+1,v_lengthOfHash);
				// Finally, substitute the corrupted part into the correct authenticator
				authenticator.authenticatorEfc.tbsAuthenticatorEfc.apduContentDigest.hashedMessageContent := corruptedhashedMessageContent;
				// Then send it together with the request ADU
				v_apduForSending.infoExchangeAuthenticator:= authenticator;
  				
  				f_sendAndLogApdu(v_apduForSending);
                        
               //Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for NAck_Apdu containing ackADU with apduAckCode = apduNotOk (3)
				// Timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckProtocolIut(v_apduForSending, ApduReasonCode_apduNotOK_)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); //No minimum time to check for response
						setverdict(pass);
					}
				} 
				f_closeDownMtc();    
             } // TP_TSP_BASE_BI_10					
        } // End of group Invalid_Behaviour
        
    } // End of group Base
    
	group USERDETAILS {
		group Valid_Behaviour {
			testcase TP_TSP_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
            	 	          
				/**
				 * @desc    TP_TSP_USERDETAILS_BV_01: Verify that the TSP correctly receives an APDU 
				 * @desc    containing valid RequestADUs and provides valid ProvideUserDetailsADUs 
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
                   
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				            
				// Step1: send RequestADU
				f_sendAndLogApdu(m_apduNoAuthInitTester(m_adusRequestUserDetailsRandomParams));
                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[] mtcPort.receive(mw_apduNoAuthProvideUserDetails(v_apduForSending)) -> value v_apduReceived{
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); 
	
						for (
							var integer v_loop:=0;
							v_loop<lengthof(v_apduReceived.infoExchangeContent.adus.provideUserDetailsADUs[0].listOfUserParameters);
							v_loop:=v_loop+1
						){
							if (not(match(
								v_apduReceived.infoExchangeContent.adus.provideUserDetailsADUs[0].listOfUserParameters[v_loop],
								mw_userParameterResponseAvailable
							))){
								setverdict(fail);
								f_addLogEntry("listOfUserParameters incorrect.");
								stop; 	
							}
					  	}
					}
				} // End of alt statement				
				setverdict(pass);
	    		f_logReceivedWaitAndAcknowledge(USERDETAILS_TIME2_MIN_TSP);
				f_closeDownMtc();  
			
			} // End of TP_TSP_USERDETAILS_BV_01
            
			testcase TP_TSP_USERDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
				/**
				 * @desc    TP_TSP_USERDETAILS_BV_02: TP_TSP_USERDETAILS_BV_02: Verify that the TSP correctly receives a RequestADU of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of data privacy issues  
				 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
				 */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Check if there are parameters that are privacy bound
				// If not, exit test
				if (sizeof (TD_PRIVACYBOUND_USER_PARAM_REQS) == 0) {
					setverdict(inconc);
					f_addLogEntry("Privacy bound parameters missing. Test cannot be executed");
					stop;
					};
                
				// Step1: send RequestADU
				
				v_apduForSending := m_apduNoAuthInitTester({requestAdus:={m_aduRequestProvideUserDetails(TD_PRIVACYBOUND_USER_PARAM_REQS)}});
				f_sendAndLogApdu(v_apduForSending);   	  
                                
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU or the timeout expires
				// timeout expiration is handled in the altstep branch
				// The received Provide Use Details ADU shall have status flag = 2, and an empty list of user details

				alt {
					[] mtcPort.receive(mw_apduNoAuthProvideUserDetails(v_apduForSending)) -> value v_apduReceived{
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP);
 						                        

						if (not match(
							v_apduReceived.infoExchangeContent.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU : modifies mw_aduProvideUserDetails := {
								statusFlag:=UserStatus_standardCommercialUserContract_,
								listOfUserParameters := omit
							}
						)) {
							setverdict(fail);
							f_addLogEntry("Incorrect ADU received: expected listOfUserParameters empty and statusFlag = 2 ");
							stop;
						}
					}	
				} // End of alt statement				

				// Step3: Send DefaultAck with correct identifier
				setverdict(pass);						
				f_logReceivedWaitAndAcknowledge(USERDETAILS_TIME2_MIN_TSP);
				
				f_closeDownMtc();  
			
			} // End of TP_TSP_USERDETAILS_BV_02
		} // End of group Valid_Behaviour
        
		group Invalid_Behaviour {
		 	testcase TP_TSP_USERDETAILS_BI_01() runs on MainTestComponent system TestAdapter {
             
			  /**
			  * @desc    TP_TSP_USERDETAILS_BI_01: Verify that the TSP correctly responds to an incorrect RequestADU of type userDetailsRequest 
			  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
			  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
             
				// Step 1: Send APDU with 2 incorrect ADUs, the first one without userDetails, the second one with empty userDetails
				var InfoExchange v_apduToSend:= 
				m_apduNoAuthInitTester(
					{requestAdus:={m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails({})}}
				);
				
				f_sendAndLogApdu(v_apduToSend);                               

				// Step 2: wait for a Invalid ADU Error code NAck 
				t_step.start(USERDETAILS_TIME1_MAX_TSP);

				// Either we receive an APDU containing NAck with invalid adu  as error code or the timeout expires
				// timeout expiration handling is in the altstep branch				

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduToSend, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(
						v_apduToSend, 
						{{issueADUStruct:=1, issueCode:=AduReasonCode_invalidADU_},{issueADUStruct:=2,issueCode:=AduReasonCode_invalidADU_}}
					)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();  

			 } // End of testcase TP_TSP_USERDETAILS_BI_01
            
			testcase TP_TSP_USERDETAILS_BI_02() runs on MainTestComponent system TestAdapter {
            
			  /**
			  * @desc    TP_TSP_USERDETAILS_BI_02: Verify that the TSP correctly handles a RequestADUs of type userDetailsRequest with 
			  * listOfUsersParametersRequested containing non-supported user details
			  * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
			  */          
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc             

				// Front End shall initially receive a Request named as Transaction sequence #1
				// Find a parameter whose value  is not supported by the IUT
				// Prepare the list of requested parameters with one element which is unsupported

				var integer v_notSupportedUserDetailsParameter;
				for (
					v_notSupportedUserDetailsParameter := 0; 
					v_notSupportedUserDetailsParameter < 28; //There are defined values numbered 0 to 27 in the UserParameterRequest
					v_notSupportedUserDetailsParameter := v_notSupportedUserDetailsParameter + 1
				) {
					if (
							match(v_notSupportedUserDetailsParameter, complement(all from USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS))
					) {break;}
				};

				// If IUT implements all possible details, the test cannot be run				
				if (sizeof(USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS) == 27) {
					setverdict(inconc);
					f_addLogEntry("All user details supported by IUT. Test cannot be executed");
					stop;
				};				
				v_apduForSending := m_apduNoAuthInitTester(
					{requestAdus:={m_aduRequestProvideUserDetails({v_notSupportedUserDetailsParameter})}}
				);
				f_sendAndLogApdu(v_apduForSending);                              
                                
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU or the timeout expires
				// timeout expiration is handled in the altstep branch
				// The received Provide Use Details ADU shall have status flag = 1, and no  list of user details

				alt {
					[] mtcPort.receive(mw_apduNoAuthProvideUserDetails(v_apduForSending)) -> value v_apduReceived{
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						if (sizeof(v_apduReceived.infoExchangeContent.adus.provideUserDetailsADUs) > 1 )
						  {
							setverdict (fail);
						  	f_addLogEntry("Only one ADU expected. "&any2unistr(sizeof(v_apduReceived.infoExchangeContent.adus.provideUserDetailsADUs))&" ADUs received instead.");							
							stop;
						  }
						if (not match(
							v_apduReceived.infoExchangeContent.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU: modifies mw_aduProvideUserDetails := {
								listOfUserParameters:= {{
									requestedUserParameter := omit,
									userParameterStatus := UserParameterStatus_notAvailable_
								}}
							}
						)) 
						{
						  setverdict(fail);
						  f_addLogEntry("Incorrect ADU received: ");
						  stop;
						  }
							
						// Step3: Send DefaultAck with correct identifier
						f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						
						}
					} // End of alt statement
                
				f_closeDownMtc();  
                			
				} // End of testcase TP_TSP_USERDETAILS_BI_02 

            testcase TP_TSP_USERDETAILS_BI_03() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_03: Verify that the TSP correctly receives a RequestADUs of type userDetailsRequest 
			  * @desc    with listOfUsersParametersRequested containing user details that cannot be provided because of missing agreement
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */       
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Check if there are parameters that are privacy bound
				// If not, exit test
				if (sizeof (USERDETAILS_NOT_AGREED_LIST) == 0) {
					setverdict(inconc);
					f_addLogEntry("Not agreed parameters missing. Test cannot be executed");
					stop;
					};                
				// Step1: send RequestADU
				
				v_apduForSending := m_apduNoAuthInitTester({requestAdus:={m_aduRequestProvideUserDetails(USERDETAILS_NOT_AGREED_LIST)}});
				f_sendAndLogApdu(v_apduForSending);   	  
                                		
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);

               // Step #2: Wait for empty User Details
				// Either we receive an APDU containing empty User Details or the timeout expires
				// timeout expiration handling is in the altstep branch	
                alt {
					[] mtcPort.receive(mw_apduNoAuthProvideUserDetails(v_apduForSending)) -> value v_apduReceived{
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
				
						if (not match(
							v_apduReceived.infoExchangeContent.adus.provideUserDetailsADUs[0],						
							ProvideUserDetailsADU: modifies mw_aduProvideUserDetails := {
								userId := {},
								statusFlag:=UserStatus_standardCommercialUserContract_,
								listOfUserParameters:={ //Condition: Mandatory if statusFlag is 1 to 5. Shall not be used if status flag is 0,6 or 7.
									{
										requestedUserParameter:=omit,
										userParameterStatus := UserParameterStatus_missingContractualAgreement_,
										userInfoValidityPeriod:=omit,
										userParameterResponse :=*
									}
								}
							}
						)) {
						  setverdict(fail);
						  f_addLogEntry("Incorrect ADU received");
						  stop;
						}
                    }
                } // End of alt statement

				f_closeDownMtc();  
 
            } // End of TP_TSP_USERDETAILS_BI_03
            
            testcase TP_TSP_USERDETAILS_BI_04() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_04: Verify that a TSP responds correctly to a 
              * @desc    RequestADU sent earlier than allowed 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */
				// Initialisation
				if (USERDETAILS_TIMEA_MIN_TSP == 0.0)	{
					setverdict(inconc);
					f_addLogEntry("Cannot perform minimum time test because IUT sets it to 0");
					stop;			  
				};			
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				             
				// Step1: send RequestADU
				f_sendAndLogApdu(m_apduNoAuthInitTester({requestAdus:={m_aduRequestProvideUserDetails(f_userDetailsParameters())}}));
       			// Send again immediately new ADU with different ADPU-id (randomly assigned by the template)
				v_apduForSending := 
				m_apduNoAuthInitTester({requestAdus:={m_aduRequestProvideUserDetails(f_userDetailsParameters())}});
				f_sendAndLogApdu(v_apduForSending);
                               
				//Set timer
				t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step #2: Wait for NAck ADU				 					
				// Either we receive an APDU containing  NAck or the timeout expires
				// timeout expiration is handled in the altstep branch
				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(USERDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
                	} // End of alt statement
				f_closeDownMtc();  			
        	} // End of TP_TSP_USERDETAILS_BI_04

        } // End of group Invalid_Behaviour
 
    } // End of group USERDETAILS

    group LISTOFUSERS {
         group Valid_Behaviour {

             testcase TP_TSP_LISTOFUSERS_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BV_01: Verify that the TSP correctly receives an APDU containing valid 
				  * @desc    RequestADUs and provides valid ProvideUserIdListADUs with available user Id data 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				v_apduForSending := m_apduNoAuthInitTester({requestAdus:={m_aduRequestListOfUsers}});
				f_sendAndLogApdu(v_apduForSending);

				// Set timer
                t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for UserList ADU
				// Either we receive an APDU containing  User List ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch

                alt {
                	[] mtcPort.receive(mw_apduProvideUserIdList(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
 						
 						//Check whether the list of users contains elements
 						//If not, set verdict fail
						if (
							(lengthof(v_apduReceived.infoExchangeContent.adus.provideUserIdListADUs[0].userIdList) == 0)){
							f_addLogEntry("Empty user list received");
							setverdict(fail);
							stop;
						};                        
                        if ((v_apduReceived.infoExchangeContent.adus.provideUserIdListADUs[0].userIdList[0] != PX_USER_ID_RELATED) or
                        	(sizeof(v_apduReceived.infoExchangeContent.adus.provideUserIdListADUs[0].userIdList)!=1)
                        ) {
                          	f_addLogEntry("Wrong User ID or too many User IDs received");
                          	setverdict(fail);
                          	stop;
                        };
                        // Step #3: Send DefaultACK with correct identifier                        
						f_waitAndAcknowledgeReceivedApdu(LISTOFUSERS_TIME2_MIN_TSP);
						
                 	}
                } // End of alt statement
				f_closeDownMtc();  

             } // End of TP_TSP_LISTOFUSERS_BV_01           

             testcase TP_TSP_LISTOFUSERS_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BV_02: Verify that the TSP correctly receives an APDU containing valid RequestADUs to user Id data not available and provides valid ProvideUserIdListADUs 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				v_apduForSending := m_apduNoAuthInitTester({requestAdus:={
					m_aduRequestListOfUsers(PX_USER_ID_NO_RELATED)
				}});
				f_sendAndLogApdu(v_apduForSending);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for UserList ADU
				// Either we receive an APDU containing  User List ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch

                 alt {
                      [] mtcPort.receive(mw_apduProvideUserIdList(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
 						//	Check whether the list of users contains elements
 						// If yes, set verdict fail		                              
                        if (lengthof(v_apduReceived.infoExchangeContent.adus.provideUserIdListADUs[0].userIdList) > 0) {
                          	f_addLogEntry("Not empty user list received");
                          	setverdict(fail);
                          	stop;
                        };
                        // Step #3: Send DefaultACK with correct identifier
						f_logReceivedWaitAndAcknowledge(USERDETAILS_TIME2_MIN_TSP);
                      	}
                    } // End of alt statement
				
				f_closeDownMtc();  

             } // End of TP_TSP_LISTOFUSERS_BV_02  		
 		
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
			  testcase TP_TSP_LISTOFUSERS_BI_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_01: Verify that the TSP correctly receives an invalid requestADU with userIdRequestType not equal to 0 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				var integer wrongUserIdRequestType := float2int(rnd() * 254.0) + 1; // Any casual number different from 0
				
				// Save the apdu to be sent to check later in the received NAck
				v_apduForSending := m_apduNoAuthInitTester({requestAdus:={m_aduRequestListOfUsers}});
				v_apduForSending.infoExchangeContent.adus.requestAdus[0].userListRequest.userIdRequestType := 100; //Only allowed value according to CEN/TS 16986 is 0
				f_sendAndLogApdu(v_apduForSending);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for NAck ADU				 					
				// Either we receive an APDU containing  NAck or the timeout expires
				// timeout expiration is handled in the altstep branch

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsDouble(1, AduReasonCode_invalidADU_,2,AduReasonCode_invalidADU_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();  			
			} // End of TP_TSP_LISTOFUSERS_BI_01
             
			testcase TP_TSP_LISTOFUSERS_BI_02() runs on MainTestComponent system TestAdapter {
             
                /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_02: Verify that the TSP correctly receives an invalid request ADU with no PAN, LicensePlateNumber, OBEID or ContractSerialNumber present in the userId field 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */

				//Declaration
				var RequestADU v_aduRequestInvalid;

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				// Save the apdu to be sent to check later in the received NAck
				v_aduRequestInvalid:=m_aduRequestListOfUsers;
				v_aduRequestInvalid.userListRequest.userId := {}; // Set time to the future, ie invalid
				
				v_apduForSending := m_apduNoAuthInitTester({requestAdus:={v_aduRequestInvalid}});	
					
				f_sendAndLogApdu(v_apduForSending);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for NAck ADU				 					
				// Either we receive an APDU containing  NAck or the timeout expires
				// timeout expiration is handled in the altstep branch

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsDouble(1, AduReasonCode_invalidADU_,2,AduReasonCode_invalidADU_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();		
             } // End of TP_TSP_LISTOFUSERS_BI_02
             
			  testcase TP_TSP_LISTOFUSERS_BI_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_03: Verify that the TSP correctly receives an invalid request ADU with userIdRequestTime not present 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				// Initialisation
				var RequestADU v_aduRequestInvalid;
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user who has no other userids
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				// Save the apdu to be sent to check later in the received NAck			
				v_aduRequestInvalid:=m_aduRequestListOfUsers;
				v_aduRequestInvalid.userListRequest.userIdRequestTime:=omit; // Set time to the future, ie invalid
				
				v_apduForSending := m_apduNoAuthInitTester({requestAdus:={v_aduRequestInvalid}});
									
				f_sendAndLogApdu(v_apduForSending);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for NAck ADU				 					
				// Either we receive an APDU containing  NAck or the timeout expires
				// timeout expiration is handled in the altstep branch

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsDouble(1, AduReasonCode_invalidADU_,2,AduReasonCode_invalidADU_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();				
			} // End of TP_TSP_LISTOFUSERS_BI_03
             
			  testcase TP_TSP_LISTOFUSERS_BI_04() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_04: Verify that the TSP correctly receives an invalid request ADU with invalid userIdRequestTime 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */
				var RequestADU v_aduRequestInvalid;
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				// Save the apdu to be sent to check later in the received NAck					
				v_aduRequestInvalid:=m_aduRequestListOfUsers;
				v_aduRequestInvalid.userListRequest.userIdRequestTime:=fx_getUtc(3600); // Set time to the future, ie invalid
				
				v_apduForSending := m_apduNoAuthInitTester({requestAdus:={v_aduRequestInvalid}});
				f_sendAndLogApdu(v_apduForSending);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for NAck ADU				 					
				// Either we receive an APDU containing  NAck or the timeout expires
				// timeout expiration is handled in the altstep branch

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(
						v_apduForSending,  
						m_roNackParamsDouble(1, AduReasonCode_invalidADU_,2,AduReasonCode_invalidADU_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();  			
 
             } // End of TP_TSP_LISTOFUSERS_BI_04
             
			  testcase TP_TSP_LISTOFUSERS_BI_05() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_LISTOFUSERS_BI_05: Verify that a TSP responds correctly to a RequestADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 6.5 and Table A.1/2 AND Table A.7/2  
                  */

				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_2_implementedLISTOFUSERS;
				if (LISTOFUSERS_TIMEA_MIN_TSP == 0.0)	{
					setverdict(inconc);
					f_addLogEntry("Cannot perform minimum time test because IUT sets it to 0");
					stop;			  
				};			
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 
				// we want to ask for all userids of a given user
				// IUT shall initially receive a Request as per Transaction sequence #1

				// Prepare and send the record of ADUs with 1 ADU
				f_sendAndLogApdu(m_apduNoAuthInitTester({requestAdus:={m_aduRequestListOfUsers}}));

				//Send same request again in new APDU
				v_apduForSending :=m_apduNoAuthInitTester({requestAdus:={m_aduRequestListOfUsers}});
				f_sendAndLogApdu(v_apduForSending);

				// Set timer
                 t_step.start(LISTOFUSERS_TIME1_MAX_TSP);
				// Step #2: Wait for NAck ADU				 					
				// Either we receive an APDU containing  NAck or the timeout expires
				// timeout expiration is handled in the altstep branch
				
				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(LISTOFUSERS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();  			

             } // End of TP_TSP_LISTOFUSERS_BI_05
                      
           } // End of group Invalid_Behaviour
        
    } // End of group LISTOFUSERS
    
    group EXCEPTIONLIST {
         group Valid_Behaviour {
           testcase TP_TSP_EXCEPTIONLIST_BV_01() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_EXCEPTIONLIST_BV_01: Verify that the TSP correctly performs an EXCEPTIONLIST transaction for blacklist and whitelist 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 AND Table A.7/3 
              */
				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Step 1a: Trigger IUT with EXCEPTIONLIST.TR_TSP_1 LIST_TYPE=BLACK
				f_sendAndLogTrigger(EXCEPTIONLIST_TR_TSP_1_BLACK);

				//  Wait for EXCEPTIONLIST with LIST_TYPE=BLACK
                t_step.start(EXCEPTIONLIST_BLACK_TIME1_MAX_TSP);
				alt {
					[] mtcPort.receive(mw_apduExceptionListOneBlackList) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(EXCEPTIONLIST_BLACK_TIME1_MIN_TSP); 
					}
				} // End of first alt statement
					
				// Step 1b: Trigger IUT with EXCEPTIONLIST.TR_TSP_1 LIST_TYPE=WHITE within time constraints
				f_sendAndLogTrigger(EXCEPTIONLIST_TR_TSP_1_WHITE);

				//  Wait for EXCEPTIONLIST with LIST_TYPE=WHITE
                t_step.start(EXCEPTIONLIST_WHITE_TIME1_MAX_TSP);
				alt {
					[] mtcPort.receive(mw_apduExceptionListOneWhiteList) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(EXCEPTIONLIST_WHITE_TIME1_MIN_TSP); 
						setverdict(pass);						
					}
 				} // End of second alt statement
				f_closeDownMtc();   						           
           } // End of TP_TSP_EXCEPTIONLIST_BV_01
           
           testcase TP_TSP_EXCEPTIONLIST_BV_02() runs on MainTestComponent system TestAdapter {
             
              /**
              * @desc    TP_TSP_EXCEPTIONLIST_BV_02: Verify that the TSP correctly performs an EXCEPTIONLIST 
			  * @desc    transaction for discounted users 
              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 AND Table A.7/3 
              */
				// Initialisation
				var ExceptionListADU v_theAdu;
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_3_implementedEXCEPTIONLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Step 1: Trigger IUT with EXCEPTIONLIST.TR_TSP_1 LIST_TYPE=DISCOUNT
				f_sendAndLogTrigger(EXCEPTIONLIST_TR_TSP_1_DISCOUNT);
				//  Wait for EXCEPTIONLIST with LIST_TYPE=DISCOUNT
                t_step.start(EXCEPTIONLIST_DISCOUNT_TIME1_MAX_TSP);

				alt {
					[] mtcPort.receive(mw_apduExceptionListOneDiscountedList) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						// Exception List shall have a vatId	
						v_theAdu:=v_apduReceived.infoExchangeContent.adus.exceptionListADUs[0];		
               			for (var integer v_loop:=0;v_loop<lengthof(v_theAdu.exceptionListEntries);v_loop:=v_loop+1){
               				if (not(ispresent(v_theAdu.exceptionListEntries[v_loop].vatId))){
								f_addLogEntry("No vatId present");
	               				setverdict(fail);
	               				stop;
               				}
               			}
					} 
				} // End of alt statement
				// Send Ack within time constraints

				f_logReceivedWaitAndAcknowledge(EXCEPTIONLIST_DISCOUNT_TIME1_MIN_TSP);
				setverdict(pass);

				f_closeDownMtc(); 
				              
           } // End of TP_TSP_EXCEPTIONLIST_BV_02		
 		
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {	
           // No Invalid Behaviour Test Cases defined	
        } // End of group Invalid_Behaviour

    } // End of group EXCEPTIONLIST
    
    
//    group TRUSTOBJECTS {
//         group Valid_Behaviour {
//           
//         testcase TP_TSP_TRUSTOBJECTS_BV_01() runs on MainTestComponent system TestAdapter {
//              /**
//              * @desc    TP_TSP_TRUSTOBJECTS_BV_01: Verify that the TSP correctly provides a TrustObjectADU without TC request
//              * @remark  [16986:2016], Clause 6.6 and Table A.1/2
//              * @remark  Same as  TP_TC_TRUSTOBJECTS_BV_01
//              */
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				
//				var boolean isCertificateOrPublicKey:=false;
//				var boolean isDsrcKeyRef := false;
//				var boolean isMacMasterKey := false;
//				var boolean isDsrcMasterKey := false;
//				var boolean isCertificateRevocationList := false;
//				var boolean isDsrcKey:=false;
//				
//				var integer objectsReceived := 0;
//				// Step 1: Trigger IUT with TRUSTOBJECTS_TR_2
//				f_sendAndLogTrigger(TRUSTOBJECTS_TR_2);
//
//				//  Wait for TRUSTOBJECTS
//				// We expect to receive as many APDUs containing TRUSTOBJECTS ADUs as the number of declared supported trust objects
//				alt {
//					[] mtcPort.receive(mw_apduTrustObjectInit) -> value v_apduReceived {
//						//send Ack whichever object received
//						f_logReceivedWaitAndAcknowledge(v_apduReceived); 							
//						// Look at the type of Trust Object received and set the related variable 				
//						if (match(v_apduReceived.infoExchangeContent.adus, mw_adusTrustObjectCertificate)) 
//						{isCertificateOrPublicKey:=true;}
//						if (match(v_apduReceived.infoExchangeContent.adus, mw_adusTrustObjectPublicKey)) 
//						{isCertificateOrPublicKey:=true;}
//						if (match(v_apduReceived.infoExchangeContent.adus, mw_adusTrustObjectGeneric))
//						{isCertificateRevocationList := true;}
//						if (match(v_apduReceived.infoExchangeContent.adus, mw_adusTrustObjectDsrcKeyRef)) 
//						{isDsrcKeyRef:=true;}
//						if (match(v_apduReceived.infoExchangeContent.adus, mw_adusTrustObjectMacKey)) 
//						{isMacMasterKey:=true;}
//						if (match(v_apduReceived.infoExchangeContent.adus, mw_adusTrustObjectDsrcKey)) 
//						{isDsrcKey:=true;}
//	
//						objectsReceived := objectsReceived + 1; // Count the number of trust objects received
//						if (objectsReceived < sizeof(SENT_TRUST_OBJECTS_SUPPORTED)) {
//							repeat;
//						}
//					}										
//				} // End of alt statement
//				// Exiting the alt means that the expected number of Trust Objects have been received
//
//				if (ICS_A2_1_isDsrc and isCertificateOrPublicKey and isDsrcKeyRef and isMacMasterKey and isDsrcMasterKey) {
//					setverdict(pass);
//				}			 				
//				if (ICS_A2_2_isGnss and isCertificateOrPublicKey and isDsrcKeyRef){
//					setverdict(pass);
//				}			 				
//				f_closeDownMtc();              
//           } // End of TP_TSP_TRUSTOBJECTS_BV_01
//
//           testcase TP_TSP_TRUSTOBJECTS_BV_02() runs on MainTestComponent system TestAdapter {
//             
//              /**
//              * @desc    TP_TSP_TRUSTOBJECTS_BV_02: Verify that the TSP correctly responds to 
//              * @desc	 a TrustObjectADU received from a TC without having issued a request 
//              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
//              * @remark  Same as TP_TC_TRUSTOBJECTS_BV_02
//              */
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				
//                 // Step 1: Send one valid APDU containing the a valid TrustObjectADU with the only mandatorily supported type in both profiles, for all possible purposes
//				//TODO Fausto what is the DSRCRF_OBJECT_TESTER_VALUE supposed to be, could it be a constant instead? Why four trust object purposes 
//				var InfoExchange v_apduForSending := m_apduNoAuthInitTester(
//					m_aduTrustObject(
//						{
//							TrustObjectPurposes_dSRCCharging_,
//							TrustObjectPurposes_dSRCAC_,
//							TrustObjectPurposes_oBEInterrogation_,
//							TrustObjectPurposes_oBEInterrogationAC_
//						}, 
//						DSRCRF_OBJECT_TESTER_VALUE
//					)
//				);                 
//				f_sendAndLogApdu(v_apduForSending);                 
//                 // Step 2: Wait for positive Ack within TRUSTOBJECTS.TIME2
//				// Set timer
//                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                 
//				alt {
//					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME2_MIN_TSP);
//						setverdict(pass);
//						} 
//					} // End of Alt statement 
//				f_closeDownMtc();                  
//             
//           } // End of TP_TSP_TRUSTOBJECTS_BV_02
//
//           testcase TP_TSP_TRUSTOBJECTS_BV_03() runs on MainTestComponent system TestAdapter {
//             
//              /**
//              * @desc    TP_TSP_TRUSTOBJECTS_BV_03: Verify that the TSP correctly provides a TrustObjectADU following a TC request 
//              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
//              * @remark  Same as TP_TC_TRUSTOBJECTS_BV_03
//              */
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				// Loop in all available types of trustobject supported by the IUT as specified by the length of SENT_TRUST_OBJECTS_SUPPORTED Pixit record
//				var integer v_trustObjectsToBeSent := sizeof(SENT_TRUST_OBJECTS_SUPPORTED);
//				for (var integer v_trustObjectsReceived :=1; v_trustObjectsReceived<v_trustObjectsToBeSent;v_trustObjectsReceived:=v_trustObjectsReceived+1)
//					{
//						// Prepare a request of a Trust Object by taking allowed type and purpose from the RECEIVED_TRUST_OBJECTS_SUPPORTED Pixit value
//						
//						var integer v_requestedTrustObjectType := SENT_TRUST_OBJECTS_SUPPORTED[v_trustObjectsReceived].trustObjectType;
//						var TrustObjectPurposes v_requestedTrustObjectPurposes := SENT_TRUST_OBJECTS_SUPPORTED[v_trustObjectsReceived].trustObjectPurpose;
//						
//						var InfoExchange v_apduRequestForTrustObject := m_apduNoAuth(
//							m_apciInitTester, Adus:{
//								requestAdus:= {
//									requestedADUType:= 3,
//									requestedTrustObject:={
//										trustObjectSpec:={
//											typeOfTrustObject := v_requestedTrustObjectType,
//					    					purposesOfTrustObject := v_requestedTrustObjectPurposes
//					    				}
//									}
//								}
//							}
//						); //TODO Consider moving definition to Templates.ttcn
//						
//						f_sendAndLogApdu(v_apduRequestForTrustObject);
//			
//						// Set timer
//                		 t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TSP);
//						// Step #2: Wait for TrustObjects ADU
//						// Either we receive an APDU containing  TrustObject or the timeout expires
//                 		alt {
//                      		[] mtcPort.receive(mw_apduTrustObject) -> value v_apduReceived {
//								f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP);  
//
//                        		// Step #3: Send DefaultACK with correct identifier
//								f_logReceivedWaitAndAcknowledge(TRUSTOBJECTS_TYPE1_TIME2_MIN_TSP);
//                      			}
//                    		} // End of alt statement
//						}; // end of for statement
//				//Set verdict
//				setverdict(pass);
//				f_closeDownMtc(); 
//				 
//           } // End of TP_TSP_TRUSTOBJECTS_BV_03
//
//           testcase TP_TSP_TRUSTOBJECTS_BV_04() runs on MainTestComponent system TestAdapter {
//             
//              /**
//              * @desc    TP_TSP_TRUSTOBJECTS_BV_04: Verify that the TSP correctly requests and responds to a TrustObjectADU
//              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
//              * @remark  Same as TP_TC_TRUSTOBJECTS_BV_04
//              */
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				
//				// Step 1: Trigger IUT with TRUSTOBJECTS_TR_1
//				f_sendAndLogTrigger(TRUSTOBJECTS_TR_1);
//				//  Wait for request for TRUSTOBJECTS
//				// Loop in all available types of trustobject requested supported by the IUT by repeating receive
//				var integer v_expectedTrustObjectRequests := sizeof(SENT_TRUST_OBJECTS_SUPPORTED);
//				var integer v_receivedTrustObjects := 0;
//				// Set timer
//                t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TSP);                 
//				alt {
//					[] mtcPort.receive(mw_apduRequestTrustObject) -> value v_apduReceived {
//						// Log what we received
//						f_logApduReceivedAndTStep();
//						t_step.stop;
//						v_receivedTrustObjects := v_receivedTrustObjects + 1;
//                		// Step 1: Send one valid APDU containing one valid TrustObjectADU
//
//						// Analysis of what requested and what to be sent						
//						if (ispresent(v_apduReceived.infoExchangeContent.adus.requestAdus.trustObjectRequest.requestedTrustObject.trustObjectId)) {
//							f_addLogEntry("Received a request for a specific TrustObjectId, this is not supported according to CEN/TS 16986:2016");
//							setverdict(fail);
//							stop;					
//						}
//						var TrustObjectSpec v_requestedTrustObjectSpec := v_apduReceived.infoExchangeContent.adus.requestAdus.trustObjectRequest.requestedTrustObject.trustObjectSpec;
//						var TrustObjectTypes v_requestedTrustObjectType := v_requestedTrustObjectSpec.typeOfTrustObject;
//						var RecOfTrustObjectPurposes v_requestedTrustObjectPurposesRecords := v_requestedTrustObjectSpec.purposesOfTrustObject;
//						var InfoExchange v_apduToSend;
//															
//						select (v_requestedTrustObjectType) {
//							case (TrustObjectTypes_certificate_){
//								v_apduToSend := m_apduTrustObjectResponse(
//									v_apduReceived, 
//									v_requestedTrustObjectPurposesRecords,
//									TD_CERTIFICATE			
//								);
//							}
//							case (TrustObjectTypes_publicKey_){
//								v_apduToSend := m_apduTrustObjectResponse(
//									v_apduReceived, 
//									v_requestedTrustObjectPurposesRecords,
//									TD_PUBLICKEY
//								);                 												
//							}
//							case (TrustObjectTypes_symmetricKey_){
//								v_apduToSend := m_apduTrustObjectResponse(
//									v_apduReceived, 
//									v_requestedTrustObjectPurposesRecords,
//									//TODO Fausto, what is this supposed to be? TD_DSRCKEY_OBJECT is not defined
//									TD_DSRCKEY_OBJECT
//								);                 												
//							}
//							case else {
//								f_addLogEntry("Received a request trust object type other than certificate, publicKey or symmetricKey, this is not allowed according to CEN/TS 16986:2016");
//								setverdict(fail);
//								stop;					
//							}
//						};						
//
//						f_sendAndLogApdu(v_apduToSend);                 
//                
//                		// Step 2: Wait for positive Ack within TRUSTOBJECTS.TIME2
//						// Set timer
//                 		t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                 
//						alt {
//							[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToSend)) -> value v_apduReceived {
//								// Log what we received
//								f_logApduReceivedAndTStep();
//								t_step.stop;
//							}
//						} // End of second alt 
//					
//						if (v_receivedTrustObjects == v_expectedTrustObjectRequests) {
//							setverdict(pass);
//							break;  
//						};
//	                	t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TSP);  // Restart timer               
//						repeat;
//					}	
//				} // End of first alt 					
//				f_closeDownMtc();                  
//
//
//           } // End of TP_TSP_TRUSTOBJECTS_BV_04
//           
// 		} // End of group Valid_Behaviour
//         
//         group Invalid_Behaviour {
//
//           testcase TP_TSP_TRUSTOBJECTS_BI_01() runs on MainTestComponent system TestAdapter {
//             
//              /**
//              * @desc    TP_TSP_TRUSTOBJECTS_BI_01: Verify that the TSP correctly responds to a TrustObjectADU received without having issued a request and containing incorrect ADU parameters
//              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
//              * @remark  Same as TP_TC_TRUSTOBJECTS_BI_01
//              */
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				var InfoExchange v_apduForSending := m_apduNoAuthInitTester(m_aduTrustObjectInvalidStatus);                 
//				f_sendAndLogApdu(v_apduForSending);                 
//                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
//				// Set timer
//                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                		
//
//				alt {
//					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); 
//						setverdict(pass);
//						}
//					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsDouble(1, AduReasonCode_invalidADU_,2,AduReasonCode_invalidADU_))) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); 
//						setverdict(pass);
//						}
//					} // End of Alt statement
//				f_closeDownMtc();                   
//             
//           } // End of TP_TSP_TRUSTOBJECTS_BI_01
//
//           testcase TP_TSP_TRUSTOBJECTS_BI_02() runs on MainTestComponent system TestAdapter {
//             
//              /**
//              * @desc    TP_TSP_TRUSTOBJECTS_BI_02: Verify that the TSP correctly responds to more than one correct Trust Object ADUs in the same APDU without having issued a request
//              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
//              * @remark  Same as TP_TC_TRUSTOBJECTS_BI_02
//              */
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				// Set two different TrustObject adus by varying the type of trust object 
//				var InfoExchange v_apduForSending := m_apduNoAuthInitTester(
//					{
//					 m_aduTrustObject(
//						{TrustObjectPurposes_dSRCCharging_,TrustObjectPurposes_dSRCAC_,TrustObjectPurposes_oBEInterrogation_,TrustObjectPurposes_oBEInterrogationAC_},
//						//TODO Fausto define DSRCRF_OBJECT_TESTER_VALUE
//						DSRCRF_OBJECT_TESTER_VALUE),
//					 m_aduTrustObject(
//					 	{TrustObjectPurposes_dSRCCharging_},
//					 	certificateTESTER_OBJECT) }
//					);                 
//				f_sendAndLogApdu(v_apduForSending);                 
//                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
//				// Set timer
//                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                		
//				//Create parameters for the m_apduNAck			
//
//				alt {
//					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); 
//						setverdict(pass);
//						}
//					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsDouble(1, AduReasonCode_semanticError_,2,AduReasonCode_semanticError_))) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); 
//						setverdict(pass);
//						}
//					} // End of Alt statement
//				f_closeDownMtc();                   
//                          
//           } // End of TP_TSP_TRUSTOBJECTS_BI_02
//
//           testcase TP_TSP_TRUSTOBJECTS_BI_03() runs on MainTestComponent system TestAdapter {
//              /**
//              * @desc    TP_TSP_TRUSTOBJECTS_BI_03: Verify that the TSP correctly responds to a not supported Trust Object
//              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
//              * @remark  Same as TP_TC_TRUSTOBJECTS_BI_03
//              */
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				// Prepare an invalid certificate (not supported by the profile)
//				var InfoExchange v_apduForSending := m_apduNoAuthInitTester(TrustObjectADU({TrustObjectPurposes_certIssuing_},invalidTESTERGenericObject));                 
//				f_sendAndLogApdu(v_apduForSending);                 
//                // Step 2: Wait for negative Ack within TRUSTOBJECTS.TIME2
//				// Set timer
//                 t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);                		
//				//Create parameters for the m_apduNAck			
//
//				alt {
//					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); 
//						setverdict(pass);
//						}
//					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {{1, AduReasonCode_semanticError_},{2,AduReasonCode_semanticError_}})) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP); 
//						setverdict(pass);
//						}
//					} // End of Alt statement
//				f_closeDownMtc();                   
//                          
//           } // End of TP_TSP_TRUSTOBJECTS_BI_03
//
//           testcase TP_TSP_TRUSTOBJECTS_BI_04() runs on MainTestComponent system TestAdapter {             
//              /**
//              * @desc    TP_TSP_TRUSTOBJECTS_BI_04: Verify that the TSP correctly responds to a RequestADU sent earlier than allowed
//              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
//              * @remark  Same as TP_TC_TRUSTOBJECTS_BI_04
//              */
//             
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				// Step1: send RequestADU by specifying the type of trustobject
//				// Prepare a request of a Trust Object by taking allowed type and purpose from the SENT_TRUST_OBJECTS_SUPPORTED Pixit value
//				var RequestADU requestAdu :={
//					requestedADUType := 3,
//					requestedTrustObject:={
//						trustObjectSpec := {
//							typeOfTrustObject := SENT_TRUST_OBJECTS_SUPPORTED[1].trustObjectType,
//							purposesOfTrustObject := SENT_TRUST_OBJECTS_SUPPORTED[1].trustObjectPurpose}
//						}
//				}
//
//				var Adus requestAduInWrapper:= {requestAdus:={requestAdu}};
//				
//				var InfoExchange v_firstApduRequest:=m_apduNoAuthInitTester(requestAduInWrapper); 
//				var InfoExchange v_secondApduRequest:=m_apduNoAuthInitTester(requestAduInWrapper); 
//				
//				
//				// Now send the first apdu
//				f_sendAndLogApdu(v_firstApduRequest);
//				
//       			//Immediately send same ADU with different APDUid				
//				f_sendAndLogApdu(v_secondApduRequest);
//                              
//				//Set timer
//				t_step.start(TRUSTOBJECTS_TYPE1_TIME2_MAX_TSP);
//                
//				// Step #2: Wait for NAck ADU				 					
//				// Either we receive an APDU containing  NAck or the timeout expires
//				// timeout expiration is handled in the altstep branch
//				
//				alt {
//					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_secondApduRequest)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME2_MIN_TSP);  
//						setverdict(pass);
//						}
//					} // End of Alt statement 
//				f_closeDownMtc();              
//           } // End of TP_TSP_TRUSTOBJECTS_BI_04
//
//           testcase TP_TSP_TRUSTOBJECTS_BI_05() runs on MainTestComponent system TestAdapter {
//
//              /**
//              * @desc    TP_TSP_TRUSTOBJECTS_BI_05: Verify that the TSP correctly responds to a TrustObjectADU sent earlier than allowed
//              * @remark  [16986:2016], Clause 6.6 and Table A.1/2 
//              */
//				// Initialisation
//				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_4_implementedTRUSTOBJECTSElectronicTransfer;
//				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
//				// Step1: prepare TrustObjectADU by specifying KeyRef as type of trustobject
//				var TrustObjectADU v_trustObjectAdu:=	m_aduTrustObject(
//						{TrustObjectPurposes_dSRCCharging_,TrustObjectPurposes_dSRCAC_,TrustObjectPurposes_oBEInterrogation_,TrustObjectPurposes_oBEInterrogationAC_},
//						//TODO Fausto define DSRCRF_OBJECT_TESTER_VALUE
//						TrustObjectCode:{dsrcKeyRef:=DSRCRF_OBJECT_TESTER_VALUE}
//				);                 
//				
//				var InfoExchange v_firstApduToBeSent := m_apduNoAuthInitTester(v_trustObjectAdu);
//				var InfoExchange v_secondApduToBeSent := m_apduNoAuthInitTester(v_trustObjectAdu);
//
//				// Send the first apdu
//				f_sendAndLogApdu(v_firstApduToBeSent);
//				// Send second apdu immediately
//				f_sendAndLogApdu(v_secondApduToBeSent);				
//
//				//Set timer
//				t_step.start(TRUSTOBJECTS_TYPE1_TIME1_MAX_TSP);
//                
//				// Step #2: Wait for NAck ADU				 					
//				// Either we receive an APDU containing  NAck or the timeout expires
//				// timeout expiration is handled in the altstep branch
//				alt {
//					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_secondApduToBeSent)) -> value v_apduReceived {
//						f_logReceivedThenCheckAndStopTime(TRUSTOBJECTS_TYPE1_TIME1_MIN_TSP);  
//						setverdict(pass);
//						}
//					} 
//				f_closeDownMtc();            
//           } // End of TP_TSP_TRUSTOBJECTS_BI_05
//           		
//        } // End of group Invalid_Behaviour
//
//    } // End of group TRUSTOBJECTS
       
   
    group PAYMENTCLAIM {
         group Valid_Behaviour {
            testcase TP_TSP_PAYMENTCLAIM_BV_01() runs on MainTestComponent system TestAdapter {
                   /**    
				  * @desc	TP_TSP_PAYMENTCLAIM_BV_01: Verify that a TSP performs the PAYMENTCLAIM 
				  * @desc	transaction correctly when using the actionCode=send 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5 
                  */
 				// Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Perform a BillingDetails transaction according to the supported types
				f_initForPaymentClaim();
				

                // Send PAYMENTCLAIM with ActionCode=SEND with the basic settings of the m_apduPaymentClaim template

				v_apduForSending := m_apduPaymentClaim;                 
				f_sendAndLogApdu(v_apduForSending);                 
                		
              	// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP);
					}
				} // End of Alt statement
				
				//TODO PT140 checl in whole project that whenever we send multiple APDUs we actually wait the required time (usually TIMEA)
				f_wait(PAYMENTCLAIM_TIMEA_MIN_TSP);				
                // Step 1: Second interaction
                // Note: no Billing Details sent to be referred by the following Payment Claim
                // Send PAYMENTCLAIM with ActionCode=SEND and changing:
                // UserId within declared valid values
                // valid values of TypeOfFee
                // valid value for paymentReference
                // paymentClaimAmount without VAT
				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimId:=2;                 
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimAmount:=TD_PAYMENTANNOUNCEMENT_TOTAL_AMOUNT_WITHOUTVAT;                 
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].typeOfFee := TypeOfFee_penalty_;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentReference := "Lane jumping";

				f_sendAndLogApdu(v_apduForSending);                 
                		
              	// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP);
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                              		
                
                } // End of TP_TSP_PAYMENTCLAIM_BV_01
                
            testcase TP_TSP_PAYMENTCLAIM_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BV_02: Verify that a TSP performs the PAYMENTCLAIM transaction 
                  * @desc 	 correctly when using the actionCode=revoke or adjust 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5 
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM;
				// Perform a BillingDetails transaction according to the supported types
				f_initForPaymentClaim();
				// Send PAYMENTCLAIM with ActionCode=SEND

				v_apduForSending := m_apduPaymentClaim;                 
				f_sendAndLogApdu(v_apduForSending);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP);
					}
				} // End of Alt statement

                // Step 1:
                // Send PAYMENTCLAIM with ActionCode=ADJUST referring to the previoulsy sent PAYMENTCLAIM and changing the charged value
				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimAmount:=TD_BILLINGDETAILS_AMOUNT_1;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].actionCode := ActionCode_adjust_;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimStatus:= PaymentClaimStatus_amendedVersion_;

				f_sendAndLogApdu(v_apduForSending);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP);
					}
				} // End of Alt statement

                // Send PAYMENTCLAIM with ActionCode=REVOKE referring to the previoulsy sent PAYMENTCLAIM
				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimAmount:=c_extPayAmountNothing;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].actionCode := ActionCode_revoke_;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimStatus:= PaymentClaimStatus_amendedVersion_;
				f_sendAndLogApdu(v_apduForSending);                 
                		
              		// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP);
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                              		
                     
                } // End of TP_TSP_PAYMENTCLAIM_BV_02
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {
            testcase TP_TSP_PAYMENTCLAIM_BI_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_01: Verify that a TSP performs the PAYMENTCLAIM 
                  * @desc	 transaction correctly when getting incorrect paymentClaimId 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Perform a BillingDetails transaction according to the supported types
				f_initForPaymentClaim();

                // Send PAYMENTCLAIM with ActionCode=SEND

				v_apduForSending := m_apduPaymentClaim;               
				f_sendAndLogApdu(v_apduForSending);                 
                		
              	// Wait for Ack (if negative Ack or not received set test failure)
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP);
						}
					} // End of Alt statement

                // Step 1:
                // Send PAYMENTCLAIM with ActionCode=REVOKE not referring to the previoulsy sent PAYMENTCLAIM
				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimId:=2;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimAmount.paymentFeeAmount:=0;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].actionCode:=ActionCode_revoke_;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimStatus:=PaymentClaimStatus_amendedVersion_;
                 
				f_sendAndLogApdu(v_apduForSending);                 
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_paymentClaimIdRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_paymentClaimIdRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                   
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_01           		

            testcase TP_TSP_PAYMENTCLAIM_BI_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_02: Verify that a TSP performs the PAYMENTCLAIM transaction 
                  * @desc 	 correctly when getting incorrect paymentClaimStatus 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Perform a BillingDetails transaction according to the supported types
				f_initForPaymentClaim();

                // Send valid PAYMENTCLAIM with ActionCode=SEND and setting:
                		// UserId within declared valid values
                		// valid values of TypeOfFee
                		// paymentReference valid and not present
				v_apduForSending := m_apduPaymentClaim;                 
				f_sendAndLogApdu(v_apduForSending);                 
                		
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP);
						}
					} // End of Alt statement
					// Step 1: send invalid PAYMENTCLAIM				
                	// Send PAYMENTCLAIM with ActionCode=ADJUST, but with status = first version

				v_apduForSending := m_apduPaymentClaim; // needs to be done again, m_apduPaymentClaim is a dynamic template
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].actionCode:=ActionCode_adjust_;

				f_sendAndLogApdu(v_apduForSending);                 
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_paymentClaimStatusRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_paymentClaimStatusRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                 		          	      
                } // End of TP_TSP_PAYMENTCLAIM_BI_02           		

            testcase TP_TSP_PAYMENTCLAIM_BI_03() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_03: Verify that a TSP performs the PAYMENTCLAIM transaction 
                  * @desc 	 correctly when getting incorrect referenceDetailsList 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Perform a BillingDetails transaction according to the supported types
				f_initForPaymentClaim();
					
                // Send PAYMENTCLAIM with ActionCode=SEND and referring to a wrong reference details list	
				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].referenceDetailsList[0].billingDetailsList[0].billingDetailsNum:=2;

				f_sendAndLogApdu(v_apduForSending);                 
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_invalidADU_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
					}
				} // End of Alt statement
					
				f_closeDownMtc();                 		               
            } // End of TP_TSP_PAYMENTCLAIM_BI_03           		

            testcase TP_TSP_PAYMENTCLAIM_BI_04() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_04: Verify that a TSP performs the PAYMENTCLAIM transaction 
                  * @desc 	 correctly when getting incorrect actionCode 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Perform a BillingDetails transaction according to the supported types
				f_initForPaymentClaim();

                // Send PAYMENTCLAIM with ActionCode=SEND and with action code = credit (not allowed)
				
				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].actionCode:=ActionCode_credit_;

				f_sendAndLogApdu(v_apduForSending);                 
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_paymentClaimStatusRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_paymentClaimStatusRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement

				f_closeDownMtc();                 						                  
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_04   

            testcase TP_TSP_PAYMENTCLAIM_BI_05() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_05: Verify that the TSP correctly performs the 
                  * @desc    PAYMENTCLAIM transaction when receiving a number of PaymenClaimADUs, 
                  * @desc    each of them containing specific errors  
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc								
				
				// Perform a BillingDetails transaction according to the supported types
				f_initForPaymentClaim();

                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the performed BillingDetails transaction
				
				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].endDateTime:=fx_getUtc(-31539600);//set end date to one hour before start date;

				f_sendAndLogApdu(v_apduForSending);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimEndDateTimeRejected (804)

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_paymentClaimEndDateTimeRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_paymentClaimEndDateTimeRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement

                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the  performed BillingDetails transaction, and containing userId unknown to the IUT

				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].userId := PX_USER_NOT_EXISTING_1;

				f_sendAndLogApdu(v_apduForSending);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimUserIdRejected (805)

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_paymentClaimUserIdRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_paymentClaimUserIdRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement

                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the performed BillingDetails transaction, and containing paymentClaimAmount exceeding maximum permitted

				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimAmount := MAX_ACCEPTED_PAYMENTCLAIM_AMOUNT;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimAmount.paymentFeeAmount := 
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimAmount.paymentFeeAmount+1;
				
				f_sendAndLogApdu(v_apduForSending);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimAmountRejected (806)

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_paymentClaimAmountRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_paymentClaimAmountRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement

                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the  performed BillingDetails transaction, and containing paymentClaimStatus = 2
				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimStatus:=2;//undefnied and not allowed value;

				f_sendAndLogApdu(v_apduForSending);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimStatusRejected (807)

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_paymentClaimStatusRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_paymentClaimStatusRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement

                // Send PAYMENTCLAIM with ActionCode=SEND and referencing the  performed BillingDetails transaction, and containing typeOfFee omitted

				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].typeOfFee := 42; //this type of fee is not defined, reserved for future CEN and ISO use and shall be rejected

				f_sendAndLogApdu(v_apduForSending);                 
                // Wait for a NAck_Apdu containing one AckADU with issues containing issueCode = paymentClaimTypeOfFeeRejected	(808)

				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(
						v_apduForSending, m_roNackParamsSingle(0,AduReasonCode_paymentClaimTypeOfFeeRejected_)
					)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
					}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(
						v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_paymentClaimTypeOfFeeRejected_)
					)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
										 
				f_closeDownMtc();				                 
                
                } // End of TP_TSP_PAYMENTCLAIM_BI_05   

            testcase TP_TSP_PAYMENTCLAIM_BI_06() runs on MainTestComponent system TestAdapter {
            	 
                  /**
                  * @desc    TP_TSP_PAYMENTCLAIM_BI_06: Verify that a TSP responds correctly to a 
                  * @desc 	 PaymentClaimADU sent earlier than allowed  
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.7/5  
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_5_implementedPAYMENTCLAIM;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				if (PAYMENTCLAIM_TIMEA_MIN_TSP == 0.0)	{
					setverdict(inconc);
					f_addLogEntry("Cannot perform minimum time test because IUT sets it to 0");
					stop;			  
				};			
				// Perform a BillingDetails transaction according to the supported types
				f_initForPaymentClaim();

				// Send one PAYMENTCLAIM related to the sent BILLINGDETAILS within allowed time constraints

				v_apduForSending := m_apduPaymentClaim;

				f_sendAndLogApdu(v_apduForSending);                 

                // Step 1:
                	// Send PAYMENTCLAIM with ActionCode=REVOKE before TIMEA_MIN
              		// Wait for negative Ack (if positive Ack or not received set test failure) 

				v_apduForSending := m_apduPaymentClaim;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].actionCode := ActionCode_revoke_;
				v_apduForSending.infoExchangeContent.adus.paymentClaimADUs[0].paymentClaimStatus := PaymentClaimStatus_amendedVersion_;
               
				f_sendAndLogApdu(v_apduForSending); 
                		
              	// Wait for negative Ack  with NAck_requestSentTooOften code
				// Set timer
                 t_step.start(PAYMENTCLAIM_TIME1_MAX_TSP);                 
                // Wait for negative Ack (if positive Ack or not received set test failure)				
				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(PAYMENTCLAIM_TIME1_MIN_TSP); 
						setverdict(pass);						
					}
				} // End of Alt statement               
				f_closeDownMtc();  			
                
			} // End of TP_TSP_PAYMENTCLAIM_BI_06  
        } // End of group Invalid_Behaviour

    } // End of group PAYMENTCLAIM

    group DSRC_CONTRACTISSUERLIST {
         group Valid_Behaviour {
           testcase TP_TSP_DSRC_CONTRACTISSUERLIST_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_CONTRACTISSUERLIST_BV_01: Verify that the TSP correctly performs the DSRC.CONTRACTISSUERLIST transaction with three manufacturerIDs 
                  * @remark  [16986:2016], Clause 7.1 and Table A.1/2 AND Table A.2/1 AND Table A.26/1 
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_1_implementedDSRCCONTRACTISSUERLIST;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Step 1: Trigger IUT with CONTRACTISSUERLIST.TR_TSP_1
				f_sendAndLogTrigger(DSRC_CONTRACTISSUERLIST_TR_TSP_1_DIFFMANUFID);

				//  Wait for apdu containing CONTRACTISSUERLIST for three different manufacturers
				var template InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut(
					{modifies mw_aduContractIssuerList:= {manufacturerIdId := MANUFACTURERID1}},
					{modifies mw_aduContractIssuerList:= {manufacturerIdId := MANUFACTURERID2}},
					{modifies mw_aduContractIssuerList:= {manufacturerIdId := MANUFACTURERID3}}
           			);                 

				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();					
						// Send Ack within time constraints
						f_logReceivedWaitAndAcknowledge(DSRC_CONTRACTISSUERLIST_TIME1_MIN_TSP);
						setverdict(pass);	
						}		
					} // End of alt statement
				
				f_closeDownMtc(); 
			} // End of TP_TSP_CONTRACTISSUERLIST_BV_01
 		} // End of group Valid_Behaviour
         
        group Invalid_Behaviour {
           // No Invalid Behaviour Test cases defined		
        } // End of group Invalid_Behaviour

    } // End of group DSRC_CONTRACTISSUERLIST
    
    group DSRC_EFCCONTEXTDATA {
         group Valid_Behaviour {
           testcase TP_TSP_DSRC_EFCCONTEXTDATA_BV_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BV_01: Verify that the TSP correctly performs the 
                  * @desc    DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing only mandatory context data for a domain type = dsrcContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */                 
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// iso17573ADU containing only mandatory field with valid values
                 	// feeModifiers set to null
				// set tester tolling domain characteristics
				v_apduForSending := m_apduNoAuthInitTester({m_aduDsrcEfcContextDataTestValues});                 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
				// Set timer
                 t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement 
				f_closeDownMtc();                  
                                 
                } // End of TP_TSP_DSRC_EFCCONTEXTDATA_BV_01

           testcase TP_TSP_DSRC_EFCCONTEXTDATA_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BV_02: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing only mandatory context data for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                                   
                // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1: Send EFCCONTEXTDATA with:
               	// domainType = dsrcClosedContext 
               	// ClosedContextDefinition containing only mandatory field with valid values
               	// feeModifiers set to null
				// Only tollContextOverview in ClosedContextDefinition set to a valid value
				v_apduForSending :=m_apduNoAuthInitTester({m_aduEfcContextDataDsrcClosedContextTollContextOverview});
				f_sendAndLogApdu(v_apduForSending);                 

                // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
				// Set timer
                t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                  
                
			} // End of TP_TSP_DSRC_EFCCONTEXTDATA_BV_02

           	testcase TP_TSP_DSRC_EFCCONTEXTDATA_BV_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BV_03: Verify that the TSP correctly performs the 
                  * @desc    DSRC_EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory 
                  * @desc    context data plus tariffClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
								
				v_apduForSending := m_apduNoAuthInitTester({m_aduEfcContextDataDsrcClosedContextTariffClassDefinition});
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with tariffClassDefinition = {valid contents} and all other fields set to null
				f_sendAndLogApdu();                 

                // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
				// Set timer
                t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                  
                                  
            } // End of TP_TSP_DSRC_EFCCONTEXTDATA_BV_03

			testcase TP_TSP_DSRC_EFCCONTEXTDATA_BV_04() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BV_04: Verify that the TSP correctly performs the 
                  * @desc    DSRC_EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory 
                  * @desc    context data plus localVehicleClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1: Send EFCCONTEXTDATA with:
                // domainType = dsrcClosedContext 
                // dsrcClosedContext with valid values and feeModifiers set to null
                // closedSystem with localVehicleClassDefinition  = {valid contents} and all other fields set to null
				v_apduForSending := m_apduNoAuthInitTester({m_aduEfcContextDataDsrcClosedContextLocVehClass});                
				f_sendAndLogApdu(v_apduForSending);                 
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
				// Set timer
                 t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                  
                                  
			} // End of TP_TSP_DSRC_EFCCONTEXTDATA_BV_04

           testcase TP_TSP_DSRC_EFCCONTEXTDATA_BV_05() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BV_05: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus timeClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with timeClassDefinition  = {valid contents} and all other fields set to null
				v_apduForSending := m_apduNoAuthInitTester({m_aduEfcContextDataDsrcClosedContextTimeClass});                
				f_sendAndLogApdu(v_apduForSending);                 
                 // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
				// Set timer
                 t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                  
                
                } // End of TP_TSP_DSRC_EFCCONTEXTDATA_BV_05

           testcase TP_TSP_DSRC_EFCCONTEXTDATA_BV_06() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BV_06: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus userClassDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcClosedContext 
                 	// dsrcClosedContext with valid values and feeModifiers set to null
                 	// closedSystem with userClassDefinition  = {valid contents} and all other fields set to null
				v_apduForSending := m_apduNoAuthInitTester({m_aduEfcContextDataDsrcClosedContextUserClass});                
				f_sendAndLogApdu(v_apduForSending);                 

                // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
				// Set timer
                t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                  
                                
                } // End of TP_TSP_DSRC_EFCCONTEXTDATA_BV_06

           testcase TP_TSP_DSRC_EFCCONTEXTDATA_BV_07() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BV_07: Verify that the TSP correctly performs the DSRC.EFCCONTEXTDATA transaction with an EFCContextDataADU containing mandatory context data plus feeDefinition for a domain type = dsrcClosedContext 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1: Send EFCCONTEXTDATA with:
                // domainType = dsrcClosedContext 
                // dsrcClosedContext with valid values and feeModifiers set to null
                // closedSystem with feeDefinition  = {valid contents} and all other fields set to null
				v_apduForSending := m_apduNoAuthInitTester({m_aduEfcContextDataDsrcClosedContextFeeDefinition});                
				f_sendAndLogApdu(v_apduForSending);

                // Step 2: Wait for positive Ack within DSRC.EFCCONTEXTDATA.TIME1
				// Set timer
                t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement 
				f_closeDownMtc();                  
                
                } // End of TP_TSP_DSRC_EFCCONTEXTDATA_BV_07
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_DSRC_EFCCONTEXTDATA_BI_01() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BI_01: Verify that the TSP correctly responds to an EFCContextDataADU containing only mandatory context data for a domain type = dsrcContext with a wrong data field 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// iso17573ADU containing only mandatory field with one invalid value
                 	// feeModifiers set to null
                 	// set tester tolling domain characteristics
                 	// PT140 TODO: which field to be set to a wrong value? Is this test doable?
				var Iso17575_3AduBody v_contextData;
				v_apduForSending := m_apduNoAuthInitTester({m_aduDsrcEfcContextDataTestValues});                 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Step 2: Wait for negative Ack within DSRC.EFCCONTEXTDATA.TIME1
				// Set timer
                 t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsDouble(1, AduReasonCode_semanticError_,2,AduReasonCode_semanticError_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
			
				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC_EFCCONTEXTDATA_BI_01

           testcase TP_TSP_DSRC_EFCCONTEXTDATA_BI_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BI_02: Verify that the TSP correctly responds to an EFCContextDataADU containing only mandatory context data for a domain type = dsrcClosedContext with a wrong data field 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Step 1: Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// dsrcClosedContext containing invalid values
                 	// feeModifiers set to null
                 	// all other mandatory fields set to valid values
					// Only tollContextOverview in ClosedContextDefinition set to a valid value
				v_apduForSending := m_apduNoAuthInitTester({m_aduEfcContextDataDsrcClosedContextTollContextOverviewInvalidCCT});                 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Step 2: Wait for negative Ack within DSRC.EFCCONTEXTDATA.TIME1
				// Set timer
                 t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(
						v_apduForSending, 
						m_roNackParamsDouble(1, AduReasonCode_semanticError_,2,AduReasonCode_semanticError_)
					)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement

				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC_EFCCONTEXTDATA_BI_02

           testcase TP_TSP_DSRC_EFCCONTEXTDATA_BI_03() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_DSRC_EFCCONTEXTDATA_BI_03: Verify that the TSP responds correctly to an EfcContextDataADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 7.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/2
                  */
                  
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_2_implementedDSRCEFCCONTEXTDATA;
				if (DSRC_EFCCONTEXTDATA_TIMEA_MIN_TSP == 0.0)	{
					setverdict(inconc);
					f_addLogEntry("Cannot perform minimum time test because IUT sets it to 0");
					stop;			  
				};			
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                 // Send EFCCONTEXTDATA with:
                 	// domainType = dsrcContext 
                 	// iso17573ADU containing only mandatory field with valid values
                 	// feeModifiers set to null
				// set tester tolling domain characteristics
				v_apduForSending := m_apduNoAuthInitTester({m_aduDsrcEfcContextDataTestValues});     
				f_sendAndLogApdu(v_apduForSending);                 
                // Step 1: Do not wait for positive Ack but send immediately another EFCCONTEXTDATA before TIME1
                f_sendAndLogApdu(v_apduForSending);                 
				// Set timer
                 t_step.start(DSRC_EFCCONTEXTDATA_TIME1_MAX_TSP);                 

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_semanticError_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_EFCCONTEXTDATA_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();  			
                } // End of TP_TSP_DSRC_EFCCONTEXTDATA_BI_03
           		
        } // End of group Invalid_Behaviour

    } // End of group DSRC_EFCCONTEXTDATA
    
    group DSRC_BILLINGDETAILS {
         group Valid_Behaviour {

         	testcase TP_TSP_DSRC_BILLINGDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_BILLINGDETAILS_BV_01: Verify that the TSP correctly performs a 
                  * @desc    DSRC.BILLINGDETAILS transaction when a TC sends a single BillingDetailsADU 
                  * @desc    with no optional fields except includedDiscounts and actionCode=send 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with no optional fields except includedDiscounts
				var InfoExchange v_apduToSend := m_apduNoAuthInitTester({m_aduDsrcBillingDetails});                 
				f_sendAndLogApdu(v_apduToSend);                 
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToSend)) -> value v_apduReceived {
					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement 
				f_closeDownMtc();                  
                } // End of TP_TSP_DSRC_BILLINGDETAILS_BV_01

           testcase TP_TSP_DSRC_BILLINGDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_BILLINGDETAILS_BV_02: Verify that the TSP correctly performs a 
                  * @desc    DSRC.BILLINGDETAILS transaction when the TC provides multiple BillingDetailsADUs 
                  * @desc    with no optional fields  
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 // Step 1: Send one valid APDU containing 10 valid BillingDetailsADU with actionCode = SEND
				v_apduForSending := m_apduNoAuthInitTester({
					m_aduDsrcBillingDetails(1),                 
					m_aduDsrcBillingDetails(2),                 
					m_aduDsrcBillingDetails(3),                 
					m_aduDsrcBillingDetails(4),                 
					m_aduDsrcBillingDetails(5),                 
					m_aduDsrcBillingDetails(6),                 
					m_aduDsrcBillingDetails(7),                 
					m_aduDsrcBillingDetails(8),                 
					m_aduDsrcBillingDetails(9),                 
					m_aduDsrcBillingDetails(10)                 
				});                 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement					

				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC_BILLINGDETAILS_BV_02

           testcase TP_TSP_DSRC_BILLINGDETAILS_BV_03() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_BILLINGDETAILS_BV_03: Verify that the TSP correctly performs a 
                  * @desc	 DSRC.BILLINGDETAILS transaction when the TC sends a single BillingDetailsADU 
                  * @desc 	 with actionCode = adjust and no optional fields 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Prepare a billingdetails with excessive amount
				var InfoExchange v_apduToSend :=m_apduNoAuthInitTester(
				{modifies mw_aduDsrcBillingDetails(1):= {
					billingDetailsAmount:={
						paymentFeeAmount := MAX_ACCEPTED_BILLINGDETAILS_AMOUNT.paymentFeeAmount + 4000
					}
			  	}});				
				// Wait for a negative ack
				f_sendAndLogApdu(v_apduToSend);                 
                 
                // Wait for negative Ack (if positive Ack or not received set test failure)
				// Set timer
                 t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduToSend, AduReasonCode_billingDetailsAmountRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduToSend, m_roNackParamsSingle(1, AduReasonCode_billingDetailsAmountRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with only mandatory fields and with
                 	// actionCode = adjust
                 	// billingDetailsNum = 1
                 	// paymentFeeAmount = 45

				v_apduToSend :=m_apduNoAuthInitTester(
					{
						modifies mw_aduDsrcBillingDetails(1):= {
							actionCode:=ActionCode_adjust_,
							billingDetailsAmount:={
							 	paymentFeeAmount:=45
							}						
						}
					}
				);                 
				f_sendAndLogApdu(v_apduToSend);
				                 
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduToSend)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();  			
                          
           } // End of TP_TSP_DSRC_BILLINGDETAILS_BV_03

           testcase TP_TSP_DSRC_BILLINGDETAILS_BV_04() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_BILLINGDETAILS_BV_05: Verify that the TSP correctly performs a DSRC.BILLINGDETAILS transaction when the TC sends a single BillingDetailsADU with actionCode = revoke and no optional fields 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 // Send one valid APDU containing one valid BillingDetailsADU numbered 1 with only mandatory field
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies mw_aduDsrcBillingDetails(1):= {
						actionCode := ActionCode_revoke_
					}}
				); 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						}
					} // End of Alt statement
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with only mandatory fields and with
                 	// actionCode = revoke
                 	// billingDetailsNum = 1
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies mw_aduDsrcBillingDetails(1):= {
					  	actionCode := ActionCode_revoke_
					  	}
					});                 
				f_sendAndLogApdu(v_apduForSending);
				                 
                 // Step 2: Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					}  // End of Alt statement
				f_closeDownMtc();  			
				                 
                } // End of TP_TSP_DSRC_BILLINGDETAILS_BV_04
           
 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {

           testcase TP_TSP_DSRC_BILLINGDETAILS_BI_01() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_BILLINGDETAILS_BI_01: Verify that the TSP correctly responds to a series of BillingDetailsADUs bearing only mandatory fields, each BillingDetailsADU having one mandatory field bearing an incorrect value 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies mw_aduDsrcBillingDetails(3):= {
					  	billingDetailsAmount:={paymentFeeAmount := 50}
					  	}
					});                 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						}
					}  // End of Alt statement
                 
                 // Step 1: Send one valid APDU containing 10  BillingDetailsADUs with actionCode = SEND numbered from 4 to 13, each one with the following parameters respectively set to one incorrect value:
                 	// billingDetailsId.issuerId, tollContext, userId, billingDetailsAmount, usageDetails.contextName, usageDetails.appliedUserClass, usageDetails.perDeclaredVehicleClasses, usageDetails.appliedTimeClass, usageDetails.entranceTime, usageList.ListofSections.chargeObjectId
				v_apduForSending := m_apduNoAuthInitTester({
					{
						modifies m_aduDsrcBillingDetails(4):={
							billingDetailsId:={
								issuerId := 0
							}
						}
					},                 
					{
						modifies m_aduDsrcBillingDetails(5):={
							tollContext:=0
						}
					},                 
					{
						modifies m_aduDsrcBillingDetails(6):={
							userId:=omit
						}
					},                 
					{
						modifies m_aduDsrcBillingDetails(7):={
							billingDetailsAmount:={
								paymentFeeAmount := -5
							}
						}
					},                 
					{
						modifies m_aduDsrcBillingDetails(8):={
							usageDetails:={
								contextName := 42
							}
						}
					},                 
					{
						modifies m_aduDsrcBillingDetails(9):={
							usageDetails:={
								appliedUserClass := 0
							}
						}
					},                 
					{
						modifies m_aduDsrcBillingDetails(10):={
							usageDetails:={
								perDeclaredVehicleClasses := omit
							}
						}
					},                 
					{
						modifies m_aduDsrcBillingDetails(11):={
							usageDetails:={
								appliedTimeClass := 0
							}
						}
					},                 
					{
						modifies m_aduDsrcBillingDetails(12):={
							usageDetails:={
								entranceTime := 0
							}
						}
					},                 
					{
						modifies m_aduDsrcBillingDetails(13):={
							usageList:={
								ListofSections := {
								  chargeObjectId := 0
								}
							}
						}
					}                 
				});
                 
				f_sendAndLogApdu(v_apduForSending);
                 	
                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 with issue list present and the following issue codes:
                 	// billingDetailsIssuerIdRejected, billingDetailsContextIdRejected, billingDetailsUserIdRejected, billingDetailsAmountRejected, billingDetailsContextNameRejected, billingDetailsAppliedUserClassRejected, billingDetailsDeclaredVehicleClassRejected, billingDetailsAppliedTimeClassRejected, billingDetailsEntranceTimeRejected, billingDetailsIntermediateSectionRejected
				
				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, {
					  		{1,AduReasonCode_billingDetailsIssuerIdRejected_},
							{2,AduReasonCode_billingDetailsContextIdRejected_},
							{3,AduReasonCode_billingDetailsUserIdRejected_}, 
							{4,AduReasonCode_billingDetailsAmountRejected_}, 
							{5,AduReasonCode_billingDetailsContextNameRejected_}, 
							{6,AduReasonCode_billingDetailsAppliedUserClassRejected_}, 
							{7,AduReasonCode_billingDetailsDeclaredVehicleClassRejected_}, 
							{8,AduReasonCode_billingDetailsAppliedTimeClassRejected_}, 
							{9,AduReasonCode_billingDetailsEntranceTimeRejected_}, 
							{10,AduReasonCode_billingDetailsIntermediateSectionRejected_}
							})) -> value v_apduReceived {
						// Log what we received
						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(DSRC_BILLINGDETAILS_TIME1_MIN_TSP);
						t_step.stop;
						setverdict(pass);
						}
					} // End of Alt statement                	
				f_closeDownMtc();  			
                
			} // End of TP_TSP_DSRC_BILLINGDETAILS_BI_01

           	testcase TP_TSP_DSRC_BILLINGDETAILS_BI_02() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_BILLINGDETAILS_BI_02: Verify that the TSP correctly responds to a BillingDetailsADU adjusting the fee of a not previously issued BillingDetailsADU 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies m_aduDsrcBillingDetails(3):={
							billingDetailsAmount:={
								paymentFeeAmount := 50
							}
						}
				});                 
					f_sendAndLogApdu(v_apduForSending);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						}
					} // End of Alt statement 

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU numbered 14 with only mandatory fields with the following values:
                 	// actionCode = adjust
                 	// paymentFeeAmount = 45
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies m_aduDsrcBillingDetails(14):={
							actionCode := ActionCode_adjust_,
							billingDetailsAmount:={
								paymentFeeAmount := 45
							}
						}
				});                 
				f_sendAndLogApdu(v_apduForSending);                 

                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 identifying the APDU containing the BillingDetailsADU numbered 14 and with issueCode= semanticError 
                t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_semanticError_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
		
				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC_BILLINGDETAILS_BI_02

           testcase TP_TSP_DSRC_BILLINGDETAILS_BI_03() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_BILLINGDETAILS_BI_03: Verify that the TSP correctly responds to a BillingDetailsADU revoking a not previously issued BillingDetailsADU 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies m_aduDsrcBillingDetails(3):={
							billingDetailsAmount:={
								paymentFeeAmount := 50
							}
						}
					});                 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Wait for positive Ack within DSRC.BILLINGDETAILS.TIME1
				// Set timer
                 t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						}
					} // End of Alt statement

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU numbered 14 with only mandatory fields with the following values:
                 	// actionCode = revoke
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies m_aduDsrcBillingDetails(14):={
							actionCode := ActionCode_revoke_
						}
				});                 
				f_sendAndLogApdu(v_apduForSending);                 

                 // Step 2: Wait for negative Ack within DSRC.BILLINGDETAILS.TIME1 identifying the APDU containing the BillingDetailsADU numbered 14 and with issueCode= semanticError 
                t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);                 

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_semanticError_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC_BILLINGDETAILS_BI_03

           testcase TP_TSP_DSRC_BILLINGDETAILS_BI_04() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_BILLINGDETAILS_BI_04: Verify that the TSP responds correctly to a BillingDetailsADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 7.3.2 and Table A.1/2 AND Table A.2/1 AND Table A.26/3
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_3_implementedDSRCBILLINGDETAILS;
				if (DSRC_BILLINGDETAILS_TIMEA_MIN_TSP == 0.0)	{
					setverdict(inconc);
					f_addLogEntry("Cannot perform minimum time test because IUT sets it to 0");
					stop;			  
				};			
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

				// Send one valid DSRC.BILLINGDETAILS numbered 3
                 //  Send one valid APDU containing one BillingDetailsADU numbered 3 with actionCode = SEND and only mandatory fields
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies mw_aduDsrcBillingDetails(3):= {billingDetailsAmount:={paymentFeeAmount := 50}}}
				);

				f_sendAndLogApdu(v_apduForSending);                 

				// Do not wait for positive Ack

                // Step 1:
                // Send one valid DSRC.BILLINGDETAILS numbered 4  before TIME1
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies mw_aduDsrcBillingDetails(4):= {billingDetailsAmount:={paymentFeeAmount := 45}}}
				);                 
				f_sendAndLogApdu(v_apduForSending);                 

              	// Wait for negative Ack with ADUReasonCode field = requestSentTooOften (if positive Ack or not received set test failure)                	
				// Step #2: Wait for NAck ADU				 					
				// Set timer
                 t_step.start(DSRC_BILLINGDETAILS_TIME1_MAX_TSP);
				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_BILLINGDETAILS_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement             
                f_closeDownMtc();  			
                
                } // End of TP_TSP_DSRC_BILLINGDETAILS_BI_04
		
        } // End of group Invalid_Behaviour

    } // End of group DSRC_BILLINGDETAILS
    
    group DSRC_REPORTABNORMALOBE {
         group Valid_Behaviour {

           testcase TP_TSP_DSRC_REPORTABNORMALOBE_BV_01() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_REPORTABNORMALOBE_BV_01: Verify that the TSP correctly performs a DSRC.REPORTABNORMALOBE transaction in response to an APDU containing valid ReportAbnormalOBEADUs 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                // Send one valid DSRC.REPORTABNORMALOBE
				v_apduForSending := m_apduNoAuthInitTester({m_aduReportAbnormalObe});                 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Step 2: Wait for positive Ack within DSRC_REPORTABNORMALOBE_TIME1
				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                  
                
                } // End of TP_TSP_DSRC_REPORTABNORMALOBE_BV_01

 		} // End of group Valid_Behaviour
         
         group Invalid_Behaviour {		

           testcase TP_TSP_DSRC_REPORTABNORMALOBE_BI_01() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_REPORTABNORMALOBE_BI_01: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no userId field present 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                // Send one  DSRC.REPORTABNORMALOBE with userId field missing
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies m_aduReportAbnormalObe:= {
					  	userId := omit
					  	}
					});                 
				f_sendAndLogApdu(v_apduForSending);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)                	

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_semanticError_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();  			
                
           	} // End of TP_TSP_DSRC_REPORTABNORMALOBE_BI_01

          	testcase TP_TSP_DSRC_REPORTABNORMALOBE_BI_02() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_REPORTABNORMALOBE_BI_02: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no value or invalid values in the field userId 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                // Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with missing and second one with userID set to an invalid value

				v_apduForSending := {
					m_apduNoAuthInitTester({modifies m_aduReportAbnormalObe:= {
					  		userId := omit
					  		}
						}),
					m_apduNoAuthInitTester({modifies m_aduReportAbnormalObe:= {
					  		userId := PX_USER_ID_NON_EXISTING
					  		}
						})	
           			};                 
				f_sendAndLogApdu(v_apduForSending);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeUserIdRejected
				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsDouble(1, AduReasonCode_invalidADU_,2, AduReasonCode_abnormalObeUserIdRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
               	
               	f_closeDownMtc();  			
                } // End of TP_TSP_DSRC_REPORTABNORMALOBE_BI_02

           testcase TP_TSP_DSRC_REPORTABNORMALOBE_BI_03() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_REPORTABNORMALOBE_BI_03: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with invalid dateAndTime field 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Step 1:
                // Send one  DSRC.REPORTABNORMALOBE with dateAndTime field missing
				v_apduForSending := {
					m_apduNoAuthInitTester({modifies m_aduReportAbnormalObe:= {
					  	dateAndTime := fx_getUtc(1000)
					  	}
					})	
           		};                 
				f_sendAndLogApdu(v_apduForSending);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	// Wait for negative Ack with issueCode = semanticError (if positive Ack or not received set test failure)             	

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_abnormalObeDateAndTimeRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_abnormalObeDateAndTimeRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
               	
               	f_closeDownMtc();  
                                
                } // End of TP_TSP_DSRC_REPORTABNORMALOBE_BI_03


           testcase TP_TSP_DSRC_REPORTABNORMALOBE_BI_04() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_REPORTABNORMALOBE_BI_05: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no efcContextMark field 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                // Send one  DSRC.REPORTABNORMALOBE with efcContextMark field missing
				v_apduForSending := {
					m_apduNoAuthInitTester({modifies m_aduReportAbnormalObe:= {					  	
					  	efcContextMark := omit
					  	}
					})	
           		};                 
				f_sendAndLogApdu(v_apduForSending);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_invalidADU_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
               	
               	f_closeDownMtc();
                
                } // End of TP_TSP_DSRC_REPORTABNORMALOBE_BI_04

           testcase TP_TSP_DSRC_REPORTABNORMALOBE_BI_05() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_REPORTABNORMALOBE_BI_05: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with invalid values in the field efcContextMark 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                	// Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with efcContextMark missing and second one with efcContextMark set to an invalid value

				v_apduForSending := {
					m_apduNoAuthInitTester({modifies m_aduReportAbnormalObe:= {
					  	efcContextMark := 0
					  	}
					})	
           		};                 
				f_sendAndLogApdu(v_apduForSending);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	// Step 2:
              		// Wait for negative Ack with the following issues:
              			// 1, AduReasonCode_semanticError
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_semanticError_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
               	
               	f_closeDownMtc(); 
                
                } // End of TP_TSP_DSRC_REPORTABNORMALOBE_BI_05

           testcase TP_TSP_DSRC_REPORTABNORMALOBE_BI_06() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_REPORTABNORMALOBE_BI_07: Verify that the TSP correctly responds to an APDU containing ReportAbnormalOBEADU not containing the abnormalOBEReason field 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                	// Send one  DSRC.REPORTABNORMALOBE with abnormalOBEReason field missing
				v_apduForSending := {
					m_apduNoAuthInitTester({modifies m_aduReportAbnormalObe:= {					  	
					  		abnormalOBEReasonCode := omit
					  		}
						})	
           			};                 
				f_sendAndLogApdu(v_apduForSending);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
              	
              	// Wait for negative Ack with issueCode = invalidADU (if positive Ack or not received set test failure)                	
              			                	
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_invalidADU_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_invalidADU_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
               	
               	f_closeDownMtc();
                
                } // End of TP_TSP_DSRC_REPORTABNORMALOBE_BI_06

           testcase TP_TSP_DSRC_REPORTABNORMALOBE_BI_07() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_DSRC_REPORTABNORMALOBE_BI_08: Verify that the TSP correctly responds to an APDU containing one ReportAbnormalOBEADU with no value or invalid values in the field abnormalOBEReason 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Step 1:
                	// Send one  APDU containg 2 ReportAbnormalOBEADUs, first one with abnormalOBEReason missing and second one with abnormalOBEReason set to an invalid value

				v_apduForSending := {
					m_apduNoAuthInitTester(modifies m_aduReportAbnormalObe:= {
					  	abnormalOBEReasonCode := omit
						}),
					m_apduNoAuthInitTester(modifies m_aduReportAbnormalObe:= {
					  	abnormalOBEReasonCode := 700
						})	
           			};                 
				f_sendAndLogApdu(v_apduForSending);                 

				// Set timer
                 t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);                 
                
              	// Step 2:
              		// Wait for negative Ack with the following issues:
              			// 1, invalidADU (0)
              			// 2, abnormalObeReasonCodeRejected
              			                	
				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsDouble(1, AduReasonCode_invalidADU_,2, AduReasonCode_abnormalObeReasonCodeRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
               	
               	f_closeDownMtc();
            
                } // End of TP_TSP_DSRC_REPORTABNORMALOBE_BI_07
               
			testcase TP_TSP_DSRC_REPORTABNORMALOBE_BI_08() runs on MainTestComponent system TestAdapter {
                 /**
                  * @desc    TP_TSP_DSRC_REPORTABNORMALOBE_BI_09: Verify that the TSP responds correctly to a ReportAbnormalOBEADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 7.4 and Table A.1/2 AND Table A.2/1 AND Table A.26/4
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A26_4_implementedDSRCREPORTABNORMALOBE;
				if (DSRC_REPORTABNORMALOBE_TIMEA_MIN_TSP == 0.0)	{
					setverdict(inconc);
					f_addLogEntry("Cannot perform minimum time test because IUT sets it to 0");
					stop;			  
				};			
				 
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
                // Send one valid DSRC_REPORTABNORMALOBE
				v_apduForSending := m_apduNoAuthInitTester({m_aduReportAbnormalObe}); 
 
 				f_sendAndLogApdu(v_apduForSending);                 

				// Do not wait for positive Ack
                // Send one one  APDU containg one different valid ReportAbnormalOBEADU before TIMEA_MIN
				v_apduForSending := m_apduNoAuthInitTester(
					{modifies m_aduReportAbnormalObe:= {
					  	abnormalOBEReasonCode := AbnormalOBEReasonCode_obeIsNotWorkingProperly_
					  	}
					});                 
				f_sendAndLogApdu(v_apduForSending);                 
              	// Wait for negative Ack with ADUReasonCode field = requestSentTooOften (if positive Ack or not received set test failure)                	
				// Set timer
                t_step.start(DSRC_REPORTABNORMALOBE_TIME1_MAX_TSP);
				// Step #2: Wait for NAck ADU				 					
				// Either we receive an APDU containing  NAck or the timeout expires
				// timeout expiration is handled in the altstep branch

				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(DSRC_REPORTABNORMALOBE_TIME1_MIN_TSP); 
						setverdict(pass);
						}
                	} // End of alt statement               
                f_closeDownMtc(); 					
				} // End of  TP_TSP_DSRC_REPORTABNORMALOBE_BI_08             		
			
		} // End of group Invalid_Behaviour 
	} // End of group DSRC_REPORTABNORMALOBE
    
    group GNSS_TOLLDECLARATION {
         group Valid_Behaviour {
           testcase TP_TSP_GNSS_TOLLDECLARATION_BV_01() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_TOLLDECLARATION_BV_01: Verify that the TSP correctly performs a GNSS.TOLLDECLARATION transaction with actionCodes = send, revoke and adjust 
                  * @remark  [16986:2016], Clause 8.1 and Table A.1/2 AND Table A.2/2 AND Table A.52/3
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				// Step 1: Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send three valid TollDeclarationADUs with actionCode = send, revoke, and adjust, respectively
				var InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut(
					{modifies mw_aduTollDeclaration:= {	actionCode := ActionCode_send_	}},
					{modifies mw_aduTollDeclaration:= {	actionCode := ActionCode_adjust_}},
					{modifies mw_aduTollDeclaration := { actionCode := ActionCode_revoke_}}
				);
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SENDREVOKEADJUST);												
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(GNSS_TOLLDECLARATIONS_TIMEA_MIN_TSP); 
					
						var TollDeclarationId v_idReceived1 := v_apduReceived.infoExchangeContent.adus.tollDeclarationADUs[1].tollDeclarationId;
						var TollDeclarationId v_idReceived2 := v_apduReceived.infoExchangeContent.adus.tollDeclarationADUs[2].tollDeclarationId;
						var TollDeclarationId v_idReceived3 := v_apduReceived.infoExchangeContent.adus.tollDeclarationADUs[3].tollDeclarationId;				

						if ((v_idReceived1 == v_idReceived2) and (v_idReceived1 == v_idReceived3)){
							setverdict(pass);
							// Step3: Send DefaultAck with correct identifier and set verdict
							f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP);
							} else {
							f_addLogEntry("TollDeclaration Ids mismatch");
							setverdict(fail);
						};
					}
				} // End of alt statement 
			f_closeDownMtc();               
            } // End of TP_TSP_GNSS_TOLLDECLARATION_BV_01
           
 		} // End of group Valid_Behaviour
         
        group Invalid_Behaviour {
			// No Test Cases are defined for invalid behaviour.		
        } // End of group Invalid_Behaviour
    } // End of group GNSS_TOLLDECLARATION

    group GNSS_BILLINGDETAILS_TSP {
    	group Valid_Behaviour {
    		testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_01() runs on MainTestComponent system TestAdapter {
    			/**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_01: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with BillingDetailsADUs
				  * @desc 	 containing all permutations of present and not present optional fields that vary in the IUT implementation, all with actionCode=send 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_3_implementedGNSSTOLLDECLARATION and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SEND);												
				//  Wait for GNSS.TOLLDECLARATION
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({modifies mw_aduTollDeclaration:= {	actionCode := ActionCode_send_}})) -> value v_apduReceived {
						// Log what we received
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP); 	
					}				
 				} // End of alt statement 
				
				// Step 1: Trigger IUT with GNSS_BILLINGDETAILS_TSP_TR_TSP_1_SEND to send  valid BillingDetailsADUs with:
					// actionCode = send
					// all permutations of present and not present optional fields that vary in the IUT implementation
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_SEND);				
				
				//  Wait for GNSS.BILLINGDETAILS
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(Adus:{billingDetailsADUs:={mw_aduGnssBillingDetails}}))-> value v_apduReceived {
						// Log what we received							
						// Send Ack within time constraints
						f_logReceivedWaitAndAcknowledge(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TSP);
							
						// Set test success
						setverdict(pass);						
						}
 					} // End of alt statement
				f_closeDownMtc();
    		} // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_01           
    		
    		testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_02() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_02: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with single BillingDetailsADU with actionCode = adjust and no optional fields 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                  
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_3_implementedGNSSTOLLDECLARATION and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SEND);												
				//  Wait for GNSS.TOLLDECLARATION
				
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({modifies mw_aduTollDeclaration:= {	actionCode := ActionCode_send_}})) -> value v_apduReceived {
						// Log what we received
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP); 	
					}				
				} // End of alt statement 
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_SEND);				
				
				//  Wait for GNSS.BILLINGDETAILS
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(Adus:{billingDetailsADUs:={mw_aduGnssBillingDetails}})) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TSP); 
							
						// Send NAck within time constraints
						f_wait(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduNoAuthRespTester(v_apduReceived, AduReasonCode_billingDetailsAmountRejected_));
					}
 				} // End of alt statement
				// Retrieve all BillingDetails ADUs with action code=send and store their IDs in v_receivedIds
				var Adus v_receivedBillingDetails := v_apduReceived.infoExchangeContent.adus;
				var integer v_numOfReceivedBillingDetails := sizeof(v_receivedBillingDetails);
				var RoBillingDetailsId v_receivedIds;
				var integer v_currentBillingDetailsId :=0;
				for (var integer v_loop :=0 ; v_loop < v_numOfReceivedBillingDetails; v_loop := v_loop+1)
					{
					  if (v_receivedBillingDetails[v_loop].actionCode == ActionCode_send_) {
					    v_receivedIds[v_currentBillingDetailsId] := v_receivedBillingDetails[v_loop].billingDetailsId;
					    v_currentBillingDetailsId := v_currentBillingDetailsId + 1;
					  };
					}; // End of for
				if (sizeof(v_receivedIds) == 0) {
				  	setverdict(fail);
					f_addLogEntry("Requested BillingDetails with Actioncode send, none received");
					stop;
					};
				// Step 1: Trigger IUT with GNSS_BILLINGDETAILS_TSP_TR_TSP_1_ADJUST to send one APDU containing one valid BillingDetailsADU with:
				//			actionCode = adjust
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_ADJUST);				
				
				//  Wait for GNSS.BILLINGDETAILS
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(Adus:{billingDetailsADUs:={mw_aduGnssBillingDetails}})) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TSP);
						setverdict(pass);						
					}
 				} // End of alt statement
				v_receivedBillingDetails := v_apduReceived.infoExchangeContent.adus;
				v_numOfReceivedBillingDetails := sizeof(v_receivedBillingDetails);
				var boolean v_oneFound := false;
				for (var integer v_loop :=0; v_loop < v_numOfReceivedBillingDetails; v_loop := v_loop+1)
					{
					  if (
					  	(v_receivedBillingDetails[v_loop].actionCode == ActionCode_adjust_) and 
					  	match(v_receivedBillingDetails[v_loop].billingDetailsId, v_receivedIds)
					  ) {
					    v_oneFound := true;
					    break;
					  };
					}; // End of for				
				if (v_oneFound) {setverdict(pass)}
				else {setverdict(fail)};
				f_closeDownMtc();   						           				                                
               
			} // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_02           

           	testcase TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_03() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_03: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TSP transaction with revoking a single BillingDetailsADU containing only mandatory fields 
                  * @remark  [16986:2016], Clause 8.2.2 AND 8.2.4 and Table A.1/2 AND Table A.2/1 AND Table A.52/1 AND Table A.56/6
                  */
                 // Initialisation 
                 	// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one APDU containing one valid TollDeclarationADU
                 	// Send a positive Ack to conclude the TOLLDECLARATION transaction
                 	// Trigger IUT with GNSS.BILLINGDETAILS.TR_TSP_1 to send a valid BillingDetails ADU with billingDetailsNum field value = 1
                 	// Send a positive Ack to conclude the BILLINGDETAILS ADU
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_3_implementedGNSSTOLLDECLARATION and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SEND);												
				//  Wait for GNSS.TOLLDECLARATION
				
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut({modifies mw_aduTollDeclaration:= {	actionCode := ActionCode_send_}})) -> value v_apduReceived {
						// Log what we received
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP); 	
					}				
				} // End of alt statement 
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_SEND);				
				
				//  Wait for GNSS.BILLINGDETAILS
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(Adus:{billingDetailsADUs:={mw_aduGnssBillingDetails}})) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TSP); 
							
						// Send NAck within time constraints
						f_wait(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduNoAuthRespTester(v_apduReceived, AduReasonCode_billingDetailsAmountRejected_));
						}
 					} // End of alt statement
				// Retrieve all BillingDetails ADUs with action code=send and store their IDs in v_receivedIds
				var Adus v_receivedBillingDetails := v_apduReceived.infoExchangeContent.adus;
				var integer v_numOfReceivedBillingDetails := sizeof(v_receivedBillingDetails.billingDetailsADUs);
				var RoBillingDetailsId v_receivedIds;
				var integer v_currentBillingDetailsId :=0;
				for (var integer v_loop :=0; v_loop < v_numOfReceivedBillingDetails; v_loop := v_loop+1)
					{
					  if (v_receivedBillingDetails.billingDetailsADUs[v_loop].actionCode == ActionCode_send_) {
					    v_receivedIds[v_currentBillingDetailsId] := v_receivedBillingDetails.billingDetailsADUs[v_loop].billingDetailsId;
					    v_currentBillingDetailsId := v_currentBillingDetailsId + 1;
					  };
					}; // End of for
				if (sizeof(v_receivedIds) == 0) {
				  	setverdict(fail);
					f_addLogEntry("Requested BillingDetails with Actioncode send, none received");
					stop;
					};
				// Step 1: Trigger IUT with GNSS_BILLINGDETAILS_TSP_TR_TSP_1_REVOKE to send one APDU containing one valid BillingDetailsADU with:
					// actionCode = ActionCode_revoke_
					// only mandatory fields present with valid values
					// billingDetailsNum field value = same as previous sent Billing Details
				f_sendAndLogTrigger(GNSS_BILLINGDETAILS_TSP_TR_TSP_1_REVOKE);				
				
				//  Wait for GNSS.BILLINGDETAILS
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(Adus:{billingDetailsADUs:={mw_aduGnssBillingDetails}})) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_BILLINGDETAILS_TSP_TIME1_MIN_TSP);
						setverdict(pass);						
						}
 					} // End of alt statement
				v_receivedBillingDetails := v_apduReceived.infoExchangeContent.adus;
				v_numOfReceivedBillingDetails := sizeof(v_receivedBillingDetails);
				var boolean v_oneFound := false;
				for (var integer v_loop :=0; v_loop < v_numOfReceivedBillingDetails; v_loop := v_loop+1)
					{
					  if ((v_receivedBillingDetails.billingDetailsADUs[v_loop].actionCode == ActionCode_revoke_) and match(v_receivedBillingDetails.billingDetailsADUs[v_loop].billingDetailsId, v_receivedIds)) {
					    v_oneFound := true;
					    break;
					  };
					}; // End of for				
				if (v_oneFound) {setverdict(pass)}
				else {setverdict(fail)};
				f_closeDownMtc();   						           				                                

			} // End of TP_TSP_GNSS_BILLINGDETAILS_TSP_BV_03           

 		} // End of group Valid_Behaviour
         
		group Invalid_Behaviour {
        	// No Test Cases are defined for invalid behaviour.		
        } // End of group Invalid_Behaviour

	} // End of group GNSS_BILLINGDETAILS_TSP
    
	group GNSS_BILLINGDETAILS_TC {
         // Base TCs shall be carried out in addition and prior to the TCs listed below.
         group Valid_Behaviour {

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_01() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_01: Verify that the TSP correctly performs 
                  * @desc	 a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU with no 
                  * @desc    optional fields except includedDiscounts field and actionCode=send 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS_TOLLDECLARATION_TR_TSP_1_SEND to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SEND);
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(Adus:{tollDeclarationADUs:={mw_aduTollDeclaration}})) -> value v_apduReceived {
						// Log what we received
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP); 	
						}				
					} // End of alt statement
				// Extract the TollDeclaration ADU and its relevant fields to be used later
				var TollDeclarationADU v_receivedTollDeclaration := v_apduReceived.infoExchangeContent.adus;
				var TollDeclarationId v_receivedTollDeclarationId := v_receivedTollDeclaration.tollDeclarationId;
				var ObeId v_receivedObeId := v_receivedTollDeclaration.gnssTollDeclaration.chargeReport.obeId; // To be used as UserId in BillingDetails
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 	// action code = send
                 	// includedDiscounts in usageList with textDetail field being set according to values specified in Table A.54 of CEN/TS 16986:2016
				v_apduForSending := m_apduNoAuthInitTester({m_aduGnssBillingDetails(
						1, // BillingDetailsnum
						{obeId := v_receivedObeId }, // UserId
						TD_PERIOD_1,
						{{
								usageListEntry:={
									freeTextDetail := {
										textLanguage:= TD_GNSS_BILLINGDETAILS_LANG,
										textDetail := TD_GNSS_BILLINGDETAILS_TEXT
									},
									includedDiscounts :={
										discounts := 10, 
							  			discountQualifier := DiscountQualifier_userDiscount_ 
									}
								}
						}},
						TD_DISCOUNT_AMOUNT, // Amount in Billing Details
						v_receivedTollDeclarationId, // Reference to received Toll Declaration
						ActionCode_send_
				)});                 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                  
           } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_01           

		   testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_02() runs on MainTestComponent system TestAdapter {
				  /**
				  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_02: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with no optional fields, actionCode = send and having selected forSectionedRoads 
				  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
				  */
				 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   				
				//Trigger IUT with GNSS_TOLLDECLARATION_TR_TSP_1_SEND_SECTIONED to send one valid TollDeclarationADU with actionCode = send and CHOICE forSectionedRoad
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SEND_SECTIONED);
				f_receiveTollDeclSendBillingDetReceiveAck({m_sectionedRoadGnssUsageList});
				f_closeDownMtc();                
		   } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_02           

		   testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_03() runs on MainTestComponent system TestAdapter {
				  /**
				  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_03: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC 
				  * @desc 	 transaction with a single BillingDetailsADU
				  * @desc    with no optional fields, actionCode = send and having selected forTravellingInArea 
				  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
				  */
				 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   				
				//Trigger IUT with GNSS_TOLLDECLARATION_TR_TSP_1_SEND_TRAVELLINGINAREA to send one valid TollDeclarationADU with actionCode = send and CHOICE forTravellingInArea
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SEND_TRAVELLINGINAREA);
				f_receiveTollDeclSendBillingDetReceiveAck(m_stayingInAreaGnssUsageList);
				f_closeDownMtc();                
                
			} // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_03           

		   testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_04() runs on MainTestComponent system TestAdapter {
             
				  /**
				  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_04: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with no optional fields, actionCode = send and having selected forStayingInArea 
				  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
				  */
				 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   				
				//Trigger IUT with GNSS_TOLLDECLARATION_TR_TSP_1_SEND_STAYINGINAREA to send one valid TollDeclarationADU with actionCode = send and CHOICE forStayingInArea
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SEND_STAYINGINAREA);
				f_receiveTollDeclSendBillingDetReceiveAck(m_travellingInAreaGnssUsageList);
				f_closeDownMtc();                
                
			} // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_04           

		   testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_05() runs on MainTestComponent system TestAdapter {
				  /**
				  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_05: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with no optional fields, actionCode = send and having selected forCordonCrossings 
				  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
				  */
				 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   				
				//Trigger IUT with GNSS_TOLLDECLARATION_TR_TSP_1_SEND_CORDONCROSSING to send one valid TollDeclarationADU with actionCode = send and CHOICE forCordonCrossing
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SEND_CORDONCROSSING);
				f_receiveTollDeclSendBillingDetReceiveAck(m_cordonCrossingGnssUsageList);
				f_closeDownMtc();                
                
			} // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_05            

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_06() runs on MainTestComponent system TestAdapter {
             
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_06: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction
				  * @desc    with multiple BillingDetailsADUs with no optional fields 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                 // Initialisation 
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_adusTollDeclaration)) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP);
						}
					} // End of first alt statement
				// Extract the TollDeclaration ADU and its relevant fields to be used later
				var TollDeclarationADU v_receivedTollDeclaration := v_apduReceived.infoExchangeContent.adus;
				var TollDeclarationId v_receivedTollDeclarationId := v_receivedTollDeclaration.tollDeclarationId;
				var ObeId v_receivedObeId := v_receivedTollDeclaration.gnssTollDeclaration.chargeReport.obeId; // To be used as UserId in BillingDetails
                // Step 1: Send one valid APDU containing a number of valid BillingDetailsADU equal to GNSS.BILLINGDETAILS.TSP.PARAM1_MAX, with
                 	// action code = send 
                 	// no optional fields
                // Define record to contain adus
                var Adus v_adus;
				// Set all  ADUs of apdu
				for (var integer v_ind := 0; v_ind < (GNSS_BILLINGDETAILS_TSP_PARAM1_MAX_TSP - 1); v_ind := v_ind + 1){
					v_adus.billingDetailsADUs[v_ind] := m_aduGnssBillingDetails(
						v_ind,
						{obeId := v_receivedObeId }, // UserId
						TD_PERIOD_1,
						{{
							usageListEntry:={
								freeTextDetail := {
									textLanguage:= TD_GNSS_BILLINGDETAILS_LANG ,
									textDetail := TD_GNSS_BILLINGDETAILS_TEXT
								}
							},
							includedDiscounts:= omit,
							associatedEventData:=omit,
							externalCosts:=omit
						}},
						TD_BILLINGDETAILS_AMOUNT_1, // Minimum amount in Billing Details
						{v_receivedTollDeclarationId}, // Reference to received Toll Declaration
						ActionCode_send_				
					);							
				}; //End for
				v_apduForSending := m_apduNoAuthInitTester(v_adus);
				f_sendAndLogApdu(v_apduForSending);
				
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();                 
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_06
                
           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_07() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_07: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with actionCode = adjust and no optional fields
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_adusTollDeclaration)) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP);
					}
				} // End of first alt statement
				// Extract the TollDeclaration ADU and its relevant fields to be used later
				var TollDeclarationADU v_receivedTollDeclaration := v_apduReceived.infoExchangeContent.adus.tollDeclarationADUs[0];
				var TollDeclarationId v_receivedTollDeclarationId := v_receivedTollDeclaration.tollDeclarationId;
				var ObeId v_receivedObeId := v_receivedTollDeclaration.gnssTollDeclaration.chargeReport.obeId; // To be used as UserId in BillingDetails
				var ExtendedPaymentAmount v_amount:=MAX_ACCEPTED_BILLINGDETAILS_AMOUNT;
				v_amount.paymentFeeAmount:=v_amount.paymentFeeAmount+1; //set it to a value that is so high it will provoke a Nack
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 // action code = send
                 // billingDetailsAmount set to a value (to be modified later)
				v_apduForSending := m_apduNoAuthInitTester(
					{m_aduGnssBillingDetails(
						1, // BillingDetailsnum
						{obeId := v_receivedObeId }, // UserId
						TD_PERIOD_1,
						{{usageListEntry:={freeTextDetail := {
							textLanguage:= TD_GNSS_BILLINGDETAILS_LANG,
							textDetail := TD_GNSS_BILLINGDETAILS_TEXT
						}}}},
						v_amount, // Amount in Billing Details exceeds the allowed maximum
						{v_receivedTollDeclarationId}, // Reference to received Toll Declaration
						ActionCode_send_
						)}
				);                 
				f_sendAndLogApdu(v_apduForSending);
				
                // Wait for negative Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP
				// Set timer
                t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_billingDetailsAmountRejected_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_billingDetailsAmountRejected_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
					
                 // Step 1: Send one valid APDU containing BillingDetailsADU as the only ADU, where:
                 	// the values of all fields in BillingDetailsADU being valid and within the range specified by the IUT
                 	// no optional fields are specified
                 	// billingDetailsNum referencing the previously sent BillingDetailsADU
                 	// action code = adjust
                 	// value of the fee being in an acceptable range

				v_apduForSending := m_apduNoAuthInitTester(
					{m_aduGnssBillingDetails(
						1, // BillingDetailsnum same as previously sent BillingDetailsADU
						{obeId := v_receivedObeId }, // UserId
						TD_PERIOD_1,
						{{usageListEntry:={freeTextDetail := {
							textLanguage:= TD_GNSS_BILLINGDETAILS_LANG,
							textDetail := TD_GNSS_BILLINGDETAILS_TEXT
						}}}},
						MAX_ACCEPTED_BILLINGDETAILS_AMOUNT, // Amount in Billing Details less than the allowed maximum
						{v_receivedTollDeclarationId}, // Reference to received Toll Declaration
						ActionCode_adjust_
					)}
				);                 
				f_sendAndLogApdu(v_apduForSending);
				                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						setverdict(pass);
					}
				} // End of Alt statement
				f_closeDownMtc();  			
                
           } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_07                 

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BV_08() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_07: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with actionCode = adjust and no optional fields
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_adusTollDeclaration)) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP);
						}
					} // End of first alt statement
				// Extract the TollDeclaration ADU and its relevant fields to be used later
				var TollDeclarationADU v_receivedTollDeclaration := v_apduReceived.infoExchangeContent.adus;
				var TollDeclarationId v_receivedTollDeclarationId := v_receivedTollDeclaration.tollDeclarationId;
				var ObeId v_receivedObeId := v_receivedTollDeclaration.gnssTollDeclaration.chargeReport.obeId; // To be used as UserId in BillingDetails

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 // action code = send
                 // billingDetailsAmount set to a value (to be modified later)
				v_apduForSending := m_apduNoAuthInitTester(
					{m_aduGnssBillingDetailsSpecialised(1,	{obeId := v_receivedObeId }, v_receivedTollDeclarationId)}
				);                 
				f_sendAndLogApdu(v_apduForSending);
				
                 // Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						}
					} // End of Alt statement 
                 // Step 1: Send one valid APDU containing BillingDetailsADU as the only ADU, where:
                 	// the values of all fields in BillingDetailsADU being valid and within the range specified by the IUT
                 	// no optional fields are specified
                 	// billingDetailsNum referencing the previously sent BillingDetailsADU
                 	// action code = revoke

				v_apduForSending := m_apduNoAuthInitTester(
					{m_aduGnssBillingDetails(
						1, // BillingDetailsnum same as previously sent BillingDetailsADU
						{obeId := v_receivedObeId }, // UserId
						TD_PERIOD_1,
						{{usageListEntry:={freeTextDetail := {
							textLanguage:= TD_GNSS_BILLINGDETAILS_LANG ,
							textDetail := TD_GNSS_BILLINGDETAILS_TEXT
						}}}},
						MAX_ACCEPTED_BILLINGDETAILS_AMOUNT - 1, // Amount in Billing Details less than the allowed maximum
						{v_receivedTollDeclarationId}, // Reference to received Toll Declaration
						ActionCode_revoke_
						)}
					);                 
				f_sendAndLogApdu(v_apduForSending);                 
                 // Step 2: Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {					  
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						setverdict(pass);
						}
					} // End of Alt statement					
				f_closeDownMtc();					           
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BV_08                                     
 		} // End of group Valid_Behaviour
                 
         group Invalid_Behaviour {

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_01() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_01: Verify that the TSP correctly responds to a series 
                  * @desc	of BillingDetailsADUs bearing only mandatory fields,
				  * @desc    each BillingDetailsADU having one mandatory field bearing an incorrect value 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                 // Initialisation 
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_2_implementedGNSSBILLINGDETAILSTC and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_adusTollDeclaration)) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP);
						}
					} // End of first alt statement
            	// Step 1: Send one valid APDU containing 13 valid BillingDetailsADUs, each one with the following parameters respectively set to one incorrect value:
         		// billingDetailsId.issuerId, tollContext, userId, Period, billingDetailsAmount, usageDetails.contextName, usageDetails.appliedUserClass, usageDetails.perDeclaredVehicleClasses, usageDetails.appliedTimeClass, usageDetails.entranceTime, usageList.ListofSections.chargeObjectId, exitChargeObject, exitTime
				// Extract the TollDeclaration ADU and its relevant fields to be used later
				var TollDeclarationADU v_receivedTollDeclaration := v_apduReceived.infoExchangeContent.adus;
				var TollDeclarationId v_receivedTollDeclarationId := v_receivedTollDeclaration.tollDeclarationId;
				var ObeId v_receivedObeId := v_receivedTollDeclaration.gnssTollDeclaration.chargeReport.obeId; // To be used as UserId in BillingDetails
				var UserId v_userId:={obeId :=v_receivedObeId};
				var Adus v_adus;
				
				//TODO extract magic numbers into Tester Data (possibly as constants)
				v_adus.billingDetailsADUs[0]:= {modifies m_aduGnssBillingDetailsSpecialised(1,	v_userId, v_receivedTollDeclarationId):= {
					billingDetailsId := {issuerId:=0} //billingDetailsIssuerIdRejected
				}};

				v_adus.billingDetailsADUs[1]:={modifies m_aduGnssBillingDetailsSpecialised(2,	v_userId, v_receivedTollDeclarationId):= {
					tollContext:={providerIdentifier:= 0} ///billingDetailsContextIdRejected
				}};

				v_adus.billingDetailsADUs[2]:=m_aduGnssBillingDetailsSpecialised(3,	{}, v_receivedTollDeclarationId); //billingDetailsUserIdRejected 							

				v_adus.billingDetailsADUs[3]:={modifies m_aduGnssBillingDetailsSpecialised(4,	v_userId, v_receivedTollDeclarationId):= {
					billingDetailsAmount:={paymentFeeAmount:=-5} //billingDetailsAmountRejected
				}};
							
				v_adus.billingDetailsADUs[4]:={modifies m_aduGnssBillingDetailsSpecialised(5,	v_userId, v_receivedTollDeclarationId):= {
				  	usageDetails := {contextName:="AREA 51, NEVADA"} //billingDetailsContextNameRejected
				}};
							
				v_adus.billingDetailsADUs[5]:={modifies m_aduGnssBillingDetailsSpecialised(6,	v_userId, v_receivedTollDeclarationId):= {
	  				usageDetails := {appliedUserClass:="NON-EXISTING USER CLASS"} //billingDetailsAppliedUserClassRejected

				}};
				
				v_adus.billingDetailsADUs[6]:={modifies m_aduGnssBillingDetailsSpecialised(7,	v_userId, v_receivedTollDeclarationId):= {
	  				usageDetails := {
						perDeclaredVehicleClasses:={{
							declaredVehicleClass:="NON-EXISTING VEHICLE CLASS"
						}} //billingDetailsDeclaredVehicleClassRejected 
	  				}	  				
				}};
				
				v_adus.billingDetailsADUs[7]:={modifies m_aduGnssBillingDetailsSpecialised(8,	v_userId, v_receivedTollDeclarationId):= {
					usageDetails := {
						perDeclaredVehicleClasses:={{
							perUsedTimeClasses:={{
								appliedTimeClass:="NON-EXISTING TIME CLASS"//billingDetailsAppliedTimeClassRejected 
							}}
						}}
					}	  				  				
				}};
				
				v_adus.billingDetailsADUs[8]:=m_aduGnssBillingDetails(
					9,
					v_userId,
					TD_PERIOD_1,
					{{usageListEntry:={forStayingInArea := {
						qualifier:= {entranceTime:=fx_getUtc(86400)},//set to 24 hours in the future - billingDetailsEntranceTimeRejected
						stayedDuration:=1000,
						chargeUnit:={time:={dur:=100,durUnit:=DurUnit_seconds_}}
					}}}},
					MAX_ACCEPTED_BILLINGDETAILS_AMOUNT,
					{v_receivedTollDeclarationId},
					ActionCode_send_
				);			
			
				v_adus.billingDetailsADUs[9]:=m_aduGnssBillingDetails(
					10,
					v_userId,
					TD_PERIOD_1,
					{{usageListEntry:={forSectionedRoads := {
						howManyTimes:=1,
						listOfSections:={{
							chargeObjectId:="NON-EXISTING CHARGE OBJECT ID" //billingDetailsIntermediateSectionRejected
						}}
					}}}},
					MAX_ACCEPTED_BILLINGDETAILS_AMOUNT,
					{v_receivedTollDeclarationId},
					ActionCode_send_
				);			

				v_apduForSending := m_apduNoAuthInitTester(v_adus);                 
				f_sendAndLogApdu(v_apduForSending);						
               	
               	
               	
                 // Step 2: Wait for negative Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP with issue list present and the following issue codes:
                 	// billingDetailsIssuerIdRejected, billingDetailsContextIdRejected, billingDetailsUserIdRejected, billingDetailsPeriodRejected, billingDetailsAmountRejected, billingDetailsContextNameRejected, billingDetailsAppliedUserClassRejected, billingDetailsDeclaredVehicleClassRejected, billingDetailsAppliedTimeClassRejected, billingDetailsEntranceTimeRejected, billingDetailsIntermediateSectionRejected, billingDetailsExitChargeObjectRejected, billingDetailsExitTimeRejected
				// Set timer
                t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);                 
  				
				alt {
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, 
						{
							{1,AduReasonCode_billingDetailsIssuerIdRejected_},
							{2,AduReasonCode_billingDetailsContextIdRejected_},
							{3,AduReasonCode_billingDetailsUserIdRejected_}, 
							{4,AduReasonCode_billingDetailsAmountRejected_}, 
							{5,AduReasonCode_billingDetailsContextNameRejected_}, 
							{6,AduReasonCode_billingDetailsAppliedUserClassRejected_}, 
							{7,AduReasonCode_billingDetailsDeclaredVehicleClassRejected_}, 
							{8,AduReasonCode_billingDetailsAppliedTimeClassRejected_}, 
							{9,AduReasonCode_billingDetailsEntranceTimeRejected_}, 
							{10,AduReasonCode_billingDetailsIntermediateSectionRejected_} 					  
						}
					)) -> value v_apduReceived {
						// Log what we received
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						setverdict(pass);
					}
				} // End of Alt statement
				f_closeDownMtc();  			
                
			} // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_01                     

           	testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_02() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BV_07: Verify that the TSP correctly performs a GNSS.BILLINGDETAILS.TC transaction with a single BillingDetailsADU
				  * @desc    with actionCode = adjust and no optional fields
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2 AND Table A.56/6
                  */
                 // Initialisation
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_1_implementedGNSSBILLINGDETAILSTSP and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				 
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1);
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(mw_adusTollDeclaration)) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP);
						}
					} // End of first alt statement
				// Extract the TollDeclaration ADU and its relevant fields to be used later
				var TollDeclarationADU v_receivedTollDeclaration := v_apduReceived.infoExchangeContent.adus;
				var TollDeclarationId v_receivedTollDeclarationId := v_receivedTollDeclaration.tollDeclarationId;
				var ObeId v_receivedObeId := v_receivedTollDeclaration.gnssTollDeclaration.chargeReport.obeId; // To be used as UserId in BillingDetails

                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with:
                 // action code = send
                 // billingDetailsAmount set to a value (to be modified later)
				v_apduForSending := m_apduNoAuthInitTester(
					{m_aduGnssBillingDetails(
						1, // BillingDetailsnum
						{obeId := v_receivedObeId }, // UserId
						TD_PERIOD_1,
						{{usageListEntry:={freeTextDetail := {
							textLanguage:= TD_GNSS_BILLINGDETAILS_LANG,
							textDetail := TD_GNSS_BILLINGDETAILS_TEXT
						}}}},
						TD_BILLINGDETAILS_AMOUNT_1, // Valid amount in Billing Details
						v_receivedTollDeclarationId, // Reference to received Toll Declaration
						ActionCode_send_
						)}
					);                 
				f_sendAndLogApdu(v_apduForSending);
				
                 // Wait for positive Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP
				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);                 
				alt {
					[] mtcPort.receive(mw_apduDefaultAckIut(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						}
					} // End of Alt statement 
                 // Step 1: Send one valid APDU containing BillingDetailsADU as the only ADU, where:
                 	// the values of all fields in BillingDetailsADU being valid and within the range specified by the IUT
                 	// no optional fields are specified
                 	// billingDetailsNum referencing the previously sent BillingDetailsADU
                 	// action code = revoke

				v_apduForSending := m_apduNoAuthInitTester(
					{m_aduGnssBillingDetails(
						PX_BILLINGDETAILSNUM_NOT_EXISTING, // BillingDetailsnum same as previously sent BillingDetailsADU
						{obeId := v_receivedObeId }, // UserId
						TD_PERIOD_1,
						{{usageListEntry:={freeTextDetail := {
							textLanguage:= TD_GNSS_BILLINGDETAILS_LANG,
							textDetail := TD_GNSS_BILLINGDETAILS_TEXT
						}}}},
						TD_BILLINGDETAILS_AMOUNT_1, // Valid amount in Billing Details
						v_receivedTollDeclarationId, // Reference to received Toll Declaration
						ActionCode_revoke_
						)}
					);    
				f_sendAndLogApdu(v_apduForSending);                 

                 // Step 2: Wait for negative Ack within GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP identifying the APDU containing the BillingDetailsADU numbered 14 and with issueCode= semanticError 
				// Set timer
                t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);                 

				alt {
					[] mtcPort.receive(mw_apduNAckAllAdusNoAuthIut(v_apduForSending, AduReasonCode_semanticError_)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					[] mtcPort.receive(mw_apduNAckIndividualIssuesIut(v_apduForSending, m_roNackParamsSingle(1, AduReasonCode_semanticError_))) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP); 
						setverdict(pass);
						}
					} // End of Alt statement
				f_closeDownMtc();  
                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_03           

           testcase TP_TSP_GNSS_BILLINGDETAILS_TC_BI_04() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_BILLINGDETAILS_TC_BI_04: Verify that the TSP correctly responds to a BillingDetailsADU sent earlier than allowed 
                  * @remark  [16986:2016], Clause 8.2.3 AND 8.2.4 and Table A.1/2 AND Table A.2/2 AND Table A.52/2
                  */
                 // Initialisation 
					// Trigger IUT with GNSS.TOLLDECLARATION.TR_TSP_1 to send one valid TollDeclarationADU with actionCode = send
					//  Wait for GNSS.TOLLDECLARATION
					// Send positive Ack within time constraints
					// Send one valid APDU containing one valid BillingDetailsADU with action code = send and no optional parameters
					// Wait for positive Ack
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A52_2_implementedGNSSBILLINGDETAILSTC and ICS_A52_3_implementedGNSSTOLLDECLARATION;
				if (GNSS_BILLINGDETAILS_TC_TIME0_MIN_TSP == 0.0)	{
					setverdict(inconc);
					f_addLogEntry("Cannot perform minimum time test because IUT sets it to 0");
					stop;			  
				};							 
				f_intialiseMtc(v_runOrNot);                   
				// Trigger IUT with GNSS_TOLLDECLARATION_TR_TSP_1_SEND to send one valid TollDeclarationADU with actionCode = send
				f_sendAndLogTrigger(GNSS_TOLLDECLARATION_TR_TSP_1_SEND);
				// Receive the correct adu, send positive ack
				alt {
					[] mtcPort.receive(mw_apduNoAuthInitIut(Adus:{tollDeclarationADUs:={mw_aduTollDeclaration}})) -> value v_apduReceived {
						// Log what we received
						f_logReceivedWaitAndAcknowledge(GNSS_TOLLDECLARATIONS_TIME1_MIN_TSP); 	
						}				
					} // End of alt statement
				// Extract the TollDeclaration ADU and its relevant fields to be used later
				var TollDeclarationADU v_receivedTollDeclaration := v_apduReceived.infoExchangeContent.adus;
				var TollDeclarationId v_receivedTollDeclarationId := v_receivedTollDeclaration.tollDeclarationId;
				var ObeId v_receivedObeId := v_receivedTollDeclaration.gnssTollDeclaration.chargeReport.obeId; // To be used as UserId in BillingDetails
                 // Step 1: Send one valid APDU containing one valid BillingDetailsADU with action code = send
				v_apduForSending := m_apduNoAuthInitTester({m_aduGnssBillingDetails(
						1, // BillingDetailsnum
						{obeId := v_receivedObeId }, // UserId
						TD_PERIOD_1,
						{{usageListEntry:={freeTextDetail := {
							textLanguage:= TD_GNSS_BILLINGDETAILS_LANG,
							textDetail := TD_GNSS_BILLINGDETAILS_TEXT
						}}}},
						TD_BILLINGDETAILS_AMOUNT_1, // Amount in Billing Details
						v_receivedTollDeclarationId, // Reference to received Toll Declaration
						ActionCode_send_
						)});                 
				f_sendAndLogApdu(v_apduForSending);
                 // Step 1: Send another valid APDU containing one valid BillingDetailsADU with action code = send before TIME0_MIN
				v_apduForSending := m_apduNoAuthInitTester({m_aduGnssBillingDetails(
						2, // BillingDetailsnum
						{obeId := v_receivedObeId }, // UserId
						TD_PERIOD_1,
						{{usageListEntry:={freeTextDetail := {
							textLanguage:= TD_GNSS_BILLINGDETAILS_LANG,
							textDetail := TD_GNSS_BILLINGDETAILS_TEXT
						}}}},
						TD_BILLINGDETAILS_AMOUNT_1, // Amount in Billing Details
						v_receivedTollDeclarationId, // Reference to received Toll Declaration
						ActionCode_send_
						)});        				
				f_sendAndLogApdu(v_apduForSending);                 

              	// Wait for negative Ack with ADUReasonCode field = requestSentTooOften (if positive Ack or not received set test failure)                	

				// Set timer
                 t_step.start(GNSS_BILLINGDETAILS_TC_TIME1_MAX_TSP);
				alt {
					[] mtcPort.receive(mw_apduNAckRequestSentTooOften(v_apduForSending)) -> value v_apduReceived {
						f_logReceivedThenCheckAndStopTime(GNSS_BILLINGDETAILS_TC_TIME1_MIN_TSP);
						setverdict(pass);
						}
                	} // End of alt statement
                
                f_closeDownMtc();  			
                                
                } // End of TP_TSP_GNSS_BILLINGDETAILS_TC_BI_04           
		
        } // End of group Invalid_Behaviour

    } // End of group GNSS_BILLINGDETAILS_TC
    
    group GNSS_PAYMENTANNOUNCEMENT {
         group Valid_Behaviour {
           
           testcase TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_01() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_01: Verify that the TSP correctly performs the GNSS.PAYMENTANNOUNCEMENT transaction with actionCode=send 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.2/2 AND Table A.52/4 
                  */                 
                 // Initialisation 
				// The IUT is supposedly being prepared with valid test toll declaration data
					
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A2_2_isGnss and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Step 1: Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_SEND to send one valid PaymentAnnouncementADU with actionCode = send
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_SEND);												
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				var InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut(
					{modifies mw_aduPaymentAnnouncement:= {
					  	actionCode := ActionCode_send_
					  	}
					});
					
				// Wait for PaymentAnnouncementADU within allowed time constraints
				t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TSP);	
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TSP);
						setverdict(pass);
						}						
 					} // End of alt statement 
               	f_closeDownMtc();
               
                } // End of TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_01                    

           testcase TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_02() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_02: Verify that the TSP correctly performs the 
                  * @desc    GNSS.PAYMENTANNOUCEMENT transaction with actionCode=adjust 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.2/2 AND Table A.52/4 
                  */
				var integer v_idReceived;
				var ExtendedPaymentAmount v_amountReceived;
                // Initialisation 

				// The IUT is supposedly being prepared with valid test toll declaration data
					
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A2_2_isGnss and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_A to send one valid PaymentAnnouncementADU with actionCode = send
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_SEND); 												
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				var InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut({paymentAnnouncementADUs:={
					modifies mw_aduPaymentAnnouncement:= {
					  	actionCode := ActionCode_send_
					}
				}});
				// Wait for PaymentAnnouncementADU within allowed time constraints
				t_step.start(TIMEOUT_FOR_SETUP_OF_TRANSACTION);	
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TSP);
						// Remember Payment Announcement ID and amount for future usage
						v_idReceived := v_apduReceived.infoExchangeContent.adus.PaymentAnnouncementADU.paymentAnnouncementID;
						v_amountReceived := v_apduReceived.infoExchangeContent.adus.PaymentAnnouncementADU.totalamount
					}
 				} // End of alt statement

				
				// Step 1: Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_ADJUST 
				// to send one valid PaymentAnnouncementADU with actionCode = adjust
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_ADJUST); 
				
				t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIMEB_MAX_TSP);
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				v_apduToBeReceived := mw_apduNoAuthInitIut(
					Adus:{
						paymentAnnouncementADUs:={{
							modifies mw_aduPaymentAnnouncement:={
							  	paymentAnnouncementID := v_idReceived,
							  	actionCode := ActionCode_adjust_							}
						}}
					}
				);
				// Wait for PaymentAnnouncementADU within allowed time constraints
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						f_logReceivedWaitAndAcknowledge(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TSP);
						// Set test success
						setverdict(pass);						
						}
 					} // End of alt statement
               	
               	f_closeDownMtc();
                               
           } // End of TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_02                    

           testcase TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_03() runs on MainTestComponent system TestAdapter {
                  /**
                  * @desc    TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_03: Verify that the TSP correctly performs the GNSS.PAYMENTANNOUCEMENT transaction with actionCode=revoke 
                  * @remark  [16986:2016], Clause 6.8 and Table A.1/2 AND Table A.2/2 AND Table A.52/4 
                  */
                // Initialisation 
				// The IUT is supposedly being prepared with valid test toll declaration data
				var integer v_idReceived;	
				var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A2_2_isGnss and ICS_A52_4_implementedGNSSPAYMENTANNOUNCEMENT;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
				
				// Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_SEND to send one valid PaymentAnnouncementADU with actionCode = send
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_SEND);												
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				var InfoExchange v_apduToBeReceived := mw_apduNoAuthInitIut({modifies mw_aduPaymentAnnouncement:= {actionCode := ActionCode_send_}});					
				
				// Wait for PaymentAnnouncementADU within allowed time constraints
				t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TSP);	
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
					// Send Ack within time constraints
						f_logReceivedWaitAndAcknowledge(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TSP);
						// Remember Payment Announcement ID for future usage
						v_idReceived := v_apduReceived.infoExchangeContent.adus.PaymentAnnouncementADU.paymentAnnouncementID;						
					}
 				} // End of alt statement

				// Step 1: Trigger IUT with GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_REVOKE to send one valid PaymentAnnouncementADU with actionCode = revoke
				f_sendAndLogTrigger(GNSS_PAYMENTANNOUNCEMENT_TR_TSP_1_REVOKE);												
				//  Wait for GNSS.PAYMENTANNOUNCEMENT
				v_apduToBeReceived := mw_apduNoAuthInitIut(
					{modifies mw_aduPaymentAnnouncement:= {
					  	paymentAnnouncementID := v_idReceived,
					  	actionCode := ActionCode_revoke_
					  	}
					});
				// Wait for PaymentAnnouncementADU within allowed time constraints
				t_step.start(GNSS_PAYMENTANNOUNCEMENT_TIME1_MAX_TSP);	
				alt {
					[] mtcPort.receive(v_apduToBeReceived) -> value v_apduReceived {
						// Log what we received
					// Send Ack within time constraints
						f_logReceivedWaitAndAcknowledge(GNSS_PAYMENTANNOUNCEMENT_TIME1_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAckTester(v_apduReceived));
						setverdict(pass);						
					}
 				} // End of alt statement
               	
               	f_closeDownMtc();					
                
        	} // End of TP_TSP_GNSS_PAYMENTANNOUNCEMENT_BV_03                    

 		} // End of group Valid_Behaviour
         
        group Invalid_Behaviour {
           // No Test Cases are defined for invalid behaviour.		           		
        } // End of group Invalid_Behaviour

    } // End of group GNSS_PAYMENTANNOUNCEMENT
}; // End of module Toll_Service_Provider

