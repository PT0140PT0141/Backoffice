/**
 * @author  PT0140 
 * @desc    This module provides test cases based on TS 16986 TPs
 * @see     [xxxx-1:2017]: Test suite structure and test purpose
 * @see     [xxxx-1:2016], Clause 5.2.1  Namimg conventions
 * @version $id$
 */
module EfcInfoExchange_TestCasesTsp {
 
    //importing other modules
    import from EfcInfoExchange_Interfaces all;
    import from EfcInfoExchange_Functions all;
    import from EfcInfoExchange_Pixits all;
    import from EfcInfoExchange_Ics all;
	import from EfcInfoExchange_Templates all;
    import from EfcInfoExchange_InteroperabilityStatement all;
    
    //importing ASN.1 data automatically translated into TTCN-3	
    import from EfcInfoExchange language "ASN.1:1997" all;
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    import from EfcDsrcApplication language "ASN.1:1997" all;
    
    //importing ASN.1 data manually translated into TTCN-3
    import from EfcInfoExchange_ParameterisedAsn1Data all;
    import from Common_ParametrisedAsn1Data all;
 
	
    /**
     /**
      * @desc    These Test Cases apply to Toll Service Provider claiming conformance to [16986:2016] and applying Test Purposes as from TS xxxxx:2018 Annex B
      * @remark  nn TCs
      */
    group Base {
         /**
          * @desc    Test subgroup objective:
          * - to test IUT with respect to the correctness of base and general functionalities that are required in many or all transaction types;
          */
     	group Valid_Behaviour {
             /**
              * @desc    TP_TSP_Base_BV_01: Verify that a TC validates correct infoExchanceAuthenticators in received APDUs and generates correct infoExchangeAuthenticators 
              * @remark  [16986:2016], Clause 6.2.2 and Table A.1/2 
              */
//             testcase TP_TSP_Base_BV_01() runs on IutComp system TestAdapter {
//                 
//             } // TP_TSP_Base_BV_01
        } // End of group Valid_Behaviour
         
        group Invalid_Behaviour {		
        } // End of group Invalid_Behaviour
        
    } // End of group Base
    
    group USERDETAILS {
    	group Valid_Behaviour {
			testcase TP_TSP_USERDETAILS_BV_01() runs on MainTestComponent system TestAdapter {
            	 	          
                /**
                 * @desc    TP_TSP_USERDETAILS_BV_01: Verify that the TSP correctly receives an APDU containing valid RequestADUs and provides valid ProvideUserDetailsADUs 
                 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
                 */
                   
                // Initialisation
                var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                // we want to ask for a random number of parameters randomly chosen among those supported
                // the v_userParameterRequest array will be made of a random number of elements containing randomly picked up
                // parameter identifiers from the list of supported parameters (PIXIT value)
                const integer totNoParams := sizeof(USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS);
                const integer noParamsToUse := float2int(rnd() * int2float(totNoParams));
				var UserParameterRequest v_userParameterRequests[noParamsToUse];   
                for (var integer v_ct :=0; v_ct<noParamsToUse;v_ct:=v_ct+1) {
                	//Note: float2int removes the fractional part and returns just the integer, it is NOT a rounding function. That is why this works
					v_userParameterRequests[v_ct] := USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS[float2int(rnd()) * totNoParams];
                };
                
                // Step1: send RequestADU
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests)}
					)
				);
                               
				//Set timer
                t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU(s) or the timeout expires
				// timeout expiration is handled in the altstep branch
                alt {
                	[] mtcPort.receive(mw_apduProvideUserDetails) -> value v_apduReceived{
                		                    		
 						// Log what we received
 						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
                        t_step.stop;
						
						// TODO PT140: Check the ADU record and find the one we are expecting. Either function or template
 
 						//Set verdict
 						setverdict(pass);
 					    			                              
                        // Step3: Send DefaultAck with correct identifier and set verdict
                        f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));

                	}
                } // End of alt statement
				
                f_closeDownMtc();  
			
            } // End of TP_TSP_USERDETAILS_BV_01
            
  			testcase TP_TSP_USERDETAILS_BV_02() runs on MainTestComponent system TestAdapter {
                /**
                 * @desc    TP_TSP_USERDETAILS_BV_02: TP_TSP_USERDETAILS_BV_02: Verify that the TSP correctly receives a RequestADU of type userDetailsRequest with listOfUsersParametersRequested containing user details that cannot be provided because of data privacy issues  
                 * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
                 */
                // Initialisation
                var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				v_userParameterRequests := PRIVACYBOUND_LIST_OF_PARAMETERS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc

                var UserParameterRequests v_userParameterRequests;   
                // Check if there are parameters that are privacy bound
                // If not, exit test
				if (sizeof (v_userParameterRequests) = 0) {
        			setverdict(inconclusive);
        			f_addLogEntry("Privacy bound parameters missing. Test cannot be executed");
        			stop
        			};
                
                // Step1: send RequestADU
				// f_SendAPDU does all necessary filling of fields (if not already done in the template), sends the APDU, logs it together with time
				
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(v_userParameterRequests)}
					)
				);   	  
                                
				//Set timer
                t_step.start(USERDETAILS_TIME1_MAX_TSP);
                
				// Step2: Wait for ProvideUserDetailsADU 
				// Either we receive an APDU containing Provide User Details ADU or the timeout expires
				// timeout expiration is handled in the altstep branch
				// The received Provide Use Details ADU shall have status flag = 2, and an empty list of user details
				// TODO PT140: Check whether the parameterisation of the mw_apduProvideUserDetails template is correct

                alt {
                	[] mtcPort.receive(mw_apduProvideUserDetails{userId := DEFINED_USERID, statusFlag := 2, listOfUserParameters := omit}) -> value v_apduReceived{
                		                    		
 						// Log what we recevived 					
 						f_addLogEntry("The following InfoExchange received. Timer value = " & int2char(t_step.read));
 						f_addLogEntry(any2unistr(v_apduReceived)); //PT140 TODO I would like to include this in the statement above but with a linebreak. Does "\n" work?

                        // Check whether the ADU arrived too soon: the function will set failure and stop the test if so
						f_checkMinimumTime(t_step, USERDETAILS_TIME1_MIN_TSP); // 
 
						// User Details ADU correctly arrived. Stop timer
                        t_step.stop;
						
						// TODO PT140: Check the ADU record and find the one we are expecting. Either function or template
                        
 						//Set verdict
 						setverdict(pass);
 					                              
                         // Step3: Send DefaultAck with correct identifier and set verdict
                        f_wait(USERDETAILS_TIME2_MIN_TSP);
						f_sendAndLogApdu(m_apduDefaultAck(v_apduReceived));

                	}
                } // End of alt statement
				
                f_closeDownMtc();  
			
            } // End of TP_TSP_USERDETAILS_BV_02
        } // End of group Valid_Behaviour
        
        group Invalid_Behaviour {
          testcase TP_TSP_USERDETAILS_BI_01() runs on IutComp system TestAdapter {
             
              /**
              * @desc    TP_TSP_USERDETAILS_BI_01: Verify that the TSP correctly responds to an incorrect RequestADUs of type userDetailsRequest 
              * @remark  [16986:2016], Clause 6.4 and Table A.1/2 AND Table A.7/1  
              */
                // Initialisation
                var boolean v_runOrNot := ICS_A1_2_isTsp and ICS_A7_1_implementedUSERDETAILS;
				f_intialiseMtc(v_runOrNot);  //check if the testcase should be run, activate altsteps on ports, etc
             
				// Step 1: Send two incorrect ADUs with 2 incorrect ADUs
				// TODO PT140: The two incorrect ADUs are identical, because there is no way to send an empty structure as requested by the Test Purpose
				f_sendAndLogApdu(
					m_apduNoSecInit(
						{m_aduRequestProvideUserDetails(omit), m_aduRequestProvideUserDetails(omit)}
					)
				);                               

				// Step 2: wait for a Semantic Error code Nack 

                t_UserDetails_Time1.start;

				// Either we receive an APDU containing Nack with semantic error as error code or the timeout expires
				// timeout expiration handling is in the altstep branch				
				// TODO PT140: Do not know yet how to specify that we want to receive an Ack pointing to the APDU identifier of the just sent APDU
				// TODO PT140: See the syntax of the receive method and the question marks in the parameters
                alt {
                    [] mtcPort.receive(m_apduDefault(??p_apduToRespondTo??, {mw_aduDefaultAck(apduIdentifier := ?, apduAckCode := c_semanticError)})) -> value v_apduReceived {
 						// Log what we received
 						f_logApduReceivedAndTStep();

						//Check minumum time and stop timer
						f_checkMinimumTStep(USERDETAILS_TIME1_MIN_TSP); //t_step is an implicit argument and what we will compare against
                        t_step.stop;
						
						// TODO PT140: Check the ADU record and find the one we are expecting. Either function or template
 
 						//Set verdict
 						setverdict(pass);
                    }
                }  End of alt statement
                f_closeDownMtc();  

             }  End of TP_TSP_USERDETAILS_BI_01
//          
        }
    } 
} // End of module Toll_Service_Provider
