/**
 * @author  PT0140 
 * @desc    This module provides the functions signature for:
 * - external functions
 * - communication support
 * - common Context Data support
 * @remark  These functions are used by preamble/postambule function to initialization/deinitialization communication stack
 * @see     Electronic fee collection (EFC) — Application interface definition for autonomous systems — Part 2: Communication and connections to the lower layers
 * @version $id$
 */
module EfcInfoExchange_Functions language "TTCN-3:2010 Advanced Parameterization" { 

	//importing other modules
	import from EfcInfoExchange_Interfaces all;
	import from EfcInfoExchange_LibUpperTester all;
		
	//importing ASN.1 data automatically translated into TTCN-3	
	import from EfcInfoExchange language "ASN.1:1997" all;

	//importing ASN.1 data manually translated into TTCN-3
	import from EfcInfoExchange_ParameterisedAsn1Data all;
	import from Common_ParametrisedAsn1Data all;


    group External {
        /**
         * @desc    These function initializes the communication stack
         * @return  ERNoError on success, error code otherwise
         * @see     Clauses 7. EFC communication services (functions)
         * @see     Clauses 8. The use of a communication stack)
         */
       external function fx_computeAuthenticator(in InfoExchangeContent p_InfoExchange) return ApduAuthenticator;
         
    } 

	group Internal {
		  
        /**
         * @desc        ADU filtering for received messages on IuTComp
         * @verdict     Unchanged on success, fail otherwise and the component is stopped if PX_ProcessUnexpectedADUAsError is set to true
         */
    	altstep a_defaults() runs on MainTestComponent {
        	var InfoExchange v_infoExchange;
        	//PT140 TODO fix this, should be uncommented
//    		[] mtcPort.receive -> value v_infoExchange {
//                f_addLogEntry("Unexpected APDU received");
//                f_addLogEntry(any2unistr(v_infoExchange));
//                repeat; // Ignore unexpected ADUs, but log them
//            }
    
            [] any timer.timeout {
                f_addLogEntry("Unexpected timeout occured");
                setverdict(inconc);
                stop;
            } // End of any timer.timeout
        } 
 
    	//PT140: need to check ports to be initialised
        //PT140: port names left as those from 17575 tests  
     	function f_intialiseMtc(boolean p_runTestcase) runs on MainTestComponent {
     
     		if (not p_runTestcase) {
     			f_addLogEntry("Testcase shall not be run according to ISO 16986 Implementation Conformance Statement (ICS).");
     			setverdict(inconc);
     			stop;
     		}
     		
     		// Initialize communication stack
            //PT140 TODO is this needed?
            //f_initializeCommunication();
            
            // Map TTCN-3 ports to TestAdapter ports
            map(self:mtcPort, system:taPort);
            map(self:mtcAccessPort, system:taAccessPort);
              
            // Activate message filtering and timeouts altstep
            activate(a_defaults());
            // Activate UpperTester altstep
            activate(a_upperTester());
            
            f_addLogEntry("Initialisations performed. Test case starting.");
    	} 
        
    	function f_closeDownMtc() runs on MainTestComponent {
        	// Deactivate communication stack
        	
        	//PT140 TODO is this needed. Uncomment in that case
            //f_deactivateCommunication();
                
            // Unmap TTCN-3 ports from TestAdapter ports
			unmap(self:mtcPort, system:taPort);
			unmap(self:mtcAccessPort, system:taAccessPort);
                
            //Deactivates all defaults
			deactivate;
            f_addLogEntry("Everything deactivated. Test case ended");
    
        } 
            
    	function f_addLogEntry(in charstring p_text){
    		log("*** " & testcasename() & ":" & p_text);
    	}
    
    	function f_addLogEntrySentApdu (in InfoExchange p_infoExchange){
 			f_addLogEntry("Sent the following APDU to the IUT: " & any2unistr(p_infoExchange));
    	}

    	function f_checkMinimumTime(in timer p_compare, in float p_timeMin) {	                      
            if (p_compare.read <= p_timeMin) {
            	setverdict(fail);
            	f_addLogEntry("minimum time not correct");
            	stop
        	};
    	}  
        	
        // Function which inserts a waiting time - parameter t_wait - and waits in a "do-nothing-loop"
    	function f_wait(in float p_wait) {
    		timer t_waitTime;
    		t_waitTime.start (5.0);
    		while (t_waitTime.running) {
    			// empty loop = do nothing, just wait
    		}
    	}
    	
    	// Function f_prepare_toReceive_InfoExchange to put ADUs together with APCIS and prepare InfoExchange to be received
    	// It  concatenates multiple ADUs into a single stream and prepare APCI accordingly
    	
//    	function f_createInfoExchangeForComparison(in Adus p_infoExchangeAdus) return InfoExchange {
//    		var InfoExchangeContent v_infoExchangeContent;
//    		var InfoExchange v_infoExchange;
//    		v_infoExchangeContent.apci := m_apciFields{apduOriginator := ORIGINATOR, informationSenderID := SENDER, informationrecipientID := TESTER_ID};
//    		v_infoExchangeContent.adus := p_infoExchangeAdus;
//    		v_infoExchange.infoExchangeContent := v_infoExchangeContent;
//    		v_infoExchange.infoExchangeAuthenticator := AnyOrOmit;
//    		f_addLogEntry("Expecting the following infoExchange");
//     		f_addLogEntry(any2unistr(v_infoExchange)); 
//    		return v_infoExchange;
//    	}
    
//    	function f_createInfoExchange(in Adus p_adus, in integer p_apduToAnswer) return InfoExchange {
//    		var InfoExchangeContent v_infoExchangeContent;
//    		var InfoExchange v_infoExchange;
//    		
//    		if (p_apduToAnswer != null) {
//    			v_infoExchangeContent.apci := m_apciFields  { 
//    				apduOriginator := TESTER_ID, 
//    				informationSenderID := TESTER_ID, 
//    				informationrecipientID := ORIGINATOR, 
//    				RelatedApduId.apduOriginator := ORIGINATOR,
//    				RelatedApduId.apduIdentifier := p_apduToAnswer
//    			}
//    		} else {
//    			v_InfoexchangeContent.apci := m_apciFields  { 
//    				apduOriginator := TESTER_ID, 
//    				informationSenderID := TESTER_ID, 
//    				informationrecipientID := ORIGINATOR
//    			}
//    		}
//    		
//    		v_infoexchangeContent.apci.apduIdentifier := float2int(rnd()) * 65535;
//    		v_InfoexchangeContent.adus := p_adus;
//    		v_InfoExchange.infoExchangeContent := v_InfoexchangeContent;
//    		return v_infoExchange;
//    	}
    	
    
	}
}
