/**
 * @author  PT0140 
 * @desc    This module provides the functions signature for:
 * - external functions
 * - communication support
 * - common Context Data support
 * @remark  These functions are used by preamble/postambule function to initialization/deinitialization communication stack
 * @see     Electronic fee collection (EFC) — Application interface definition for autonomous systems — Part 2: Communication and connections to the lower layers
 * @version $id$
 */
module EfcInfoExchange_Functions language "TTCN-3:2010 Advanced Parameterization" { 

	//importing other modules
	import from EfcInfoExchange_Interfaces all;
	import from EfcInfoExchange_LibUpperTester all;
	import from EfcInfoExchange_TesterData all;
		
	//importing ASN.1 data automatically translated into TTCN-3	
	import from EfcInfoExchange language "ASN.1:1997" all;

	//importing ASN.1 data manually translated into TTCN-3
	import from EfcInfoExchange_ParameterisedAsn1Data all;
	import from Common_ParametrisedAsn1Data all;

    group External {
		external function fx_computeAuthenticator(in InfoExchangeContent p_InfoExchange) return ApduAuthenticator;
		external function fx_evaluateAuthenticator(in ApduAuthenticator p_apduAuthenticator) return boolean;
    	external function fx_getUtc(in integer secondOffset:= 0) return GeneralizedTime; //Should current time offset by the number of seconds (positive or negative) specified by the parameter secondOffset
    } 

	group Internal {
		  
    	altstep a_defaults() runs on MainTestComponent {
    		[] mtcPort.receive(InfoExchange:?) -> value v_apduReceived {
                f_addLogEntry("Unexpected APDU received");
				f_logApduReceivedAndTStep();
                repeat; // Ignore unexpected ADUs, but log them
            }
    
            [] t_step.timeout {
                f_addLogEntry("Current step in the message sequence timed out");
                setverdict(fail);
                stop;
            } 
            
			[] t_transaction.timeout {
                f_addLogEntry("Running the entire transaction took longer than timeout set in module parameter INITIALISE_TRANSACTION_TIMEOUT");
                setverdict(inconc);
                stop;
            } 
        } 
 
     	function f_intialiseMtc(boolean p_runTestcase) runs on MainTestComponent {
     
     		if (not p_runTestcase) {
     			f_addLogEntry("Testcase shall not be run according to ISO 16986 Implementation Conformance Statement (ICS).");
     			setverdict(none);
     			stop;
     		}
     		
     		// Initialize communication stack
            //PT140 TODO is this needed?
            //f_initializeCommunication();
            
            // Map TTCN-3 ports to TestAdapter ports
            map(mtc:mtcPort, system:taPort);
            map(mtc:mtcAccessPort, system:taAccessPort);
              
            // Activate message filtering and timeouts altstep
            activate(a_defaults());
            // Activate UpperTester altstep
            activate(a_upperTester());
            
            f_addLogEntry("Initialisations performed. Test case starting.");
			
    	} 
        
    	function f_closeDownMtc() runs on MainTestComponent {
        	// Deactivate communication stack
        	
        	//PT140 TODO is this needed. Uncomment in that case
            //f_deactivateCommunication();
                
            // Unmap TTCN-3 ports from TestAdapter ports
			unmap(self:mtcPort, system:taPort);
			unmap(self:mtcAccessPort, system:taAccessPort);
                
            //Deactivates all defaults
			deactivate;
            f_addLogEntry("Test case ended.");
    
        } 
        
        //defining a string that means carrige return (new line) through its ascii value
	    const charstring c_newLine := int2char(13);

        function f_sendAndLogApdu(in InfoExchange p_apduToSend) runs on MainTestComponent {
        	mtcPort.send(p_apduToSend);   	  
			f_addLogEntry("Sent the following APDU to the IUT: " & any2unistr(p_apduToSend));
		}
		
		function f_sendAndLogTrigger(in Iso16986Trigger iut_Trigger) runs on MainTestComponent {
		  	mtcAccessPort.send(iut_Trigger);
		  	f_addLogEntry("Sent the following Trigger to the IUT: " & any2unistr(iut_Trigger));
		}
           
    	function f_addLogEntry(in charstring p_text){
    		log("*** " & testcasename() & ":" & p_text);
    	}

        /**
         * @desc Function to log received APDUs. It assumes that
         * @desc the received APDU is stored in the MainTestComponent
         * @desc v_apduReceived and that the MainTestComponent t_step timer 
         * @desc is used and running (otherwise it is set back to 0)
         */		
		function f_logApduReceivedAndTStep() runs on MainTestComponent{
			f_addLogEntry("At time step value " & any2unistr(t_step.read) & ", sent the following APDU to the IUT: " & c_newLine & any2unistr(v_apduReceived));			
		}		

//TODO this is never used. Needed somewhere?
//		function f_userDetailsParameters(out UserParametersRequest v_userParameterRequest)  runs on MainTestComponent {
//		/**		
//		 * @desc we want to ask for a random number of parameters randomly chosen among those supported
//		 * @desc the v_userParameterRequest array will be made of a random number of elements containing randomly picked up
//		 * @desc parameter identifiers from the list of supported parameters (PIXIT value)
//		*/
//				const integer totNoParams := sizeof(USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS);
//				const integer noParamsToUse := float2int(rnd() * int2float(totNoParams));
//				var UserParameterRequest v_userParameterRequests[noParamsToUse];   
//				for (var integer v_ct :=0; v_ct<noParamsToUse;v_ct:=v_ct+1) {
//					//Note: float2int removes the fractional part and returns just the integer, it is NOT a rounding function. That is why this works
//					v_userParameterRequests[v_ct] := USERDETAILS_SUPPORTED_LIST_OF_PARAMETERS[float2int(rnd()) * totNoParams];
//					continue;			
//				};
//			  
//		}
		  
    	function f_checkMinimumTStep(in float p_timeMin) runs on MainTestComponent {	                      
            if (t_step.read <= p_timeMin) {
            	setverdict(fail);
            	f_addLogEntry("Received APDU before minimum wait time at: " & any2unistr(t_step.read));
            	stop
        	};
    	}
    	// function to set a variable with the DSRC system description
    	function f_setDsrcContextData(in Iso17575_3AduBody v_ContextDescription)  runs on MainTestComponent {
    	  v_ContextDescription.tollContextOverview := tollContextOverviewTESTER_VALUE;
    	  v_ContextDescription.tollContextPartitionOverview := tollContextPartitionOverviewTESTER_VALUE;
    	  v_ContextDescription.tariffTable := tariffTableTESTER_VALUE;
    	  v_ContextDescription.currencyConversionTable := currencyConversionTableTESTER_VALUE;
    	  v_ContextDescription.tariffClassDefinition := optSignedTariffClassDefinitionTESTER_VALUE;
    	  v_ContextDescription.localVehicleClassDefinition := optSignedLocalVehicleClassDefinitionTESTER_VALUE;
    	  v_ContextDescription.timeClassDefinition := optSignedTimeClassDefinitionTESTER_VALUE;
    	  v_ContextDescription.userClassDefinition := optSignedUserClassDefinitionTESTER_VALUE;
    	  v_ContextDescription.tollContextLayout := tollContextLayoutTESTER_VALUE;
    	  v_ContextDescription.chargeReportingEvents := chargeReportingEventsTESTER_VALUE;
    	  v_ContextDescription.chargeReportConfiguration := chargeReportConfigurationTESTER_VALUE;
    	  v_ContextDescription.tollContextVersion := tollContextVersionTESTER_VALUE;
    	  
    	}
		       	
        // Function which inserts a waiting time - parameter t_wait - and waits in a "do-nothing-loop"
    	function f_wait(in float p_wait){
    		timer t_waitTime;
    		t_waitTime.start(p_wait);
    		while (t_waitTime.running) {
    			// empty loop = do nothing, just wait
    		}
    	} 	
	}
}
